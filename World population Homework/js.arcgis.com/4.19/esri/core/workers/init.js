// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
(function(a, k) {
    var w = function() {
            return "undefined" !== typeof u && "function" !== typeof u ? u : "undefined" !== typeof window ? window : "undefined" !== typeof self ? self : this
        }(),
        t = function() {},
        r = function(N) {
            for (var T in N) return 0;
            return 1
        },
        f = {}.toString,
        b = function(N) {
            return "[object Function]" == f.call(N)
        },
        c = function(N) {
            return "[object String]" == f.call(N)
        },
        g = function(N) {
            return "[object Array]" == f.call(N)
        },
        e = function(N, T) {
            if (N)
                for (var aa = 0; aa < N.length;) T(N[aa++])
        },
        d = function(N, T) {
            for (var aa in T) N[aa] = T[aa];
            return N
        },
        h = function(N, T) {
            return d(Error(N), {
                src: "dojoLoader",
                info: T
            })
        },
        p = 1,
        l = function() {
            return "_" + p++
        },
        n = function(N, T, aa) {
            return za(N, T, aa, 0, n)
        },
        u = w,
        y = u.document,
        x = y && y.createElement("DiV"),
        q = n.has = function(N) {
            return b(B[N]) ? B[N] = B[N](u, y, x) : B[N]
        },
        B = q.cache = k.hasCache;
    b(a) && (a = a(w));
    q.add = function(N, T, aa, fa) {
        (void 0 === B[N] || fa) && (B[N] = T);
        return aa && q(N)
    };
    q.add("host-webworker", "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope);
    q("host-webworker") && (d(k.hasCache, {
        "host-browser": 0,
        dom: 0,
        "dojo-dom-ready-api": 0,
        "dojo-sniff": 0,
        "dojo-inject-api": 1,
        "host-webworker": 1,
        "dojo-guarantee-console": 0
    }), k.loaderPatch = {
        injectUrl: function(N, T) {
            try {
                importScripts(N), T()
            } catch (aa) {
                console.info("failed to load resource (" + N + ")"), console.error(aa)
            }
        }
    });
    for (var z in a.has) q.add(z, a.has[z], 0, 1);
    n.async = 1;
    var v = q("csp-restrictions") ? function() {} : new Function("return eval(arguments[0]);");
    n.eval = function(N, T) {
        return v(N + "\r\n//# sourceURL\x3d" + T)
    };
    var A = {},
        m = n.signal = function(N, T) {
            N = A[N];
            e(N && N.slice(0),
                function(aa) {
                    aa.apply(null, g(T) ? T : [T])
                })
        };
    z = n.on = function(N, T) {
        var aa = A[N] || (A[N] = []);
        aa.push(T);
        return {
            remove: function() {
                for (var fa = 0; fa < aa.length; fa++)
                    if (aa[fa] === T) {
                        aa.splice(fa, 1);
                        break
                    }
            }
        }
    };
    var E = [],
        C = {},
        G = [],
        F = {},
        D = n.map = {},
        H = [],
        I = {},
        Q = "",
        P = {},
        Y = {};
    w = {};
    var W = 0;
    if (!q("foreign-loader")) var X = function(N, T) {
        T = !1 !== T;
        var aa, fa;
        for (aa in Y) {
            var ja = Y[aa];
            if (fa = aa.match(/^url:(.+)/)) P["url:" + ua(fa[1], N)] = ja;
            else if ("*now" == aa) var ia = ja;
            else "*noref" != aa && (fa = S(aa, N, !0), P[fa.mid] = P["url:" + fa.url] = ja)
        }
        ia &&
            ia(Aa(N));
        T && (Y = {})
    };
    var ba = function(N) {
            return N.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(T) {
                return "\\" + T
            })
        },
        V = function(N, T) {
            T.splice(0, T.length);
            for (var aa in N) T.push([aa, N[aa], new RegExp("^" + ba(aa) + "(/|$)"), aa.length]);
            T.sort(function(fa, ja) {
                return ja[3] - fa[3]
            });
            return T
        },
        ca = function(N, T) {
            e(N, function(aa) {
                T.push([c(aa[0]) ? new RegExp("^" + ba(aa[0]) + "$") : aa[0], aa[1]])
            })
        },
        ea = function(N) {
            var T = N.name;
            T || (T = N, N = {
                name: T
            });
            N = d({
                main: "main"
            }, N);
            N.location = N.location ? N.location : T;
            N.packageMap && (D[T] =
                N.packageMap);
            N.main.indexOf("./") || (N.main = N.main.substring(2));
            F[T] = N
        },
        sa = [],
        ma = function(N, T, aa) {
            for (var fa in N) {
                "waitSeconds" == fa && (n.waitms = 1E3 * (N[fa] || 0));
                "cacheBust" == fa && (Q = N[fa] ? c(N[fa]) ? N[fa] : (new Date).getTime() + "" : "");
                if ("baseUrl" == fa || "combo" == fa) n[fa] = N[fa];
                N[fa] !== B && (n.rawConfig[fa] = N[fa], "has" != fa && q.add("config-" + fa, N[fa], 0, T))
            }
            n.baseUrl || (n.baseUrl = "./");
            /\/$/.test(n.baseUrl) || (n.baseUrl += "/");
            for (fa in N.has) q.add(fa, N.has[fa], 0, T);
            e(N.packages, ea);
            for (var ja in N.packagePaths) e(N.packagePaths[ja],
                function(ia) {
                    var va = ja + "/" + ia;
                    c(ia) && (ia = {
                        name: ia
                    });
                    ia.location = va;
                    ea(ia)
                });
            V(d(D, N.map), H);
            e(H, function(ia) {
                ia[1] = V(ia[1], []);
                "*" == ia[0] && (H.star = ia)
            });
            V(d(C, N.paths), G);
            ca(N.aliases, E);
            if (!q("foreign-loader")) {
                if (T) sa.push({
                    config: N.config
                });
                else
                    for (fa in N.config) T = pa(fa, aa), T.config = d(T.config || {}, N.config[fa]);
                N.cache && (X(), Y = N.cache, X(0, !!N.cache["*noref"]))
            }
            m("config", [N, n.rawConfig])
        };
    if (q("dojo-cdn")) {
        var ra = y.getElementsByTagName("script");
        var ta = 0;
        for (var qa, la, na, xa; ta < ra.length;)
            if (qa =
                ra[ta++], (na = qa.getAttribute("src")) && (xa = na.match(/(((.*)\/)|^)dojo\.js(\W|$)/i)) && (la = xa[3] || "", k.baseUrl = k.baseUrl || la, W = qa), na = qa.getAttribute("data-dojo-config") || qa.getAttribute("djConfig")) w = n.eval("({ " + na + " })", "data-dojo-config"), W = qa
    }
    n.rawConfig = {};
    ma(k, 1);
    q("dojo-cdn") && ((F.dojo.location = la) && (la += "/"), F.dijit.location = la + "../dijit/", F.dojox.location = la + "../dojox/");
    ma(a, 1);
    ma(w, 1);
    if (!q("foreign-loader")) var wa = function(N) {
            La(function() {
                e(N.deps, Va)
            })
        },
        za = function(N, T, aa, fa, ja) {
            var ia;
            if (c(N)) {
                if ((ia = pa(N, fa, !0)) && ia.executed) return ia.result;
                throw h("undefinedModule", N);
            }
            g(N) || (ma(N, 0, fa), N = T, T = aa);
            if (g(N))
                if (N.length) {
                    aa = "require*" + l();
                    for (var va, Ea = [], Fa = 0; Fa < N.length;) va = N[Fa++], Ea.push(pa(va, fa));
                    ia = d(K("", aa, 0, ""), {
                        injected: 2,
                        deps: Ea,
                        def: T || t,
                        require: fa ? fa.require : n,
                        gc: 1
                    });
                    I[ia.mid] = ia;
                    wa(ia);
                    var Ma = Ga && !0;
                    La(function() {
                        Na(ia, Ma)
                    });
                    ia.executed || ya.push(ia);
                    Oa()
                } else T && T();
            return ja
        },
        Aa = function(N) {
            if (!N) return n;
            var T = N.require;
            T || (T = function(aa, fa, ja) {
                return za(aa, fa, ja,
                    N, T)
            }, N.require = d(T, n), T.module = N, T.toUrl = function(aa) {
                return ua(aa, N)
            }, T.toAbsMid = function(aa) {
                return oa(aa, N)
            });
            return T
        },
        ya = [],
        L = [],
        R = {},
        U = function(N) {
            N.injected = 1;
            R[N.mid] = 1;
            N.url && (R[N.url] = N.pack || 1);
            ab()
        },
        da = function(N) {
            N.injected = 2;
            delete R[N.mid];
            N.url && delete R[N.url];
            r(R) && bb()
        },
        ka = n.idle = function() {
            return !L.length && r(R) && !ya.length && !Ga
        };
    var M = function(N, T) {
            if (T)
                for (var aa = 0; aa < T.length; aa++)
                    if (T[aa][2].test(N)) return T[aa];
            return 0
        },
        J = function(N) {
            var T = [];
            for (N = N.replace(/\\/g, "/").split("/"); N.length;) {
                var aa =
                    N.shift();
                if (".." == aa && T.length && ".." != fa) {
                    T.pop();
                    var fa = T[T.length - 1]
                } else "." != aa && T.push(fa = aa)
            }
            return T.join("/")
        },
        K = function(N, T, aa, fa) {
            return {
                pid: N,
                mid: T,
                pack: aa,
                url: fa,
                executed: 0,
                def: 0
            }
        },
        O = function(N, T, aa, fa, ja, ia, va, Ea, Fa, Ma) {
            var Da, Wa, Ba;
            var Pa = /^\./.test(N);
            if (/(^\/)|(:)|(\.js$)/.test(N) || Pa && !T) return K(0, N, 0, N);
            N = J(Pa ? T.mid + "/../" + N : N);
            if (/^\./.test(N)) throw h("irrationalPath", N);
            Ma || Pa || !ia.star || (Ba = M(N, ia.star[1]));
            !Ba && T && (Ba = (Ba = M(T.mid, ia)) && M(N, Ba[1]));
            Ba && (N = Ba[1] + N.substring(Ba[3]));
            T = (xa = N.match(/^([^\/]+)(\/(.+))?$/)) ? xa[1] : "";
            (Da = aa[T]) ? N = T + "/" + (Wa = xa[3] || Da.main): T = "";
            var Qa = 0;
            e(Ea, function(Ha) {
                var Xa = N.match(Ha[0]);
                Xa && 0 < Xa.length && (Qa = b(Ha[1]) ? N.replace(Ha[0], Ha[1]) : Ha[1])
            });
            if (Qa) return O(Qa, 0, aa, fa, ja, ia, va, Ea, Fa);
            if (aa = fa[N]) return Fa ? K(aa.pid, aa.mid, aa.pack, aa.url) : fa[N];
            fa = (Ba = M(N, va)) ? Ba[1] + N.substring(Ba[3]) : T ? ("/" === Da.location.slice(-1) ? Da.location.slice(0, -1) : Da.location) + "/" + Wa : N;
            /(^\/)|(:)/.test(fa) || (fa = ja + fa);
            return K(T, N, Da, J(fa + ".js"))
        },
        S = function(N, T, aa) {
            return O(N,
                T, F, I, n.baseUrl, H, G, E, void 0, aa)
        };
    if (!q("foreign-loader")) var Z = function(N, T, aa) {
            return N.normalize ? N.normalize(T, function(fa) {
                return oa(fa, aa)
            }) : oa(T, aa)
        },
        ha = 0,
        pa = function(N, T, aa) {
            var fa;
            if (fa = N.match(/^(.+?)!(.*)$/)) {
                var ja = pa(fa[1], T, aa);
                5 !== ja.executed || ja.load || Ra(ja);
                ja.load ? (fa = Z(ja, fa[2], T), N = ja.mid + "!" + (ja.dynamic ? ++ha + "!" : "") + fa) : (fa = fa[2], N = ja.mid + "!" + ++ha + "!waitingForPlugin");
                N = {
                    plugin: ja,
                    mid: N,
                    req: Aa(T),
                    prid: fa
                }
            } else N = S(N, T);
            return I[N.mid] || !aa && (I[N.mid] = N)
        };
    var oa = n.toAbsMid = function(N,
            T) {
            return S(N, T).mid
        },
        ua = n.toUrl = function(N, T) {
            T = S(N + "/x", T);
            var aa = T.url;
            return Ya(0 === T.pid ? N : aa.substring(0, aa.length - 5))
        };
    if (!q("foreign-loader")) {
        var Ca = {
            injected: 2,
            executed: 5,
            def: 3,
            result: 3
        };
        la = function(N) {
            return I[N] = d({
                mid: N
            }, Ca)
        };
        var Ia = la("require"),
            cb = la("exports"),
            db = la("module"),
            Ja = {},
            Sa = 0,
            Ra = function(N) {
                var T = N.result;
                N.dynamic = T.dynamic;
                N.normalize = T.normalize;
                N.load = T.load;
                return N
            },
            eb = function(N) {
                var T = {};
                e(N.loadQ, function(ja) {
                    var ia = Z(N, ja.prid, ja.req.module),
                        va = N.dynamic ? ja.mid.replace(/waitingForPlugin$/,
                            ia) : N.mid + "!" + ia;
                    ia = d(d({}, ja), {
                        mid: va,
                        prid: ia,
                        injected: 0
                    });
                    I[va] && I[va].injected || Za(I[va] = ia);
                    T[ja.mid] = I[va];
                    da(ja);
                    delete I[ja.mid]
                });
                N.loadQ = 0;
                var aa = function(ja) {
                        for (var ia = ja.deps || [], va = 0; va < ia.length; va++)(ja = T[ia[va].mid]) && (ia[va] = ja)
                    },
                    fa;
                for (fa in I) aa(I[fa]);
                e(ya, aa)
            },
            Ta = function(N) {
                n.trace("loader-finish-exec", [N.mid]);
                N.executed = 5;
                N.defOrder = Sa++;
                N.loadQ && (Ra(N), eb(N));
                for (ta = 0; ta < ya.length;) ya[ta] === N ? ya.splice(ta, 1) : ta++;
                /^require\*/.test(N.mid) && delete I[N.mid]
            },
            fb = [],
            Na = function(N,
                T) {
                if (4 === N.executed) return n.trace("loader-circular-dependency", [fb.concat(N.mid).join("-\x3e")]), !N.def || T ? Ja : N.cjs && N.cjs.exports;
                if (!N.executed) {
                    if (!N.def) return Ja;
                    var aa = N.mid,
                        fa = N.deps || [],
                        ja, ia = [],
                        va = 0;
                    for (N.executed = 4; ja = fa[va++];) {
                        ja = ja === Ia ? Aa(N) : ja === cb ? N.cjs.exports : ja === db ? N.cjs : Na(ja, T);
                        if (ja === Ja) return N.executed = 0, n.trace("loader-exec-module", ["abort", aa]), Ja;
                        ia.push(ja)
                    }
                    n.trace("loader-run-factory", [N.mid]);
                    T = N.def;
                    ia = b(T) ? T.apply(null, ia) : T;
                    N.result = void 0 === ia && N.cjs ? N.cjs.exports :
                        ia;
                    Ta(N)
                }
                return N.result
            },
            Ga = 0,
            La = function(N) {
                try {
                    Ga++, N()
                } catch (T) {
                    throw T;
                } finally {
                    Ga--
                }
                ka() && m("idle", [])
            },
            Oa = function() {
                Ga || La(function() {
                    for (var N, T, aa = 0; aa < ya.length;) N = Sa, T = ya[aa], Na(T), N != Sa ? aa = 0 : aa++
                })
            }
    }
    var Ya = "function" == typeof a.fixupUrl ? a.fixupUrl : function(N) {
        N += "";
        return N + (Q ? (/\?/.test(N) ? "\x26" : "?") + Q : "")
    };
    void 0 === q("dojo-loader-eval-hint-url") && q.add("dojo-loader-eval-hint-url", 1);
    var Za = function(N) {
            var T = N.plugin;
            5 !== T.executed || T.load || Ra(T);
            var aa = function(fa) {
                N.result = fa;
                da(N);
                Ta(N);
                Oa()
            };
            T.load ? T.load(N.prid, N.req, aa) : T.loadQ ? T.loadQ.push(N) : (T.loadQ = [N], ya.unshift(T), Va(T))
        },
        Ka = 0,
        gb = function(N, T) {
            q("config-stripStrict") && (N = N.replace(/(["'])use strict\1/g, ""));
            N === Ka ? Ka.call(null) : n.eval(N, q("dojo-loader-eval-hint-url") ? T.url : T.mid)
        },
        Va = function(N) {
            var T = N.mid,
                aa = N.url;
            if (!(N.executed || N.injected || R[T] || N.url && (N.pack && R[N.url] === N.pack || 1 == R[N.url])))
                if (U(N), N.plugin) Za(N);
                else {
                    var fa = function() {
                        hb(N);
                        if (2 !== N.injected) {
                            if (q("dojo-enforceDefine")) {
                                m("error", h("noDefine",
                                    N));
                                return
                            }
                            da(N);
                            d(N, Ca);
                            n.trace("loader-define-nonmodule", [N.url])
                        }
                        Oa()
                    };
                    (Ka = P[T] || P["url:" + N.url]) ? (n.trace("loader-inject", ["cache", N.mid, aa]), gb(Ka, N), fa()) : (n.trace("loader-inject", ["script", N.mid, aa]), n.injectUrl(Ya(aa), fa, N))
                }
        },
        $a = function(N, T, aa) {
            n.trace("loader-define-module", [N.mid, T]);
            if (2 === N.injected) return m("error", h("multipleDefine", N)), N;
            d(N, {
                deps: T,
                def: aa,
                cjs: {
                    id: N.mid,
                    uri: N.url,
                    exports: N.result = {},
                    setExports: function(ja) {
                        N.cjs.exports = ja
                    },
                    config: function() {
                        return N.config
                    }
                }
            });
            for (var fa =
                    0; T[fa]; fa++) T[fa] = pa(T[fa], N);
            da(N);
            b(aa) || T.length || (N.result = aa, Ta(N));
            return N
        },
        hb = function(N, T) {
            for (var aa = [], fa, ja; L.length;) ja = L.shift(), T && (ja[0] = T.shift()), fa = ja[0] && pa(ja[0]) || N, aa.push([fa, ja[1], ja[2]]);
            X(N);
            e(aa, function(ia) {
                wa($a.apply(null, ia))
            })
        },
        bb = t,
        ab = t;
    q("dom");
    if (q("dom")) {
        var Ua = function(N, T, aa, fa) {
                N.addEventListener(T, fa, !1);
                return function() {
                    N.removeEventListener(T, fa, !1)
                }
            },
            ib = Ua(window, "load", "onload", function() {
                n.pageLoaded = 1;
                try {
                    "complete" != y.readyState && (y.readyState = "complete")
                } catch (N) {}
                ib()
            });
        ra = y.getElementsByTagName("script");
        for (ta = 0; !W;) /^dojo/.test((qa = ra[ta++]) && qa.type) || (W = qa);
        n.injectUrl = function(N, T, aa) {
            aa = aa.node = y.createElement("script");
            var fa = Ua(aa, "load", "onreadystatechange", function(ia) {
                    ia = ia || window.event;
                    var va = ia.target || ia.srcElement;
                    if ("load" === ia.type || /complete|loaded/.test(va.readyState)) fa(), ja(), T && T()
                }),
                ja = Ua(aa, "error", "onerror", function(ia) {
                    fa();
                    ja();
                    m("error", h("scriptError: " + N, [N, ia]))
                });
            aa.type = "text/javascript";
            aa.charset = "utf-8";
            aa.src = N;
            W.parentNode.insertBefore(aa,
                W);
            return aa
        }
    }
    n.log = t;
    n.trace = t;
    q("foreign-loader") ? qa = t : (qa = function(N, T, aa) {
        var fa = arguments.length,
            ja = ["require", "exports", "module"],
            ia = [0, N, T];
        1 == fa ? ia = [0, b(N) ? ja : [], N] : 2 == fa && c(N) ? ia = [N, b(T) ? ja : [], T] : 3 == fa && (ia = [N, T, aa]);
        n.trace("loader-define", ia.slice(0, 2));
        (fa = ia[0] && pa(ia[0])) && !R[fa.mid] ? wa($a(fa, ia[1], ia[2])) : L.push(ia)
    }, qa.amd = {
        vendor: "dojotoolkit.org"
    });
    d(d(n, k.loaderPatch), a.loaderPatch);
    z("error", function(N) {
        try {
            if (console.error(N), N instanceof Error) {
                for (var T in N) console.log(T + ":",
                    N[T]);
                console.log(".")
            }
        } catch (aa) {}
    });
    d(n, {
        uid: l,
        cache: P,
        packs: F
    });
    u.define || (u.define = qa, u.require = n, q("foreign-loader") || (e(sa, function(N) {
        ma(N)
    }), qa = w.deps || a.deps || k.deps, a = w.callback || a.callback || k.callback, n.boot = qa || a ? [qa || [], a] : 0))
})(function(a) {
    return a.dojoConfig || a.djConfig || a.require || {}
}, {
    async: 1,
    baseUrl: "https://js.arcgis.com/4.19/dojo",
    hasCache: {
        "config-selectorEngine": "lite",
        "config-tlmSiblingOfDojo": 1,
        "dojo-built": 1,
        "dojo-loader": 1,
        dom: 1,
        "host-browser": 1
    },
    packages: [{
        location: ".",
        name: "dojo"
    }, {
        location: "../dijit",
        name: "dijit"
    }, {
        location: "../dojox",
        name: "dojox"
    }, {
        location: "../dgrid",
        main: "OnDemandGrid",
        name: "dgrid"
    }, {
        location: "../dstore",
        main: "Store",
        name: "dstore"
    }, {
        location: "../esri",
        name: "esri"
    }, {
        location: "../moment",
        main: "moment",
        name: "moment"
    }, {
        location: "../tslib",
        main: "tslib",
        name: "tslib"
    }]
});
require({
    cache: {
        "esri/config": function() {
            define(["module", "./core/global", "./core/has", "./core/object"], function(a, k, w, t) {
                w = {
                    apiKey: void 0,
                    applicationUrl: k.location && k.location.href,
                    assetsPath: "",
                    fontsUrl: "https://static.arcgis.com/fonts",
                    geometryService: null,
                    geometryServiceUrl: "https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer",
                    geoRSSServiceUrl: "https://utility.arcgis.com/sharing/rss",
                    kmlServiceUrl: "https://utility.arcgis.com/sharing/kml",
                    portalUrl: "https://www.arcgis.com",
                    workers: {
                        loaderConfig: {
                            has: {},
                            paths: {},
                            map: {},
                            packages: []
                        }
                    },
                    request: {
                        httpsDomains: "arcgis.com arcgisonline.com esrikr.com premiumservices.blackbridge.com esripremium.accuweather.com gbm.digitalglobe.com firstlook.digitalglobe.com msi.digitalglobe.com".split(" "),
                        interceptors: [],
                        maxUrlLength: 2E3,
                        proxyRules: [],
                        proxyUrl: null,
                        timeout: 6E4,
                        trustedServers: [],
                        useIdentity: !0
                    },
                    log: {
                        interceptors: [],
                        level: null
                    }
                };
                k.esriConfig && (t.deepMerge(w, k.esriConfig, !0), delete w.has);
                w.assetsPath || (a = (new URL(a.uri, document.baseURI)).href,
                    w.assetsPath = a.slice(0, a.indexOf("esri/")));
                w.baseUrl && console.warn("[esri.config]", "baseUrl has been replaced by assetsPath");
                Object.defineProperty(w, "baseUrl", {
                    set() {
                        console.warn("[esri.config]", "baseUrl has been replaced by assetsPath")
                    }
                });
                w.request.corsEnabledServers = [];
                w.request.corsEnabledServers.push = function() {
                    console.warn("[esri.config]", "request.corsEnabledServers is not supported and will be removed in a future release. See http://esriurl.com/cors8664");
                    return 0
                };
                return w
            })
        },
        "esri/core/global": function() {
            define(function() {
                return function() {
                    if ("undefined" !==
                        typeof globalThis) return globalThis;
                    if ("undefined" !== typeof self) return self;
                    if ("undefined" !== typeof window) return window;
                    if ("undefined" !== typeof global) return global
                }()
            })
        },
        "esri/core/has": function() {
            define(["./global"], function(a) {
                function k(c) {
                    return "function" === typeof r[c] ? r[c] = r[c](a) : r[c]
                }
                var w, t;
                let r;
                if (null != (w = a.dojoConfig) && w.has || null != (t = a.esriConfig) && t.has) {
                    var f, b;
                    r = { ...null == (f = a.dojoConfig) ? void 0 : f.has,
                        ...null == (b = a.esriConfig) ? void 0 : b.has
                    }
                } else r = {};
                k.add = (c, g, e, d) => {
                    if (d || "undefined" ===
                        typeof r[c]) r[c] = g;
                    return e && k(c)
                };
                k.cache = r;
                k.add("esri-deprecation-warnings", !0);
                (() => {
                    k.add("host-webworker", "undefined" !== typeof a.WorkerGlobalScope && self instanceof a.WorkerGlobalScope);
                    var c = "undefined" !== typeof window && "undefined" !== typeof location && "undefined" !== typeof document && window.location === location && window.document === document;
                    k.add("host-browser", c);
                    k.add("dom", c);
                    if (k("host-browser")) {
                        var g = navigator;
                        c = g.userAgent;
                        g = g.appVersion;
                        const d = parseFloat(g);
                        k.add("edge", parseFloat(c.split("Edge/")[1]) ||
                            void 0);
                        k.add("webkit", !k("edge") && parseFloat(c.split("WebKit/")[1]) || void 0);
                        k.add("chrome", !k("edge") && parseFloat(c.split("Chrome/")[1]) || void 0);
                        k.add("safari", 0 <= g.indexOf("Safari") && !k("chrome") && !k("edge") ? parseFloat(g.split("Version/")[1]) : void 0);
                        k.add("mac", 0 <= g.indexOf("Macintosh"));
                        if (c.match(/(iPhone|iPod|iPad)/)) {
                            const h = RegExp.$1.replace(/P/, "p");
                            var e = c.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
                            e = parseFloat(e.replace(/_/, ".").replace(/_/g, ""));
                            k.add(h, e);
                            k.add("ios", e)
                        }
                        k.add("trident", parseFloat(g.split("Trident/")[1]) ||
                            void 0);
                        k("webkit") || (0 <= c.indexOf("Opera") && k.add("opera", 9.8 <= d ? parseFloat(c.split("Version/")[1]) || d : d), 0 <= c.indexOf("Gecko") && !k("trident") && !k("edge") && k.add("mozilla", d), k("mozilla") && k.add("ff", parseFloat(c.split("Firefox/")[1] || c.split("Minefield/")[1]) || void 0))
                    }
                })();
                (() => {
                    if (a.navigator) {
                        var c = navigator.userAgent;
                        const g = c.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i);
                        c = c.match(/iPhone/i);
                        g && k.add("esri-mobile", g);
                        c && k.add("esri-iPhone", c);
                        k.add("esri-geolocation", !!navigator.geolocation)
                    }
                    k.add("esri-canvas-svg-support", !k("trident"));
                    k.add("esri-wasm", "WebAssembly" in a);
                    k.add("esri-shared-array-buffer", () => {
                        const g = !1 === a.crossOriginIsolated;
                        return "SharedArrayBuffer" in a && !g
                    });
                    k.add("esri-atomics", "Atomics" in a);
                    k.add("esri-workers", "Worker" in a);
                    k.add("esri-text-decoder", "TextDecoder" in a);
                    k.add("esri-text-encoder", "TextEncoder" in a);
                    k.add("featurelayer-snapshot-enabled", !0);
                    k.add("featurelayer-snapshot-point-min-threshold", 8E4);
                    k.add("featurelayer-snapshot-point-max-threshold",
                        4E5);
                    k.add("featurelayer-snapshot-point-coverage", .1);
                    k.add("featurelayer-advanced-symbols", !1);
                    k.add("featurelayer-pbf", !0);
                    k.add("featurelayer-pbf-statistics", !1);
                    k.add("feature-layers-workers", !0);
                    k.add("mapview-transitions-duration", 200);
                    k.add("mapserver-pbf-enabled", !1);
                    !k("host-webworker") && k("host-browser") && (k.add("csp-restrictions", () => {
                        try {
                            new Function
                        } catch {
                            return !0
                        }
                        return !1
                    }), k.add("esri-image-decode", () => {
                        if ("decode" in new Image) {
                            const g = new Image;
                            g.src = 'data:image/svg+xml;charset\x3dUTF-8,\x3csvg version\x3d"1.1" xmlns\x3d"http://www.w3.org/2000/svg"\x3e\x3c/svg\x3e';
                            g.decode().then(() => {
                                k.add("esri-image-decode", !0, !0, !0)
                            }).catch(() => {
                                k.add("esri-image-decode", !1, !0, !0)
                            })
                        } else return !1
                    }), k.add("esri-url-encodes-apostrophe", () => {
                        const g = a.document.createElement("a");
                        g.href = "?'";
                        return -1 < g.href.indexOf("?%27")
                    }), k.add("vectortilelayer-max-buffers", () => k("ff") ? 160 : Number.POSITIVE_INFINITY))
                })();
                return k
            })
        },
        "esri/core/object": function() {
            define(["exports", "./lang"], function(a, k) {
                function w(r, f, b) {
                    for (const c of r) {
                        if (null == b) return;
                        if (!(c in b))
                            if (f) b[c] = {};
                            else return;
                        b = b[c]
                    }
                    return b
                }

                function t(r, f, b) {
                    return f ? Object.keys(f).reduce(function(c, g) {
                        let e = c[g],
                            d = f[g];
                        if (e === d) return c;
                        if (void 0 === e) return c[g] = k.clone(d), c;
                        if (Array.isArray(d) || Array.isArray(c)) e = e ? Array.isArray(e) ? c[g] = e.concat() : c[g] = [e] : c[g] = [], d && (Array.isArray(d) || (d = [d]), b ? d.forEach(h => {
                            -1 === e.indexOf(h) && e.push(h)
                        }) : c[g] = d.concat());
                        else if (d && "object" === typeof d) c[g] = t(e, d, b);
                        else if (!c.hasOwnProperty(g) || f.hasOwnProperty(g)) c[g] = d;
                        return c
                    }, r || {}) : r
                }
                a.deepMerge = function(r, f, b = !1) {
                    return t(r,
                        f, b)
                };
                a.getDeepValue = function(r, f) {
                    if (null != f) return f[r] || w(r.split("."), !1, f)
                };
                a.setDeepValue = function(r, f, b) {
                    const c = r.split(".");
                    r = c.pop();
                    (b = w(c, !0, b)) && r && (b[r] = f)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/lang": function() {
            define(["exports", "./has", "./typedArrayUtil"], function(a, k, w) {
                function t(f, b) {
                    let c;
                    if (b)
                        for (c in f) f.hasOwnProperty(c) && (void 0 === f[c] ? delete f[c] : f[c] instanceof Object && t(f[c], !0));
                    else
                        for (c in f) f.hasOwnProperty(c) && void 0 === f[c] && delete f[c];
                    return f
                }

                function r(f) {
                    if (!f || "object" !== typeof f || "function" === typeof f) return f;
                    if (w.isInt8Array(f) || w.isUint8Array(f) || w.isUint8ClampedArray(f) || w.isInt16Array(f) || w.isUint16Array(f) || w.isInt32Array(f) || w.isUint32Array(f) || w.isFloat32Array(f) || w.isFloat64Array(f)) return w.slice(f);
                    if (f instanceof Date) return new Date(f.getTime());
                    if (f instanceof ArrayBuffer) return f.slice(0, f.byteLength);
                    if (f instanceof Map) {
                        const c = new Map;
                        f.forEach((g, e) => {
                            c.set(e, r(g))
                        });
                        return c
                    }
                    if (f instanceof Set) {
                        const c = new Set;
                        f.forEach(g => {
                            c.add(r(g))
                        });
                        return c
                    }
                    let b;
                    if ("function" === typeof f.clone) b = f.clone();
                    else if ("function" === typeof f.map && "function" === typeof f.forEach) b = f.map(r);
                    else if ("function" === typeof f.notifyChange && "function" === typeof f.watch) b = f.clone();
                    else {
                        b = {};
                        for (const c of Object.getOwnPropertyNames(f)) b[c] = r(f[c])
                    }
                    return b
                }
                a.clone = r;
                a.equals = function(f, b) {
                    return f === b || "number" === typeof f && isNaN(f) && "number" === typeof b && isNaN(b) || "function" === typeof(f || {}).getTime && "function" === typeof(b || {}).getTime &&
                        f.getTime() === b.getTime() || !1
                };
                a.fixJson = t;
                a.mixin = function(f = {}, ...b) {
                    k("esri-deprecation-warnings") && console.warn("[esri.core.lang] \ud83d\uded1 DEPRECATED - Function: mixin()\n\t\ud83d\udee0\ufe0f Replacement: Use Object.assign() directly\n\t\u2699\ufe0f Version: 4.19");
                    return Object.assign(f, ...b)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/typedArrayUtil": function() {
            define(["exports"], function(a) {
                a.estimateSize = function(k) {
                    return k ? 128 + k.buffer.byteLength + 64 : 0
                };
                a.forEach =
                    function(k, w) {
                        if (k.forEach) k.forEach(w);
                        else
                            for (let t = 0; t < k.length; t++) w(k[t], t, k)
                    };
                a.isArrayBuffer = function(k) {
                    return k instanceof ArrayBuffer || k && k.constructor && "ArrayBuffer" === k.constructor.name
                };
                a.isFloat32Array = function(k) {
                    return k instanceof Float32Array || k && k.constructor && "Float32Array" === k.constructor.name
                };
                a.isFloat64Array = function(k) {
                    return k instanceof Float64Array || k && k.constructor && "Float64Array" === k.constructor.name
                };
                a.isInt16Array = function(k) {
                    return k instanceof Int16Array || k && k.constructor &&
                        "Int16Array" === k.constructor.name
                };
                a.isInt32Array = function(k) {
                    return k instanceof Int32Array || k && k.constructor && "Int32Array" === k.constructor.name
                };
                a.isInt8Array = function(k) {
                    return k instanceof Int8Array || k && k.constructor && "Int8Array" === k.constructor.name
                };
                a.isUint16Array = function(k) {
                    return k instanceof Uint16Array || k && k.constructor && "Uint16Array" === k.constructor.name
                };
                a.isUint32Array = function(k) {
                    return k instanceof Uint32Array || k && k.constructor && "Uint32Array" === k.constructor.name
                };
                a.isUint8Array =
                    function(k) {
                        return k instanceof Uint8Array || k && k.constructor && "Uint8Array" === k.constructor.name
                    };
                a.isUint8ClampedArray = function(k) {
                    return k instanceof Uint8ClampedArray || k && k.constructor && "Uint8ClampedArray" === k.constructor.name
                };
                a.slice = function(k, w, t) {
                    if (k.slice) return k.slice(w, t);
                    void 0 === w ? w = 0 : (0 > w && (w += k.length), w = Math.min(k.length, Math.max(0, w)));
                    void 0 === t ? t = k.length : (0 > t && (t += k.length), t = Math.min(k.length, Math.max(0, t)));
                    t = Math.max(0, t - w);
                    const r = new k.constructor(t);
                    for (let f = 0; f < t; f++) r[f] =
                        k[w + f];
                    return r
                };
                a.toArray = function(k) {
                    const w = Array(k.length);
                    for (let t = 0; t < k.length; t++) w[t] = k[t];
                    return w
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/kernel": function() {
            define(["require", "exports", "./core/has", "./support/revision", "./core/urlUtils"], function(a, k, w, t, r) {
                w("host-webworker") || (console.debug(`Using ArcGIS API for JavaScript ${"4.19"} [Date: ${t.buildDate}, Revision: ${t.commitHash.slice(0,8)}]`), (w("edge") || w("trident")) && console.warn("Deprecated browser - see http://esriurl.com/oldbrowser"));
                k.buildDate = t.buildDate;
                k.revision = t.commitHash;
                k.addTokenParameter = function(f) {
                    const b = k.id && k.id.findCredential(f);
                    return b && b.token ? r.addQueryParameter(f, "token", b.token) : f
                };
                k.setId = function(f) {
                    k.id = f
                };
                k.version = "4.19";
                k.workerMessages = {
                    request(f, b) {
                        return (new Promise(function(c, g) {
                            a(["./request"], function(e) {
                                c(Object.freeze({
                                    __proto__: null,
                                    "default": e
                                }))
                            }, g)
                        })).then(({
                            default: c
                        }) => {
                            const g = f.options || {};
                            g.responseType = "array-buffer";
                            g.signal = null == b ? void 0 : b.signal;
                            return c(f.url, g)
                        }).then(c =>
                            ({
                                result: {
                                    data: c.data,
                                    ssl: c.ssl
                                },
                                transferList: [c.data]
                            }))
                    }
                };
                Object.defineProperty(k, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/support/revision": function() {
            define(["exports"], function(a) {
                a.buildDate = "20210422";
                a.commitHash = "33983ad14c009689ffdf09d4145a0b9e63420892";
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/urlUtils": function() {
            define("exports ./global ../config ./maybe ./Logger ./Error".split(" "), function(a, k, w, t, r, f) {
                function b(L) {
                    const R = {
                            path: null,
                            query: null
                        },
                        U = new qa(L),
                        da = L.indexOf("?");
                    null === U.query ? R.path = L : (R.path = L.substring(0, da), R.query = c(U.query));
                    U.fragment && (R.hash = U.fragment, null === U.query && (R.path = R.path.substring(0, R.path.length - (U.fragment.length + 1))));
                    return R
                }

                function c(L) {
                    var R = L.split("\x26");
                    L = {};
                    for (const da of R) {
                        if (!da) continue;
                        var U = da.indexOf("\x3d");
                        0 > U ? (R = decodeURIComponent(da), U = "") : (R = decodeURIComponent(da.slice(0, U)), U = decodeURIComponent(da.slice(U + 1)));
                        let ka = L[R];
                        "string" === typeof ka && (ka = L[R] = [ka]);
                        Array.isArray(ka) ? ka.push(U) : L[R] = U
                    }
                    return L
                }

                function g(L) {
                    return L &&
                        "object" === typeof L && "toJSON" in L && "function" === typeof L.toJSON
                }

                function e(L, R) {
                    return L ? R && "function" === typeof R ? Object.keys(L).map(U => encodeURIComponent(U) + "\x3d" + encodeURIComponent(R(U, L[U]))).join("\x26") : Object.keys(L).map(U => {
                        const da = L[U];
                        if (null == da) return "";
                        const ka = encodeURIComponent(U) + "\x3d";
                        return (U = R && R[U]) ? ka + encodeURIComponent(U(da)) : Array.isArray(da) ? da.map(M => g(M) ? ka + encodeURIComponent(JSON.stringify(M)) : ka + encodeURIComponent(M)).join("\x26") : g(da) ? ka + encodeURIComponent(JSON.stringify(da)) :
                            ka + encodeURIComponent(da)
                    }).filter(U => U).join("\x26") : ""
                }

                function d(L) {
                    const R = L.indexOf("?"); - 1 !== R ? (wa.path = L.slice(0, R), wa.query = L.slice(R + 1)) : (wa.path = L, wa.query = null);
                    return wa
                }

                function h(L) {
                    L = d(L).path;
                    L && "/" === L[L.length - 1] || (L = `${L}/`);
                    L = I(L, !0);
                    return L = L.toLowerCase()
                }

                function p(L) {
                    const R = X.proxyRules;
                    L = h(L);
                    for (let U = 0; U < R.length; U++)
                        if (0 === L.indexOf(R[U].urlPrefix)) return R[U]
                }

                function l(L) {
                    L = y(L);
                    const R = L.indexOf("/sharing");
                    return 0 < R ? L.substring(0, R) : L.replace(/\/+$/, "")
                }

                function n(L,
                    R, U = !1) {
                    L = Y(L);
                    R = Y(R);
                    return !U && L.scheme !== R.scheme || null == L.host || null == R.host ? !1 : L.host.toLowerCase() === R.host.toLowerCase() && L.port === R.port
                }

                function u(L, R = xa, U) {
                    return C(L) ? U && U.preserveProtocolRelative ? L : "http" === la.scheme && la.authority === q(L).slice(2) ? `http:${L}` : `https:${L}` : G(L) ? L : t.assumeNonNull(x("/" === L[0] ? Q(R) : R, L))
                }

                function y(L) {
                    L = L.trim();
                    L = u(L);
                    if (/^https?:\/\//i.test(L)) {
                        const R = d(L);
                        L = R.path.replace(/\/{2,}/g, "/");
                        L = L.replace("/", "//");
                        R.query && (L += `?${R.query}`)
                    }
                    L = L.replace(/^(https?:\/\/)(arcgis\.com)/i,
                        "$1www.$2");
                    return L = P(L)
                }

                function x(...L) {
                    var R = L.filter(t.isSome);
                    if (R && R.length) {
                        L = [];
                        if (B(R[0])) {
                            var U = R[0],
                                da = U.indexOf("//"); - 1 !== da && (L.push(U.slice(0, da + 1)), ea.test(R[0]) && (L[0] += "/"), R[0] = U.slice(da + 2))
                        } else "/" === R[0][0] && L.push("");
                        R = R.reduce((ka, M) => M ? ka.concat(M.split("/")) : ka, []);
                        for (U = 0; U < R.length; U++) da = R[U], ".." === da && 0 < L.length && ".." !== L[L.length - 1] ? L.pop() : (!da && U === R.length - 1 || da && ("." !== da || 0 === L.length)) && L.push(da);
                        return L.join("/")
                    }
                }

                function q(L, R = !1) {
                    if (z(L) || v(L)) return null;
                    var U = L.indexOf("://");
                    if (-1 === U && C(L)) U = 2;
                    else if (-1 !== U) U += 3;
                    else return null;
                    U = L.indexOf("/", U); - 1 !== U && (L = L.slice(0, U));
                    R && (L = I(L, !0));
                    return L
                }

                function B(L) {
                    return C(L) || G(L)
                }

                function z(L) {
                    return null != L && "blob:" === L.slice(0, 5)
                }

                function v(L) {
                    return "data:" === L.slice(0, 5)
                }

                function A(L) {
                    L = m(L);
                    if (!L || !L.isBase64) return null;
                    L = atob(L.data);
                    const R = new Uint8Array(L.length);
                    for (let U = 0; U < L.length; U++) R[U] = L.charCodeAt(U);
                    return R.buffer
                }

                function m(L) {
                    L = L.match(za);
                    if (!L) return null;
                    const [, R, U, da] =
                    L;
                    return {
                        mediaType: R,
                        isBase64: !!U,
                        data: da
                    }
                }

                function E(L) {
                    const R = A(L);
                    if (!R) return null;
                    L = m(L);
                    return new Blob([R], {
                        type: L.mediaType
                    })
                }

                function C(L) {
                    return null != L && void 0 !== L && "/" === L[0] && "/" === L[1]
                }

                function G(L) {
                    return ba.test(L)
                }

                function F(L) {
                    return V.test(L) || "http" === la.scheme && C(L)
                }

                function D(L) {
                    return C(L) ? `https:${L}` : L.replace(V, "https:")
                }

                function H() {
                    return "https" === la.scheme
                }

                function I(L, R = !1) {
                    if (C(L)) return L.slice(2);
                    L = L.replace(ba, "");
                    R && 1 < L.length && "/" === L[0] && "/" === L[1] && (L = L.slice(2));
                    return L
                }

                function Q(L) {
                    var R = L.indexOf("//");
                    R = L.indexOf("/", R + 2);
                    return -1 === R ? L : L.slice(0, R)
                }

                function P(L) {
                    const R = X.httpsDomains;
                    if (!F(L)) return L;
                    const U = L.indexOf("/", 7);
                    let da;
                    da = -1 === U ? L : L.slice(0, U);
                    da = da.toLowerCase().slice(7);
                    if (sa.test(da))
                        if (da.endsWith(":80")) da = da.slice(0, -3), L = L.replace(":80", "");
                        else return L;
                    if ("http" === la.scheme && da === la.authority && !ma.test(L)) return L;
                    if (H() && da === la.authority || R && R.some(ka => da === ka || da.endsWith(`.${ka}`)) || H() && !p(L)) L = D(L);
                    return L
                }

                function Y(L) {
                    if ("string" ===
                        typeof L) return new qa(u(L));
                    L.scheme || (L.scheme = la.scheme);
                    return L
                }
                const W = r.getLogger("esri.core.urlUtils"),
                    X = w.request,
                    ba = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i,
                    V = /^\s*http:/i,
                    ca = /^\s*https:/i,
                    ea = /^\s*file:/i,
                    sa = /:\d+$/,
                    ma = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i,
                    ra = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,
                    ta = /^((([^\[:]+):)?([^@]+)@)?(\[([^\]]+)\]|([^\[:]*))(:([0-9]+))?$/;
                let qa = function() {
                    function L(R = "") {
                        this.uri = R;
                        this.port = this.host = this.password = this.user = this.fragment =
                            this.query = this.path = this.authority = this.scheme = null;
                        R = t.assumeNonNull(this.uri.match(ra));
                        this.scheme = R[2] || (R[1] ? "" : null);
                        this.authority = R[4] || (R[3] ? "" : null);
                        this.path = R[5];
                        this.query = R[7] || (R[6] ? "" : null);
                        this.fragment = R[9] || (R[8] ? "" : null);
                        null != this.authority && (R = t.assumeNonNull(this.authority.match(ta)), this.user = R[3] || null, this.password = R[4] || null, this.host = R[6] || R[7], this.port = R[9] || null)
                    }
                    L.prototype.toString = function() {
                        return this.uri
                    };
                    return L
                }();
                const la = new qa(w.applicationUrl),
                    na = {},
                    xa =
                    (() => {
                        var L = t.assumeNonNull(la.path);
                        L = L.substring(0, L.lastIndexOf(L.split("/")[L.split("/").length - 1]));
                        return `${`${la.scheme}://${la.host}${null!=la.port?`:${la.port}`:""}`}${L}`
                    })(),
                    wa = {
                        path: "",
                        query: ""
                    },
                    za = /^data:(.*?)(;base64)?,(.*)$/,
                    Aa = /.*?\.([^\/]*)$/,
                    ya = /(^data:image\/svg|\.svg$)/i;
                a.Url = qa;
                a.addProxy = function(L) {
                    var R = p(L),
                        U = void 0;
                    if (R) {
                        var da = d(R.proxyUrl);
                        U = da.path;
                        da = da.query ? c(da.query) : null
                    }
                    U && (R = b(L), L = U + "?" + R.path, (U = e({ ...da,
                        ...R.query
                    })) && (L = `${L}?${U}`));
                    return L
                };
                a.addProxyRule =
                    function(L) {
                        L = {
                            proxyUrl: L.proxyUrl,
                            urlPrefix: h(L.urlPrefix)
                        };
                        const R = X.proxyRules,
                            U = L.urlPrefix;
                        let da = R.length;
                        for (let ka = 0; ka < R.length; ka++) {
                            const M = R[ka].urlPrefix;
                            if (0 === U.indexOf(M)) {
                                if (U.length === M.length) return -1;
                                da = ka;
                                break
                            }
                            0 === M.indexOf(U) && (da = ka + 1)
                        }
                        R.splice(da, 0, L);
                        return da
                    };
                a.addQueryParameter = function(L, R, U) {
                    L = b(L);
                    const da = L.query || {};
                    da[R] = String(U);
                    return `${L.path}?${e(da)}`
                };
                a.addQueryParameters = function(L, R) {
                    L = b(L);
                    const U = L.query || {};
                    for (const da in R) U[da] = R[da];
                    return (R = e(U)) ?
                        `${L.path}?${R}` : L.path
                };
                a.appBaseUrl = xa;
                a.appUrl = la;
                a.changeDomain = function(L, R, U) {
                    if (!(R && U && L && B(L))) return L;
                    const da = L.indexOf("//");
                    var ka = L.indexOf("/", da + 2);
                    const M = L.indexOf(":", da + 2);
                    ka = Math.min(0 > ka ? L.length : ka, 0 > M ? L.length : M);
                    if (L.slice(da + 2, ka).toLowerCase() !== R.toLowerCase()) return L;
                    R = L.slice(0, da + 2);
                    L = L.slice(ka);
                    return `${R}${U}${L}`
                };
                a.dataComponents = m;
                a.dataToArrayBuffer = A;
                a.dataToBlob = E;
                a.downloadDataAsFile = function(L, R) {
                    a: {
                        var U = document.createElement("a");
                        if ("download" in U) {
                            var da =
                                null;
                            if (k.URL && k.URL.createObjectURL) {
                                da = E(L);
                                if (!da) {
                                    U = !1;
                                    break a
                                }
                                da = k.URL.createObjectURL(da)
                            }
                            U.download = R;
                            U.href = da || L;
                            U.style.display = "none";
                            document.body.appendChild(U);
                            U.click();
                            document.body.removeChild(U);
                            da && k.URL.revokeObjectURL(da);
                            U = void 0
                        } else U = !1
                    }
                    U || window.navigator.msSaveOrOpenBlob && window.navigator.msSaveOrOpenBlob(E(L), R)
                };
                a.getFilename = function(L, R) {
                    if (!L) return "";
                    L = b(L).path.replace(/\/+$/, "");
                    L = L.substring(L.lastIndexOf("/") + 1);
                    if (null == R || !R.length) return L;
                    R = new RegExp(`\.(${R.join("|")})$`,
                        "ig");
                    return L.replace(R, "")
                };
                a.getInterceptor = function(L) {
                    const R = da => null == da || da instanceof RegExp && da.test(L) || "string" === typeof da && L.startsWith(da),
                        U = X.interceptors;
                    if (U)
                        for (const da of U)
                            if (Array.isArray(da.urls)) {
                                if (da.urls.some(R)) return da
                            } else if (R(da.urls)) return da;
                    return null
                };
                a.getOrigin = q;
                a.getPathExtension = function(L) {
                    return t.isNone(L) ? null : (L = L.match(Aa)) ? L[1] : null
                };
                a.getProxyRule = p;
                a.getProxyUrl = function(L = !1) {
                    let R, U = X.proxyUrl;
                    if ("string" === typeof L) {
                        if (R = ca.test(L) || "https" ===
                            la.scheme && C(L), L = p(L)) U = L.proxyUrl
                    } else R = !!L;
                    if (!U) throw W.warn("esri/config: esriConfig.request.proxyUrl is not set."), new f("urlutils:proxy-not-set", "esri/config: esriConfig.request.proxyUrl is not set.");
                    R && H() && (U = D(U));
                    return b(U)
                };
                a.hasProtocol = G;
                a.hasSameOrigin = n;
                a.hasSamePortal = function(L, R) {
                    L = l(L);
                    R = l(R);
                    return I(L) === I(R)
                };
                a.isAbsolute = B;
                a.isAppHTTPS = H;
                a.isBlobProtocol = z;
                a.isDataProtocol = v;
                a.isProtocolRelative = C;
                a.isSVG = function(L) {
                    return ya.test(L)
                };
                a.isTrustedServer = function(L) {
                    if ("string" ===
                        typeof L)
                        if (B(L)) L = Y(L);
                        else return !0;
                    if (n(L, la)) return !0;
                    const R = X.trustedServers || [];
                    for (let da = 0; da < R.length; da++) {
                        var U = R[da];
                        na[U] || (G(U) || C(U) ? na[U] = [new qa(u(U))] : na[U] = [new qa(`http://${U}`), new qa(`https://${U}`)]);
                        U = na[U];
                        for (let ka = 0; ka < U.length; ka++)
                            if (n(L, U[ka])) return !0
                    }
                    return !1
                };
                a.join = x;
                a.makeAbsolute = u;
                a.makeData = function(L) {
                    return L.isBase64 ? `data:${L.mediaType};base64,${L.data}` : `data:${L.mediaType},${L.data}`
                };
                a.makeRelative = function(L, R = xa, U) {
                    if (!B(L)) return L;
                    var da = y(L),
                        ka =
                        da.toLowerCase();
                    R = y(R).toLowerCase().replace(/\/+$/, "");
                    if ((U = U ? y(U).toLowerCase().replace(/\/+$/, "") : null) && 0 !== R.indexOf(U)) return L;
                    var M = ka.indexOf("//") + 2;
                    M = ka.indexOf("/", M);
                    var J = -1 === M ? ka.length : M;
                    for (M = -1; ka.slice(0, J + 1) === R.slice(0, J) + "/";) {
                        M = J + 1;
                        if (J === ka.length) break;
                        var K = ka;
                        J += 1;
                        J = K.indexOf("/", J);
                        J = -1 === J ? K.length : J
                    }
                    if (-1 === M || U && M < U.length) return L;
                    L = da.slice(M);
                    da = R.slice(M - 1).replace(/[^/]+/g, "").length;
                    if (0 < da)
                        for (ka = 0; ka < da; ka++) L = `../${L}`;
                    else L = `./${L}`;
                    return L
                };
                a.normalize =
                    y;
                a.objectToQuery = e;
                a.queryToObject = c;
                a.removeFile = function(L) {
                    let R = 0;
                    if (B(L)) {
                        var U = L.indexOf("//"); - 1 !== U && (R = U + 2)
                    }
                    U = L.lastIndexOf("/");
                    return U < R ? L : L.slice(0, U + 1)
                };
                a.removeQueryParameter = function(L, R) {
                    const {
                        path: U,
                        query: da
                    } = b(L);
                    if (!da) return L;
                    delete da[R];
                    return (L = e(da)) ? `${U}?${L}` : U
                };
                a.removeQueryParameters = function(L, R) {
                    L = b(L);
                    const U = Object.keys(L.query || {});
                    0 < U.length && R && R.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${U.join(", ")}.`);
                    return L.path
                };
                a.removeTrailingSlash = function(L) {
                    return L.replace(/\/+$/, "")
                };
                a.toHTTP = function(L) {
                    return C(L) ? `http:${L}` : L.replace(ca, "http:")
                };
                a.toHTTPS = D;
                a.trustedServersUrlCache = na;
                a.urlToObject = b;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/maybe": function() {
            define(["exports"], function(a) {
                function k(w, t, r) {
                    return null != w ? r(w) : t
                }
                a.abortMaybe = function(w) {
                    null != w && w.abort();
                    return null
                };
                a.andThen = function(w, t) {
                    return null != w ? t(w) : null
                };
                a.applySome = function(w, t) {
                    return null != w ?
                        t(w) : null
                };
                a.assumeNonNull = function(w) {
                    return w
                };
                a.destroyMaybe = function(w) {
                    null != w && w.destroy();
                    return null
                };
                a.disposeMaybe = function(w) {
                    null != w && w.dispose();
                    return null
                };
                a.filterNones = function(w) {
                    return w.filter(t => null != t)
                };
                a.forEachSome = function(w, t) {
                    for (const r of w) k(r, null, t)
                };
                a.get = function(w, ...t) {
                    let r = 0;
                    for (; r < t.length && w;) w = w[t[r++]];
                    return w
                };
                a.isNone = function(w) {
                    return null == w
                };
                a.isSome = function(w) {
                    return null != w
                };
                a.isUndefined = function(w) {
                    return void 0 === w
                };
                a.mapMany = function(w, t) {
                    const r = [];
                    for (const f of w) r.push(k(f, null, t));
                    return r
                };
                a.mapOr = k;
                a.mapSome = function(w, t) {
                    const r = [];
                    w.forEach(f => {
                        f = t(f);
                        null != f && r.push(f)
                    });
                    return r
                };
                a.mapSomeFirst = function(w, t) {
                    for (const r of w)
                        if (w = t(r), null != w) return w;
                    return null
                };
                a.none = null;
                a.nullifyNonnullableForDispose = function(w) {
                    return null
                };
                a.releaseMaybe = function(w) {
                    null != w && w.release();
                    return null
                };
                a.removeMaybe = function(w) {
                    null != w && w.remove();
                    return null
                };
                a.unwrap = function(w) {
                    return w
                };
                a.unwrapOr = function(w, t) {
                    return null != w ? w : "function" ===
                        typeof t ? t() : t
                };
                a.unwrapOrThrow = function(w, t) {
                    if (null == w) throw Error(t);
                    return w
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/Logger": function() {
            define(["../chunks/_rollupPluginBabelHelpers", "./has", "../config", "./maybe", "./string"], function(a, k, w, t, r) {
                const f = {
                    info: 0,
                    warn: 1,
                    error: 2,
                    none: 3
                };
                k = function() {
                    function b(g) {
                        this.level = null;
                        this._module = "";
                        this.writer = this._parent = null;
                        this._loggedMessages = {
                            error: new Map,
                            warn: new Map,
                            info: new Map
                        };
                        null != g.level && (this.level = g.level);
                        null !=
                            g.writer && (this.writer = g.writer);
                        this._module = g.module;
                        b._loggers[this.module] = this;
                        g = this.module.lastIndexOf("."); - 1 !== g && (this._parent = b.getLogger(this.module.slice(0, g)))
                    }
                    var c = b.prototype;
                    c.error = function(...g) {
                        this._log("error", "always", ...g)
                    };
                    c.warn = function(...g) {
                        this._log("warn", "always", ...g)
                    };
                    c.info = function(...g) {
                        this._log("info", "always", ...g)
                    };
                    c.errorOnce = function(...g) {
                        this._log("error", "once", ...g)
                    };
                    c.warnOnce = function(...g) {
                        this._log("warn", "once", ...g)
                    };
                    c.infoOnce = function(...g) {
                        this._log("info",
                            "once", ...g)
                    };
                    c.errorOncePerTick = function(...g) {
                        this._log("error", "oncePerTick", ...g)
                    };
                    c.warnOncePerTick = function(...g) {
                        this._log("warn", "oncePerTick", ...g)
                    };
                    c.infoOncePerTick = function(...g) {
                        this._log("info", "oncePerTick", ...g)
                    };
                    b.getLogger = function(g) {
                        let e = b._loggers[g];
                        e || (e = new b({
                            module: g
                        }));
                        return e
                    };
                    c._log = function(g, e, ...d) {
                        if (this._matchLevel(g)) {
                            if ("always" !== e && !b._throttlingDisabled) {
                                const h = this._argsToKey(d),
                                    p = this._loggedMessages[g].get(h);
                                if ("once" === e && null != p || "oncePerTick" === e &&
                                    p && p >= b._tickCounter) return;
                                this._loggedMessages[g].set(h, b._tickCounter);
                                b._scheduleTickCounterIncrement()
                            }
                            for (const h of w.log.interceptors)
                                if (h(g, this.module, ...d)) return;
                            this._inheritedWriter()(g, this.module, ...d)
                        }
                    };
                    c._parentWithMember = function(g, e) {
                        let d = this;
                        for (; t.isSome(d);) {
                            const h = d[g];
                            if (t.isSome(h)) return h;
                            d = d.parent
                        }
                        return e
                    };
                    c._inheritedWriter = function() {
                        return this._parentWithMember("writer", this._consoleWriter)
                    };
                    c._consoleWriter = function(g, e, ...d) {
                        console[g](`[${e}]`, ...d)
                    };
                    c._matchLevel =
                        function(g) {
                            return f[this._parentWithMember("level", w.log.level ? w.log.level : "warn")] <= f[g]
                        };
                    c._argsToKey = function(...g) {
                        return r.numericHash(JSON.stringify(g, (e, d) => "object" !== typeof d || Array.isArray(d) ? d : "[Object]"))
                    };
                    b._scheduleTickCounterIncrement = function() {
                        b._tickCounterScheduled || (b._tickCounterScheduled = !0, Promise.resolve().then(() => {
                            b._tickCounter++;
                            b._tickCounterScheduled = !1
                        }))
                    };
                    a._createClass(b, [{
                            key: "module",
                            get: function() {
                                return this._module
                            }
                        }, {
                            key: "parent",
                            get: function() {
                                return this._parent
                            }
                        },
                        {
                            key: "test",
                            get: function() {
                                const g = this;
                                return {
                                    loggedMessages: g._loggedMessages,
                                    clearLoggedWarnings() {
                                        return g._loggedMessages.warn.clear()
                                    }
                                }
                            }
                        }
                    ], [{
                        key: "testSingleton",
                        get: function() {
                            return {
                                resetLoggers(g = {}) {
                                    const e = b._loggers;
                                    b._loggers = g;
                                    return e
                                },
                                set throttlingDisabled(g) {
                                    b._throttlingDisabled = g
                                }
                            }
                        }
                    }]);
                    return b
                }();
                k._loggers = {};
                k._tickCounter = 0;
                k._tickCounterScheduled = !1;
                k._throttlingDisabled = !1;
                return k
            })
        },
        "esri/chunks/_rollupPluginBabelHelpers": function() {
            define(["exports"], function(a) {
                function k(c,
                    g) {
                    for (var e = 0; e < g.length; e++) {
                        var d = g[e];
                        d.enumerable = d.enumerable || !1;
                        d.configurable = !0;
                        "value" in d && (d.writable = !0);
                        Object.defineProperty(c, d.key, d)
                    }
                }

                function w(c) {
                    w = Object.setPrototypeOf ? Object.getPrototypeOf : function(g) {
                        return g.__proto__ || Object.getPrototypeOf(g)
                    };
                    return w(c)
                }

                function t(c, g) {
                    t = Object.setPrototypeOf || function(e, d) {
                        e.__proto__ = d;
                        return e
                    };
                    return t(c, g)
                }

                function r() {
                    if ("undefined" === typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
                    if ("function" === typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
                    } catch (c) {
                        return !1
                    }
                }

                function f(c, g, e) {
                    f = r() ? Reflect.construct : function(d, h, p) {
                        var l = [null];
                        l.push.apply(l, h);
                        d = new(Function.bind.apply(d, l));
                        p && t(d, p.prototype);
                        return d
                    };
                    return f.apply(null, arguments)
                }

                function b(c) {
                    var g = "function" === typeof Map ? new Map : void 0;
                    b = function(e) {
                        function d() {
                            return f(e, arguments, w(this).constructor)
                        }
                        if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e;
                        if ("function" !==
                            typeof e) throw new TypeError("Super expression must either be null or a function");
                        if ("undefined" !== typeof g) {
                            if (g.has(e)) return g.get(e);
                            g.set(e, d)
                        }
                        d.prototype = Object.create(e.prototype, {
                            constructor: {
                                value: d,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        });
                        return t(d, e)
                    };
                    return b(c)
                }
                a._assertThisInitialized = function(c) {
                    if (void 0 === c) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return c
                };
                a._createClass = function(c, g, e) {
                    g && k(c.prototype, g);
                    e && k(c, e);
                    return c
                };
                a._inheritsLoose =
                    function(c, g) {
                        c.prototype = Object.create(g.prototype);
                        c.prototype.constructor = c;
                        t(c, g)
                    };
                a._wrapNativeSuper = b
            })
        },
        "esri/core/string": function() {
            define(["exports", "./object"], function(a, k) {
                function w(r) {
                    return null == r ? "" : r
                }
                const t = /\{([^\}]+)\}/g;
                a.escapeRegExpString = function(r, f) {
                    return r.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, b => f && -1 !== f.indexOf(b) ? b : `\\${b}`)
                };
                a.numericHash = function(r) {
                    let f = 0;
                    for (let b = 0; b < r.length; b++) f = (f << 5) - f + r.charCodeAt(b), f |= 0;
                    return f
                };
                a.replace = function(r, f) {
                    return r.replace(t,
                        "object" === typeof f ? (b, c) => w(k.getDeepValue(c, f)) : (b, c) => w(f(c)))
                };
                a.stripHTML = function(r) {
                    return (new DOMParser).parseFromString(r || "", "text/html").body.innerText || ""
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/Error": function() {
            define(["../chunks/_rollupPluginBabelHelpers", "./lang", "./Logger", "./Message"], function(a, k, w, t) {
                t = function(r) {
                    function f(b, c, g) {
                        var e = r.call(this, b, c, g) || this;
                        return a._assertThisInitialized(e) instanceof f ? e : new f(b, c, g)
                    }
                    a._inheritsLoose(f, r);
                    f.prototype.toJSON =
                        function() {
                            if (null != this.details) try {
                                return {
                                    name: this.name,
                                    message: this.message,
                                    details: JSON.parse(JSON.stringify(this.details, (b, c) => {
                                        if (c && "object" === typeof c && "function" === typeof c.toJSON) return c;
                                        try {
                                            return k.clone(c)
                                        } catch (g) {
                                            return "[object]"
                                        }
                                    }))
                                }
                            } catch (b) {
                                throw w.getLogger("esri.core.Error").error(b), b;
                            }
                            return {
                                name: this.name,
                                message: this.message,
                                details: this.details
                            }
                        };
                    f.fromJSON = function(b) {
                        return new f(b.name, b.message, b.details)
                    };
                    return f
                }(t);
                t.prototype.type = "error";
                return t
            })
        },
        "esri/core/Message": function() {
            define(["./object"],
                function(a) {
                    function k(w, t) {
                        return w.replace(/\$\{([^\s:\}]*)(?::([^\s:\}]+))?\}/g, function(r, f) {
                            if ("" === f) return "$";
                            r = a.getDeepValue(f, t);
                            r = null == r ? "" : r;
                            if ("undefined" === typeof r) throw Error(`could not find key "${f}" in template`);
                            return r.toString()
                        })
                    }
                    return function() {
                        function w(t, r, f) {
                            this.name = t;
                            this.details = f;
                            this.message = void 0;
                            this instanceof w && (this.message = r && k(r, f) || "")
                        }
                        w.prototype.toString = function() {
                            return "[" + this.name + "]: " + this.message
                        };
                        return w
                    }()
                })
        },
        "esri/core/workers/RemoteClient": function() {
            define("../../support/revision ../maybe ../Error ../events ../promiseUtils ../../kernel ../../views/support/Scheduler ./registry ./utils".split(" "),
                function(a, k, w, t, r, f, b, c, g) {
                    const {
                        CLOSE: e,
                        ABORT: d,
                        INVOKE: h,
                        RESPONSE: p,
                        OPEN_PORT: l,
                        ON: n
                    } = g.MessageType;
                    let u = function() {
                            function x(B) {
                                this._timer = null;
                                this._cancelledJobIds = new Set;
                                this._invokeMessages = [];
                                this._invoke = B;
                                this._timer = null;
                                this._process = this._process.bind(this)
                            }
                            var q = x.prototype;
                            q.push = function(B) {
                                B.type === g.MessageType.ABORT ? this._cancelledJobIds.add(B.jobId) : (this._invokeMessages.push(B), null === this._timer && (this._timer = setTimeout(this._process, 0)))
                            };
                            q.clear = function() {
                                this._invokeMessages.length =
                                    0;
                                this._cancelledJobIds.clear();
                                this._timer = null
                            };
                            q._process = function() {
                                this._timer = null;
                                for (const B of this._invokeMessages) this._cancelledJobIds.has(B.jobId) || this._invoke(B);
                                this._cancelledJobIds.clear();
                                this._invokeMessages.length = 0
                            };
                            return x
                        }(),
                        y = function() {
                            function x(B, z) {
                                this._port = B;
                                this._outJobs = new Map;
                                this._inJobs = new Map;
                                this._invokeQueue = new u(v => this._onInvokeMessage(v));
                                this._messageQueue = [];
                                this._client = z.client;
                                this._onMessage = this._onMessage.bind(this);
                                this._channel = z.channel;
                                k.isSome(z.scheduler) &&
                                    (this._frameTask = z.scheduler.registerTask(b.Task.REMOTE_CLIENT, v => this._update(v), () => 0 < this._messageQueue.length));
                                this._port.addEventListener("message", this._onMessage);
                                this._port.start()
                            }
                            x.connect = function(B) {
                                const z = new MessageChannel;
                                B = "function" === typeof B ? new B : "default" in B && "function" === typeof B.default ? new B.default : B;
                                const v = new x(z.port1, {
                                    channel: z,
                                    client: B
                                });
                                "object" === typeof B && "remoteClient" in B && (B.remoteClient = v);
                                x.clients.set(v, B);
                                return z.port2
                            };
                            x.loadWorker = function(B) {
                                return (B =
                                    c.registry[B]) ? B() : Promise.resolve(null)
                            };
                            var q = x.prototype;
                            q.close = function() {
                                this._post({
                                    type: e
                                });
                                this._close()
                            };
                            q.isBusy = function() {
                                return 0 < this._outJobs.size
                            };
                            q.invoke = function(B, z, v) {
                                const A = v && v.signal,
                                    m = v && v.transferList;
                                if (!this._port) return Promise.reject(new w("worker:port-closed", `Cannot call invoke('${B}'), port is closed`, {
                                    methodName: B,
                                    data: z
                                }));
                                const E = g.newJobId();
                                return new Promise((C, G) => {
                                    const F = r.onAbortOrThrow(A, () => {
                                        var D;
                                        const H = this._outJobs.get(E);
                                        H && (this._outJobs.delete(E),
                                            null == (D = H.abortHandle) ? void 0 : D.remove(), this._post({
                                                type: d,
                                                jobId: E
                                            }), G(r.createAbortError()))
                                    });
                                    this._outJobs.set(E, {
                                        resolve: C,
                                        reject: G,
                                        abortHandle: F,
                                        debugInfo: B
                                    });
                                    this._post({
                                        type: h,
                                        jobId: E,
                                        methodName: B,
                                        abortable: null != A
                                    }, z, m)
                                })
                            };
                            q.on = function(B, z) {
                                function v(m) {
                                    z(m.data)
                                }
                                const A = new MessageChannel;
                                this._port.postMessage({
                                    type: g.MessageType.ON,
                                    eventType: B,
                                    port: A.port2
                                }, [A.port2]);
                                A.port1.addEventListener("message", v);
                                A.port1.start();
                                return {
                                    remove() {
                                        A.port1.postMessage({
                                            type: g.MessageType.CLOSE
                                        });
                                        A.port1.close();
                                        A.port1.removeEventListener("message", v)
                                    }
                                }
                            };
                            q.openPort = function() {
                                const B = new MessageChannel;
                                this._post({
                                    type: l,
                                    port: B.port2
                                });
                                return B.port1
                            };
                            q._close = function() {
                                this._channel && (this._channel = null);
                                this._port.removeEventListener("message", this._onMessage);
                                this._port.close();
                                this._outJobs.forEach(B => {
                                    var z;
                                    null == (z = B.abortHandle) ? void 0 : z.remove();
                                    B.reject(r.createAbortError(`Worker closing, aborting job calling '${B.debugInfo}'`))
                                });
                                this._inJobs.clear();
                                this._outJobs.clear();
                                this._invokeQueue.clear();
                                this._port = this._client = null;
                                this._frameTask = k.removeMaybe(this._frameTask)
                            };
                            q._onMessage = function(B) {
                                k.isSome(this._frameTask) ? this._messageQueue.push(B) : this._processMessage(B)
                            };
                            q._processMessage = function(B) {
                                if (B = g.receiveMessage(B)) switch (B.type) {
                                    case p:
                                        this._onResponseMessage(B);
                                        break;
                                    case h:
                                        this._invokeQueue.push(B);
                                        break;
                                    case d:
                                        this._onAbortMessage(B);
                                        break;
                                    case e:
                                        this._onCloseMessage();
                                        break;
                                    case l:
                                        this._onOpenPortMessage(B);
                                        break;
                                    case n:
                                        this._onOnMessage(B)
                                }
                            };
                            q._onAbortMessage = function(B) {
                                const z =
                                    this._inJobs,
                                    v = B.jobId,
                                    A = z.get(v);
                                this._invokeQueue.push(B);
                                A && (A.controller && A.controller.abort(), z.delete(v))
                            };
                            q._onCloseMessage = function() {
                                const B = this._client;
                                this._close();
                                B && "destroy" in B && x.clients.get(this) === B && B.destroy();
                                x.clients.delete(this);
                                B && B.remoteClient && (B.remoteClient = null)
                            };
                            q._onInvokeMessage = function(B) {
                                const {
                                    methodName: z,
                                    jobId: v,
                                    data: A,
                                    abortable: m
                                } = B;
                                B = m ? r.createAbortController() : null;
                                const E = this._inJobs;
                                let C = this._client,
                                    G = C[z],
                                    F;
                                try {
                                    if (!G && z && -1 !== z.indexOf(".")) {
                                        const D =
                                            z.split(".");
                                        for (let H = 0; H < D.length - 1; H++) C = C[D[H]], G = C[D[H + 1]]
                                    }
                                    if ("function" !== typeof G) throw new TypeError(`${z} is not a function`);
                                    F = G.call(C, A, {
                                        client: this,
                                        signal: B ? B.signal : null
                                    })
                                } catch (D) {
                                    this._post({
                                        type: p,
                                        jobId: v,
                                        error: g.toInvokeError(D)
                                    });
                                    return
                                }
                                r.isPromiseLike(F) ? (E.set(v, {
                                        controller: B,
                                        promise: F
                                    }), F.then(D => {
                                        E.has(v) && (E.delete(v), this._post({
                                            type: p,
                                            jobId: v
                                        }, D))
                                    }, D => {
                                        E.has(v) && (E.delete(v), r.isAbortError(D) || this._post({
                                            type: p,
                                            jobId: v,
                                            error: g.toInvokeError(D || {
                                                message: `Error encountered at method ${z}`
                                            })
                                        }))
                                    })) :
                                    this._post({
                                        type: p,
                                        jobId: v
                                    }, F)
                            };
                            q._onOpenPortMessage = function(B) {
                                new x(B.port, {
                                    client: this._client
                                })
                            };
                            q._onOnMessage = function(B) {
                                const {
                                    port: z
                                } = B, v = this._client.on(B.eventType, m => {
                                    z.postMessage(m)
                                }), A = t.on(B.port, "message", m => {
                                    g.receiveMessage(m).type === g.MessageType.CLOSE && (A.remove(), v.remove(), z.close())
                                })
                            };
                            q._onResponseMessage = function(B) {
                                var z;
                                const {
                                    jobId: v,
                                    error: A,
                                    data: m
                                } = B;
                                B = this._outJobs;
                                if (B.has(v)) {
                                    var E = B.get(v);
                                    B.delete(v);
                                    null == (z = E.abortHandle) ? void 0 : z.remove();
                                    A ? E.reject(w.fromJSON(JSON.parse(A))) :
                                        E.resolve(m)
                                }
                            };
                            q._update = function(B) {
                                for (; !B.done && 0 < this._messageQueue.length;) this._processMessage(this._messageQueue.shift()), B.madeProgress()
                            };
                            q._post = function(B, z, v) {
                                return g.postMessage(this._port, B, z, v)
                            };
                            return x
                        }();
                    y.kernelInfo = {
                        revision: a.commitHash,
                        version: f.version,
                        buildDate: a.buildDate
                    };
                    y.clients = new Map;
                    return y
                })
        },
        "esri/core/events": function() {
            define(["exports"], function(a) {
                function k(r) {
                    return r && ("function" === typeof r.on || "function" === typeof r.addEventListener)
                }

                function w(r, f, b) {
                    if (!k(r)) throw new TypeError("target is not a Evented or EventTarget object");
                    if ("on" in r) return r.on(f, b);
                    if (Array.isArray(f)) {
                        const c = f.slice();
                        for (const g of c) r.addEventListener(g, b);
                        return {
                            remove() {
                                for (const g of c) r.removeEventListener(g, b)
                            }
                        }
                    }
                    r.addEventListener(f, b);
                    return {
                        remove() {
                            r.removeEventListener(f, b)
                        }
                    }
                }
                const t = {
                    Win: "Meta",
                    Scroll: "ScrollLock",
                    Spacebar: " ",
                    Down: "ArrowDown",
                    Left: "ArrowLeft",
                    Right: "ArrowRight",
                    Up: "ArrowUp",
                    Del: "Delete",
                    Apps: "ContextMenu",
                    Esc: "Escape",
                    Multiply: "*",
                    Add: "+",
                    Subtract: "-",
                    Decimal: ".",
                    Divide: "/"
                };
                a.eventKey = function({
                    key: r
                }) {
                    return t[r] ||
                        r
                };
                a.ieKeyNormalizationMap = t;
                a.isEventTarget = k;
                a.on = w;
                a.once = function(r, f, b) {
                    if (!k(r)) throw new TypeError("target is not a Evented or EventTarget object");
                    if ("once" in r) return r.once(f, b);
                    const c = w(r, f, g => {
                        c.remove();
                        b.call(r, g)
                    });
                    return {
                        remove() {
                            c.remove()
                        }
                    }
                };
                a.pausable = function(r, f, b) {
                    let c = !1;
                    const g = w(r, f, e => {
                        c || b.call(r, e)
                    });
                    return {
                        resume() {
                            c = !1
                        },
                        pause() {
                            c = !0
                        },
                        remove() {
                            g.remove()
                        }
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/promiseUtils": function() {
            define("exports ./maybe ./Logger ./Error ./clock ./events".split(" "),
                function(a, k, w, t, r, f) {
                    function b(x = "Aborted") {
                        return new t("AbortError", x)
                    }

                    function c() {
                        return new AbortController
                    }

                    function g(x) {
                        if (d(x)) throw b();
                    }

                    function e(x) {
                        return k.isSome(x) ? "aborted" in x ? x : x.signal : x
                    }

                    function d(x) {
                        x = e(x);
                        return k.isSome(x) && x.aborted
                    }

                    function h(x, q) {
                        x = e(x);
                        if (!k.isNone(x))
                            if (x.aborted) q();
                            else return f.once(x, "abort", () => q())
                    }

                    function p(x) {
                        return x && "AbortError" === x.name
                    }

                    function l() {
                        let x = null;
                        const q = new Promise((B, z) => {
                            x = {
                                promise: void 0,
                                resolve: B,
                                reject: z
                            }
                        });
                        x.promise =
                            q;
                        return x
                    }

                    function n(x) {
                        if (x) {
                            if ("function" !== typeof x.forEach) {
                                const q = Object.keys(x),
                                    B = q.map(z => x[z]);
                                return n(B).then(z => {
                                    const v = {};
                                    q.forEach((A, m) => v[A] = z[m]);
                                    return v
                                })
                            }
                            return Promise.allSettled(x).then(q => Array.from(x, (B, z) => {
                                z = q[z];
                                return "fulfilled" === z.status ? {
                                    promise: B,
                                    value: z.value
                                } : {
                                    promise: B,
                                    error: z.reason
                                }
                            }))
                        }
                    }

                    function u(x, q, B) {
                        const z = c();
                        h(B, () => z.abort());
                        return new Promise((v, A) => {
                            let m = setTimeout(() => {
                                m = 0;
                                v(q)
                            }, x);
                            h(z, () => {
                                m && (clearTimeout(m), A(b()))
                            })
                        })
                    }

                    function y(x) {
                        return x &&
                            "object" === typeof x && "then" in x && "function" === typeof x.then ? x : Promise.resolve(x)
                    }
                    a.after = u;
                    a.all = function(x) {
                        return Promise.all(x)
                    };
                    a.always = function(x, q) {
                        return x.then(q, q)
                    };
                    a.create = function(x) {
                        return new Promise((q, B) => {
                            try {
                                x(q, B)
                            } catch (z) {
                                Promise.resolve().then(() => B(z))
                            }
                        })
                    };
                    a.createAbortController = c;
                    a.createAbortError = b;
                    a.createDeferred = l;
                    a.createResolver = function() {
                        let x, q;
                        const B = new Promise((v, A) => {
                                x = v;
                                q = A
                            }),
                            z = v => {
                                x(v)
                            };
                        z.resolve = v => x(v);
                        z.reject = v => q(v);
                        z.timeout = (v, A) => r["default"].setTimeout(() =>
                            z.reject(A), v);
                        z.promise = B;
                        return z
                    };
                    a.createTask = function(x) {
                        let q = c();
                        x = x(q.signal);
                        let B = {
                            promise: x,
                            finished: !1,
                            abort: () => {
                                q && (q.abort(), q = null)
                            }
                        };
                        const z = () => {
                            B && (B.finished = !0, B = null);
                            q = null
                        };
                        x.then(z, z);
                        return B
                    };
                    a.debounce = function(x, q = -1) {
                        let B, z, v, A, m = null;
                        const E = (...C) => {
                            if (B) {
                                z = C;
                                A && A.reject(b());
                                A = l();
                                C = k.assumeNonNull(A.promise);
                                if (m) {
                                    var G = m;
                                    m = null;
                                    G.abort()
                                }
                                return C
                            }
                            v = A || l();
                            A = null;
                            if (0 < q) {
                                const D = c(),
                                    H = B = y(x(...C, D.signal));
                                u(q).then(() => {
                                    B === H && (A ? D.abort() : m = D)
                                })
                            } else B = 1, B = y(x(...C));
                            C = () => {
                                const D = z;
                                z = v = B = m = null;
                                null != D && E(...D)
                            };
                            G = B;
                            const F = v;
                            G.then(C, C);
                            G.then(F.resolve, F.reject);
                            return k.assumeNonNull(F.promise)
                        };
                        return E
                    };
                    a.eachAlways = n;
                    a.eachAlwaysValues = function(x) {
                        return n(x).then(q => q.filter(B => !!B.value).map(B => B.value))
                    };
                    a.filter = function(x, q) {
                        const B = x.slice();
                        return Promise.all(x.map((z, v) => q(z, v))).then(z => B.filter((v, A) => z[A]))
                    };
                    a.ignoreAbortErrors = function(x) {
                        return x.catch(q => {
                            if (!p(q)) throw q;
                        })
                    };
                    a.isAbortError = p;
                    a.isAborted = d;
                    a.isPromiseLike = function(x) {
                        return x &&
                            "function" === typeof x.then
                    };
                    a.logOnError = function(x, q = w.getLogger("esri")) {
                        return x.catch(B => {
                            p(B) || q.error(B)
                        })
                    };
                    a.onAbort = h;
                    a.onAbortOrThrow = function(x, q) {
                        x = e(x);
                        if (!k.isNone(x)) return g(x), f.once(x, "abort", () => q(b()))
                    };
                    a.reject = function(x) {
                        return Promise.reject(x)
                    };
                    a.resolve = function(x) {
                        return Promise.resolve(x)
                    };
                    a.throwIfAbortError = function(x) {
                        if (p(x)) throw x;
                    };
                    a.throwIfAborted = g;
                    a.throwIfNotAbortError = function(x) {
                        if (!p(x)) throw x;
                    };
                    a.timeout = function(x, q, B, z) {
                        const v = B && "abort" in B ? B : null;
                        null !=
                            z || v || (z = B);
                        let A = setTimeout(() => {
                            A = 0;
                            v && v.abort()
                        }, q);
                        const m = () => {
                            throw z || new t("promiseUtils:timeout", "The wrapped promise did not resolve within " + q + " ms");
                        };
                        return x.then(E => {
                            if (0 === A) throw m();
                            clearTimeout(A);
                            return E
                        }, E => {
                            clearTimeout(A);
                            throw 0 === A ? m() : E;
                        })
                    };
                    a.when = y;
                    a.whenOrAbort = function(x, q) {
                        const B = e(q);
                        return k.isNone(B) ? x : new Promise((z, v) => {
                            let A = h(q, () => v(b()));
                            const m = () => A = k.removeMaybe(A);
                            x.then(m, m);
                            x.then(z, v)
                        })
                    };
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/core/clock": function() {
            define(["exports",
                "./global"
            ], function(a, k) {
                function w(t) {
                    return {
                        setTimeout: (r, f) => {
                            const b = t.setTimeout(r, f);
                            return {
                                remove: () => t.clearTimeout(b)
                            }
                        }
                    }
                }
                k = w(k);
                a.default = k;
                a.wrap = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/support/Scheduler": function() {
            define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/has ../../core/maybe ../../core/Logger ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/property ../../core/jsonMap ../../core/accessorSupport/decorators/subclass ../../core/urlUtils ../../core/uuid ../../portal/support/resourceExtension ../../core/PerformanceSampler ../../core/PooledArray ../../core/promiseUtils ../../core/Accessor ../../core/watchUtils ../../layers/support/PromiseQueue ./debugFlags".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l, n, u, y, x, q, B) {
                    function z(I) {
                        return I in A ? A[I] : "number" === typeof I ? I : 1
                    }
                    const v = f.getLogger("esri.views.support.Scheduler");
                    (function(I) {
                        I.REMOTE_CLIENT = "worker messages";
                        I.SLIDE = "slide";
                        I.STAGE = "stage";
                        I.STREAM_DATA_LOADER = "stream loader";
                        I.ELEVATION_QUERY = "elevation query";
                        I.TERRAIN_SURFACE = "terrain";
                        I.SURFACE_GEOMETRY_UPDATES = "surface geometry updates";
                        I.GRAPHICS_CORE = "Graphics3D";
                        I.I3S_CONTROLLER = "I3S";
                        I.POINT_CLOUD_LAYER = "point cloud";
                        I.FEATURE_TILE_FETCHER =
                            "feature fetcher";
                        I.LABELER = "labeler";
                        I.GRAPHICS_DECONFLICTOR = "graphics deconflictor";
                        I.FILTER_VISIBILITY = "Graphics3D filter visibility";
                        I.FEATURE_QUERY_ENGINE = "feature query";
                        I.SCALE_VISIBILITY = "Graphics3D scale visibility";
                        I.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility";
                        I.POINT_OF_INTEREST_FREQUENT = "POI frequent";
                        I.POINT_OF_INTEREST_INFREQUENT = "POI infrequent";
                        I.FEATURE_TILE_TREE = "feature tile tree";
                        I.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree";
                        I.ELEVATION_ALIGNMENT = "elevation alignment";
                        I.TEXT_TEXTURE_ATLAS = "text texture atlas";
                        I.TEXTURE_UNLOAD = "texture unload";
                        I.OVERLAY_MANAGER = "overlay manager";
                        I.LINE_OF_SIGHT_TOOL = "line of sight tool";
                        I.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool";
                        I.ELEVATION_PROFILE = "elevation profile";
                        I.SNAPPING = "snapping";
                        I[I.TEST_PRIO = 1] = "TEST_PRIO"
                    })(a.Task || (a.Task = {}));
                    const A = {
                            [a.Task.REMOTE_CLIENT]: 0,
                            [a.Task.SLIDE]: 0,
                            [a.Task.STREAM_DATA_LOADER]: 0,
                            [a.Task.ELEVATION_QUERY]: 0,
                            [a.Task.STAGE]: 1,
                            [a.Task.TERRAIN_SURFACE]: 1,
                            [a.Task.SURFACE_GEOMETRY_UPDATES]: 1,
                            [a.Task.GRAPHICS_CORE]: 2,
                            [a.Task.I3S_CONTROLLER]: 2,
                            [a.Task.POINT_CLOUD_LAYER]: 2,
                            [a.Task.FEATURE_TILE_FETCHER]: 2,
                            [a.Task.LABELER]: 8,
                            [a.Task.GRAPHICS_DECONFLICTOR]: 4,
                            [a.Task.FILTER_VISIBILITY]: 4,
                            [a.Task.FEATURE_QUERY_ENGINE]: 8,
                            [a.Task.SCALE_VISIBILITY]: 4,
                            [a.Task.FRUSTUM_VISIBILITY]: 4,
                            [a.Task.POINT_OF_INTEREST_FREQUENT]: 6,
                            [a.Task.POINT_OF_INTEREST_INFREQUENT]: 30,
                            [a.Task.FEATURE_TILE_TREE]: 16,
                            [a.Task.FEATURE_TILE_TREE_ACTIVE]: 0,
                            [a.Task.ELEVATION_ALIGNMENT]: 12,
                            [a.Task.TEXT_TEXTURE_ATLAS]: 12,
                            [a.Task.TEXTURE_UNLOAD]: 12,
                            [a.Task.OVERLAY_MANAGER]: 12,
                            [a.Task.LINE_OF_SIGHT_TOOL]: 16,
                            [a.Task.LINE_OF_SIGHT_TOOL_INTERACTIVE]: 0,
                            [a.Task.SNAPPING]: 0
                        },
                        m = 1E3 / 30;
                    var E;
                    (function(I) {
                        let Q = function(W) {
                            function X(V) {
                                var ca = W.call(this, V) || this;
                                ca.updating = !0;
                                ca.performanceInfo = {
                                    total: new l("total"),
                                    tasks: []
                                };
                                ca._budget = null;
                                ca._state = 1;
                                ca._tasks = new n;
                                ca._runQueue = new n;
                                ca._load = 0;
                                ca._idleStateCallbacks = new n;
                                ca._idleUpdatesStartFired = !1;
                                ca._maxReschedule = F;
                                ca._forceTask = !1;
                                ca._debug = !1;
                                ca._debugHandle = x.init(B, "SCHEDULER_LOG_SLOW_TASKS",
                                    ma => ca._debug = ma);
                                ca._budget = new Y(V.nowFunc);
                                H.length = 0;
                                for (const ma in a.Task) D.set(a.Task[ma], ca.performanceInfo.tasks.length), ca.performanceInfo.tasks.push(new l(a.Task[ma])), H.push(0);
                                let ea;
                                const sa = k._assertThisInitialized(ca);
                                ca._test = {
                                    get state() {
                                        return r.isNone(ea) ? sa._state : ea
                                    },
                                    set state(ma) {
                                        ea = ma
                                    },
                                    FRAME_SAFETY_BUDGET: 6.5,
                                    INTERACTING_BUDGET: m,
                                    IDLE_BUDGET: 100,
                                    get budget() {
                                        return sa._budget.budget
                                    },
                                    usedBudget: 0,
                                    updateTask: ma => ca._updateTask(ma),
                                    getState: ma => ca._getState(ma),
                                    getRuntime: ma =>
                                        ca._getRuntime(ma),
                                    resetRuntimes: () => ca._resetRuntimes(),
                                    getRunning: () => ca._getRunning()
                                };
                                return ca
                            }
                            k._inheritsLoose(X, W);
                            var ba = X.prototype;
                            ba.destroy = function() {
                                this._debugHandle && this._debugHandle.remove()
                            };
                            ba.registerTask = function(V, ca, ea) {
                                const sa = z(V);
                                V = new P(this, V, ca, ea, sa);
                                this._tasks.push(V);
                                return V
                            };
                            ba.registerIdleStateCallbacks = function(V, ca) {
                                const ea = {
                                    idleBegin: V,
                                    idleEnd: ca
                                };
                                this._idleStateCallbacks.push(ea);
                                2 === this.state && this._idleUpdatesStartFired && ea.idleBegin();
                                const sa = this;
                                return {
                                    remove: () =>
                                        this._removeIdleStateCallbacks(ea),
                                    set idleBegin(ma) {
                                        sa._idleUpdatesStartFired && (ea.idleEnd(), 2 === sa._state && ma());
                                        ea.idleBegin = ma
                                    },
                                    set idleEnd(ma) {
                                        ea.idleEnd = ma
                                    }
                                }
                            };
                            ba.updateBudget = function(V) {
                                this._test.usedBudget = 0;
                                let ca = 6.5,
                                    ea = V.frameDuration,
                                    sa = 1;
                                switch (this.state) {
                                    case 2:
                                        ca = 0;
                                        ea = Math.max(100, V.frameDuration);
                                        sa = 30;
                                        break;
                                    case 1:
                                        ea = Math.max(m, V.frameDuration)
                                }
                                ea -= V.elapsedFrameTime + ca;
                                if (2 !== this.state && 1 > ea && !this._forceTask) return this._forceTask = !0, !1;
                                ea = Math.max(ea, sa);
                                this._budget.reset(ea,
                                    this.state);
                                this._maxReschedule = F;
                                this._updateLoad();
                                return this._schedule()
                            };
                            ba.frame = function() {
                                this._forceTask = !1;
                                switch (this.state) {
                                    case 2:
                                        this._idleUpdatesStartFired || (this._idleUpdatesStartFired = !0, this._idleStateCallbacks.forAll(V => V.idleBegin()));
                                        this._runIdle();
                                        break;
                                    case 1:
                                        this._runInteracting();
                                        break;
                                    default:
                                        this._runAnimating()
                                }
                                this._test.usedBudget = this._budget.elapsed
                            };
                            ba._removeIdleStateCallbacks = function(V) {
                                this._idleUpdatesStartFired && V.idleEnd();
                                this._idleStateCallbacks.removeUnordered(V)
                            };
                            ba.removeTask = function(V) {
                                this._tasks.removeUnordered(V);
                                this._runQueue.removeUnordered(V)
                            };
                            ba._updateTask = function(V) {
                                this._tasks.forAll(ca => {
                                    ca.name === V && ca.setPriority(V)
                                })
                            };
                            ba._getState = function(V) {
                                if (this._runQueue.some(ea => ea.name === V)) return a.TaskState.SCHEDULED;
                                let ca = a.TaskState.IDLE;
                                this._tasks.forAll(ea => {
                                    ea.name === V && ea.needsUpdate && (1 >= ea.schedulePriority ? ca = a.TaskState.READY : ca !== a.TaskState.READY && (ca = a.TaskState.WAITING))
                                });
                                return ca
                            };
                            ba._getRuntime = function(V) {
                                let ca = 0;
                                this._tasks.forAll(ea => {
                                    ea.name === V && (ca += ea.runtime)
                                });
                                return ca
                            };
                            ba._resetRuntimes = function() {
                                this._tasks.forAll(V => V.runtime = 0)
                            };
                            ba._getRunning = function() {
                                const V = new Map;
                                this._tasks.forAll(ea => {
                                    ea.needsUpdate && V.set(ea.name, (V.get(ea.name) || 0) + 1)
                                });
                                if (0 === V.size) return null;
                                let ca = "";
                                V.forEach((ea, sa) => {
                                    ca = 1 < ea ? ca + ` ${ea}x ${sa}` : ca + ` ${sa}`
                                });
                                return ca
                            };
                            ba._runIdle = function() {
                                this._run()
                            };
                            ba._runInteracting = function() {
                                this._run()
                            };
                            ba._runAnimating = function() {
                                this._run()
                            };
                            ba._updateLoad = function() {
                                const V = this._tasks.reduce((ca,
                                    ea) => ea.needsUpdate ? ++ca : ca, 0);
                                this._load = .9 * this._load + V * (1 - .9)
                            };
                            ba._schedule = function() {
                                if (0 >= this._maxReschedule) return !1;
                                this._runQueue.filterInPlace(V => {
                                    if (V.needsUpdate) return !0;
                                    V.schedulePriority = V.priority;
                                    return !1
                                });
                                for (this._tasks.forAll(V => {
                                        0 === V.priority && V.needsUpdate && !this._runQueue.some(ca => ca === V) && this._runQueue.unshift(V)
                                    }); 0 === this._runQueue.length;) {
                                    let V = !1,
                                        ca = 0;
                                    this._tasks.forAll(ea => {
                                        if (ea.needsUpdate && 0 !== ea.schedulePriority && 0 !== ea.priority) switch (V = !0, ca = Math.max(ca, ea.priority),
                                            ea.schedulePriority) {
                                            case 1:
                                                ea.schedulePriority = 0;
                                                this._runQueue.push(ea);
                                                break;
                                            default:
                                                --ea.schedulePriority
                                        }
                                    });
                                    if (!V) return this.updating = !1;
                                    this._maxReschedule === F && (this._maxReschedule = ca);
                                    --this._maxReschedule
                                }
                                return this.updating = !0
                            };
                            ba._run = function() {
                                const V = this._budget.now();
                                for (var ca = 0; ca < H.length; ++ca) H[ca] = 0;
                                do
                                    for (; 0 < this._runQueue.length;) {
                                        var ea = this._budget.now();
                                        ca = this._runQueue.pop();
                                        this._budget.resetProgress();
                                        try {
                                            ca.update(this._budget)
                                        } catch (sa) {
                                            v.error(`Exception in task "${ca.name}"`,
                                                sa)
                                        }
                                        ca.schedulePriority = ca.priority;
                                        ea = this._budget.now() - ea;
                                        ca.runtime += ea;
                                        H[D.get(ca.task)] += ea;
                                        this._debug && this._budget.elapsed > 2 * this._budget.budget && console.log("Task", ca.name, "used", this._budget.elapsed, "of max", this._budget.budget, "ms");
                                        if (0 >= this._budget.remaining) {
                                            this._recordFrameTaskTimes(H, this._budget.now() - V);
                                            return
                                        }
                                    }
                                while (this._schedule());
                                this._recordFrameTaskTimes(H, this._budget.now() - V)
                            };
                            ba._recordFrameTaskTimes = function(V, ca) {
                                for (let ea = 0; ea < V.length; ++ea) this.performanceInfo.tasks[ea].record(V[ea]);
                                this.performanceInfo.total.record(ca)
                            };
                            k._createClass(X, [{
                                key: "now",
                                get: function() {
                                    return this.nowFunc()
                                }
                            }, {
                                key: "load",
                                get: function() {
                                    return this._load
                                }
                            }, {
                                key: "state",
                                get: function() {
                                    return r.isNone(this._test.state) ? this._state : this._test.state
                                },
                                set: function(V) {
                                    this._state !== V && (this._state = V, 2 !== this.state && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = !1, this._idleStateCallbacks.forAll(ca => ca.idleEnd())))
                                }
                            }, {
                                key: "test",
                                get: function() {
                                    return this._test
                                }
                            }]);
                            return X
                        }(y);
                        w.__decorate([c.property()],
                            Q.prototype, "updating", void 0);
                        w.__decorate([c.property()], Q.prototype, "nowFunc", void 0);
                        Q = w.__decorate([e.subclass("esri.views.support.Scheduler")], Q);
                        I.Scheduler = Q;
                        let P = function(W) {
                            function X(V, ca, ea, sa, ma) {
                                var ra = W.call(this, {}) || this;
                                ra._scheduler = V;
                                ra.name = ca;
                                ra.update = ea;
                                ra._needsUpdateCB = sa;
                                ra._priority = ma;
                                ra.runtime = 0;
                                ra._queue = new q;
                                ra.updating = !1;
                                ra.schedulePriority = ra._priority;
                                return ra
                            }
                            k._inheritsLoose(X, W);
                            var ba = X.prototype;
                            ba.normalizeCtorArgs = function() {
                                return {}
                            };
                            ba.remove = function() {
                                this.processQueue(C);
                                this._scheduler.removeTask(this);
                                this.schedule = G.schedule;
                                this.reschedule = G.reschedule
                            };
                            ba.setPriority = function(V) {
                                this.name = V;
                                V = z(V);
                                if (0 === this._priority || 0 !== this.schedulePriority) this.schedulePriority = V;
                                this._priority = V
                            };
                            ba.schedule = function(V, ca) {
                                this.updating = !0;
                                return this._queue.push(V, ca)
                            };
                            ba.reschedule = function(V, ca) {
                                this.updating = !0;
                                return this._queue.unshift(V, ca)
                            };
                            ba.processQueue = function(V) {
                                for (; !V.done && this._queue.process();) V.madeProgress();
                                this.updating = 0 < this._queue.length
                            };
                            k._createClass(X, [{
                                key: "priority",
                                get: function() {
                                    return this._priority
                                }
                            }, {
                                key: "task",
                                get: function() {
                                    return this.name
                                },
                                set: function(V) {
                                    this.setPriority(V)
                                }
                            }, {
                                key: "needsUpdate",
                                get: function() {
                                    return this.updating || this._needsUpdateCB()
                                }
                            }]);
                            return X
                        }(y);
                        w.__decorate([c.property()], P.prototype, "updating", void 0);
                        P = w.__decorate([e.subclass("esri.views.support.SchedulerTask")], P);
                        let Y = function() {
                            function W(ba) {
                                this.now = ba;
                                this._budget = this._begin = 0;
                                this._state = 2;
                                this._didWork = !1;
                                this._enabled = !0
                            }
                            var X = W.prototype;
                            X.run =
                                function(ba) {
                                    if (this.done) return !1;
                                    !0 === ba() && (this._didWork = !0);
                                    return !0
                                };
                            X.madeProgress = function() {
                                this._didWork = !0
                            };
                            X.reset = function(ba, V) {
                                this._begin = this.now();
                                this._budget = ba;
                                this._state = V;
                                this._didWork = !1
                            };
                            X.resetProgress = function() {
                                this._didWork = !1
                            };
                            k._createClass(W, [{
                                key: "done",
                                get: function() {
                                    return this._didWork && this.elapsed >= this._budget && this._enabled
                                }
                            }, {
                                key: "budget",
                                get: function() {
                                    return this._budget
                                }
                            }, {
                                key: "state",
                                get: function() {
                                    return this._state
                                }
                            }, {
                                key: "enabled",
                                get: function() {
                                    return this._enabled
                                },
                                set: function(ba) {
                                    this._enabled = ba
                                }
                            }, {
                                key: "remaining",
                                get: function() {
                                    return Math.max(this._budget - this.elapsed, 0)
                                }
                            }, {
                                key: "elapsed",
                                get: function() {
                                    return this.now() - this._begin
                                }
                            }, {
                                key: "hasProgressed",
                                get: function() {
                                    return this._didWork
                                }
                            }]);
                            return W
                        }();
                        I.Budget = Y
                    })(E || (E = {}));
                    (function(I) {
                        I.SCHEDULED = "s";
                        I.READY = "r";
                        I.WAITING = "w";
                        I.IDLE = "i"
                    })(a.TaskState || (a.TaskState = {}));
                    const C = (() => {
                            const I = new E.Budget(() => performance.now());
                            I.enabled = !1;
                            return I
                        })(),
                        G = new(function() {
                            function I() {}
                            var Q = I.prototype;
                            Q.remove = function() {};
                            Q.processQueue = function() {};
                            Q.schedule = function(P) {
                                return u.when(P())
                            };
                            Q.reschedule = function(P) {
                                return u.when(P())
                            };
                            return I
                        }()),
                        F = Number.MAX_SAFE_INTEGER,
                        D = new Map,
                        H = [];
                    a.ImmediateTask = G;
                    a.getTaskPriority = z;
                    a.newScheduler = function(I) {
                        return new E.Scheduler({
                            nowFunc: I
                        })
                    };
                    a.noBudget = C;
                    a.taskPriorities = A;
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/chunks/tslib.es6": function() {
            define(["exports"], function(a) {
                a.__decorate = function(k, w, t, r) {
                    var f = arguments.length,
                        b = 3 >
                        f ? w : null === r ? r = Object.getOwnPropertyDescriptor(w, t) : r,
                        c;
                    if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) b = Reflect.decorate(k, w, t, r);
                    else
                        for (var g = k.length - 1; 0 <= g; g--)
                            if (c = k[g]) b = (3 > f ? c(b) : 3 < f ? c(w, t, b) : c(w, t)) || b;
                    return 3 < f && b && Object.defineProperty(w, t, b), b
                }
            })
        },
        "esri/core/accessorSupport/ensureType": function() {
            define(["exports", "../has", "../Logger"], function(a, k, w) {
                function t(D) {
                    return null == D ? D : new Date(D)
                }

                function r(D) {
                    return null == D ? D : !!D
                }

                function f(D) {
                    return null == D ? D : D.toString()
                }

                function b(D) {
                    if (null == D) return D;
                    D = parseFloat(D);
                    return isNaN(D) ? 0 : D
                }

                function c(D) {
                    return null == D ? D : Math.round(parseFloat(D))
                }

                function g(D) {
                    return D && D.constructor && void 0 !== D.constructor.__accessorMetadata__
                }

                function e(D, H) {
                    return null != H && D && !(H instanceof D)
                }

                function d(D) {
                    return D && D.Type ? "function" === typeof D.Type ? D.Type : D.Type.base : null
                }

                function h(D, H) {
                    var I;
                    (I = !H || !H.constructor) || (I = H.constructor, I = !(I && "isCollection" in I));
                    if (I) return p(D, H) ? H : new D(H);
                    I = d(D.prototype.itemType);
                    const Q = d(H.constructor.prototype.itemType);
                    if (!I) return H;
                    if (!Q) return new D(H);
                    if (I === Q) return H;
                    if (I.prototype.isPrototypeOf(Q.prototype)) return new D(H);
                    p(D, H);
                    return H
                }

                function p(D, H) {
                    return g(H) ? (G.error("Accessor#set", "Assigning an instance of '" + (H.declaredClass || "unknown") + "' which is not a subclass of '" + n(D) + "'"), !0) : !1
                }

                function l(D, H) {
                    return null == H ? H : D && "isCollection" in D ? h(D, H) : e(D, H) ? p(D, H) ? H : new D(H) : H
                }

                function n(D) {
                    return D && D.prototype && D.prototype.declaredClass || "unknown"
                }

                function u(D) {
                    switch (D) {
                        case Number:
                            return b;
                        case F:
                            return c;
                        case Boolean:
                            return r;
                        case String:
                            return f;
                        case Date:
                            return t;
                        default:
                            return l.bind(null, D)
                    }
                }

                function y(D, H) {
                    const I = u(D);
                    return 1 === arguments.length ? I : I(H)
                }

                function x(D, H, I) {
                    return 1 === arguments.length ? x.bind(null, D) : H ? Array.isArray(H) ? H.map(Q => D(Q, I)) : [D(H, I)] : H
                }

                function q(D, H, I) {
                    return 0 !== H && Array.isArray(I) ? I.map(Q => q(D, H - 1, Q)) : D(I)
                }

                function B(D, H, I) {
                    if (2 === arguments.length) return B.bind(null, D, H);
                    if (!I) return I;
                    I = q(D, H, I);
                    let Q = H;
                    for (var P = I; 0 < Q && Array.isArray(P);) Q--, P = P[0];
                    if (void 0 !== P)
                        for (P =
                            0; P < Q; P++) I = [I];
                    return I
                }

                function z(D, H) {
                    if (2 === arguments.length) return z(D).call(null, H);
                    const I = new Set,
                        Q = D.filter(X => "function" !== typeof X),
                        P = D.filter(X => "function" === typeof X);
                    for (const X of D) "string" !== typeof X && "number" !== typeof X || I.add(X);
                    let Y = null,
                        W = null;
                    return (X, ba) => {
                        if (null == X) return X;
                        const V = typeof X,
                            ca = "string" === V || "number" === V;
                        if (ca && (I.has(X) || P.some(ea => "string" === V && ea === String || "number" === V && ea === Number)) || "object" === V && P.some(ea => !e(X, ea))) return X;
                        ca && Q.length ? (Y || (Y = Q.map(ea =>
                            "string" === typeof ea ? `'${ea}'` : `${ea}`).join(", ")), G.error("Accessor#set", `'${X}' is not a valid value for this property, only the following values are valid: ${Y}`)) : "object" === typeof X && P.length ? (W || (W = P.map(ea => n(ea)).join(", ")), G.error("Accessor#set", `'${X}' is not a valid value for this property, value must be one of ${W}`)) : G.error("Accessor#set", `'${X}' is not a valid value for this property`);
                        ba && (ba.valid = !1);
                        return null
                    }
                }

                function v(D, H) {
                    if (2 === arguments.length) return v(D).call(null, H);
                    const I = {},
                        Q = [],
                        P = [];
                    for (const W in D.typeMap) {
                        const X = D.typeMap[W];
                        I[W] = y(X);
                        Q.push(n(X));
                        P.push(W)
                    }
                    const Y = "string" === typeof D.key ? W => W[D.key] : D.key;
                    return W => {
                        if (D.base && !e(D.base, W) || null == W) return W;
                        var X = Y(W) || D.defaultKeyValue;
                        const ba = I[X];
                        if (!ba) return G.error("Accessor#set", `Invalid property value, value needs to be one of ${`'${Q.join("', '")}'`}, or a plain object that can autocast (having .type = ${`'${P.join("', '")}'`})`), null;
                        if (!e(D.typeMap[X], W)) return W;
                        if ("string" === typeof D.key &&
                            !g(W)) {
                            X = {};
                            for (const V in W) V !== D.key && (X[V] = W[V]);
                            return ba(X)
                        }
                        return ba(W)
                    }
                }

                function A(D) {
                    switch (D.type) {
                        case "native":
                            return y(D.value);
                        case "array":
                            return x(A(D.value));
                        case "one-of":
                            return m(D);
                        default:
                            return null
                    }
                }

                function m(D) {
                    let H = null;
                    return (I, Q) => {
                        if (C(I, D)) return I;
                        null == H && (H = E(D));
                        G.error("Accessor#set", `Invalid property value, value needs to be of type ${H}`);
                        Q && (Q.valid = !1);
                        return null
                    }
                }

                function E(D) {
                    switch (D.type) {
                        case "native":
                            switch (D.value) {
                                case Number:
                                    return "number";
                                case String:
                                    return "string";
                                case Boolean:
                                    return "boolean";
                                case F:
                                    return "integer";
                                case Date:
                                    return "date";
                                default:
                                    return n(D.value)
                            }
                        case "array":
                            return `array of ${E(D.value)}`;
                        case "one-of":
                            return D = D.values.map(H => E(H)), `one of ${D.slice(0,D.length-1)} or ${D[D.length-1]}`
                    }
                    return "unknown"
                }

                function C(D, H) {
                    if (null == D) return !0;
                    switch (H.type) {
                        case "native":
                            switch (H.value) {
                                case Number:
                                case F:
                                    return "number" === typeof D;
                                case Boolean:
                                    return "boolean" === typeof D;
                                case String:
                                    return "string" === typeof D
                            }
                            return D instanceof H.value;
                        case "array":
                            return Array.isArray(D) ?
                                !D.some(I => !C(I, H.value)) : !1;
                        case "one-of":
                            return H.values.some(I => C(D, I))
                    }
                }
                const G = w.getLogger("esri.core.Accessor");
                let F = function() {};
                a.Integer = F;
                a.default = y;
                a.ensureArray = function(D, H) {
                    return 1 === arguments.length ? x(y.bind(null, D)) : x(y.bind(null, D), H)
                };
                a.ensureArrayTyped = x;
                a.ensureBoolean = r;
                a.ensureClass = l;
                a.ensureDate = t;
                a.ensureInteger = c;
                a.ensureLongFormType = A;
                a.ensureNArray = function(D, H, I) {
                    return 2 === arguments.length ? B(y.bind(null, D), H) : B(y.bind(null, D), H, I)
                };
                a.ensureNArrayTyped = B;
                a.ensureNumber =
                    b;
                a.ensureOneOf = z;
                a.ensureOneOfType = v;
                a.ensureString = f;
                a.ensureType = y;
                a.isClassedType = g;
                a.isLongFormType = function(D) {
                    if (!(D && "type" in D)) return !1;
                    switch (D.type) {
                        case "native":
                        case "array":
                        case "one-of":
                            return !0
                    }
                    return !1
                };
                a.isOneOf = function(D) {
                    return Array.isArray(D) ? !D.some(H => {
                        H = typeof H;
                        return !("string" === H || "number" === H || "function" === H && 1 < D.length)
                    }) : !1
                };
                a.requiresType = e;
                a.types = {
                    native(D) {
                        return {
                            type: "native",
                            value: D
                        }
                    },
                    array(D) {
                        return {
                            type: "array",
                            value: D
                        }
                    },
                    oneOf(D) {
                        return {
                            type: "one-of",
                            values: D
                        }
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/decorators/property": function() {
            define("exports ../../Logger ../ensureType ../get ../metadata ../set".split(" "), function(a, k, w, t, r, f) {
                function b(e) {
                    let d = 0;
                    var h = e;
                    if (w.isLongFormType(e)) return w.ensureLongFormType(e);
                    for (; Array.isArray(h) && 1 === h.length && "string" !== typeof h[0] && "number" !== typeof h[0];) h = h[0], d++;
                    return w.isOneOf(h) ? 0 === d ? w.ensureOneOf(h) : w.ensureNArrayTyped(w.ensureOneOf(h), d) : 1 === d ? w.ensureArray(h) : 1 <
                        d ? w.ensureNArray(h, d) : e.from ? e.from : w.ensureType(e)
                }

                function c(e, d) {
                    return h => {
                        h = +e(h);
                        null != d.step && (h = Math.round(h / d.step) * d.step);
                        null != d.min && (h = Math.max(d.min, h));
                        null != d.max && (h = Math.min(d.max, h));
                        return h
                    }
                }
                const g = k.getLogger("esri.core.accessorSupport.decorators.property");
                a.ensureRange = c;
                a.property = function(e = {}) {
                    return (d, h, p) => {
                        if (d === Function.prototype) throw Error(`Inappropriate use of @property() on a static field: ${d.name}.${h}. Accessor does not support static properties.`);
                        const l =
                            r.getOwnPropertyMetadata(d, h);
                        p && (p.get || p.set ? (l.get = p.get || l.get, l.set = p.set || l.set) : "value" in p && ("value" in e && g.warn(`@property() will redefine the value of "${h}" on "${d.constructor.name}" already defined in the metadata`, e), l.value = e.value = p.value));
                        null != e.readOnly && (l.readOnly = e.readOnly);
                        if (d = e.aliasOf) {
                            const n = "string" === typeof d ? d : d.source;
                            d = "string" === typeof d ? null : !0 === d.overridable;
                            let u;
                            l.dependsOn = [n];
                            l.get = function() {
                                let y = t.get(this, n);
                                if ("function" === typeof y) {
                                    u || (u = n.split(".").slice(0, -1).join("."));
                                    const x = t.get(this, u);
                                    x && (y = y.bind(x))
                                }
                                return y
                            };
                            l.readOnly || (l.set = d ? function(y) {
                                void 0 !== y ? this._override(h, y) : this._clearOverride(h)
                            } : function(y) {
                                f.set(this, n, y)
                            })
                        }
                        d = e.type;
                        p = e.types;
                        l.cast || (d ? l.cast = b(d) : p && (Array.isArray(p) ? l.cast = w.ensureArrayTyped(w.ensureOneOfType(p[0])) : l.cast = w.ensureOneOfType(p)));
                        e.range && (l.cast = c(l.cast, e.range));
                        r.mergeProperty(l, e)
                    }
                };
                a.propertyJSONMeta = function(e, d, h) {
                    e = r.getOwnPropertyMetadata(e, h);
                    e.json || (e.json = {});
                    e = e.json;
                    void 0 !== d && (e.origins ||
                        (e.origins = {}), e.origins[d] || (e.origins[d] = {}), e = e.origins[d]);
                    return e
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/get": function() {
            define(["exports", "./utils"], function(a, k) {
                function w(b, c) {
                    b = "?" === b[b.length - 1] ? b.slice(0, -1) : b;
                    if (null != c.getItemAt || Array.isArray(c)) {
                        var g = parseInt(b, 10);
                        if (!isNaN(g)) return Array.isArray(c) ? c[g] : c.getItemAt(g)
                    }
                    g = k.getProperties(c);
                    return k.isPropertyDeclared(g, b) ? g.get(b) : c[b]
                }

                function t(b, c, g) {
                    if (null == b) return b;
                    if ((b = w(c[g],
                            b)) || !(g < c.length - 1)) return g === c.length - 1 ? b : t(b, c, g + 1)
                }

                function r(b, c, g = 0) {
                    return "string" === typeof c && -1 === c.indexOf(".") ? w(c, b) : t(b, k.pathToArray(c), g)
                }

                function f(b, c) {
                    return r(b, c)
                }
                a.default = f;
                a.exists = function(b, c) {
                    return void 0 !== r(c, b)
                };
                a.get = f;
                a.valueOf = r;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/utils": function() {
            define(["exports", "../lang", "../maybe", "../handleUtils"], function(a, k, w, t) {
                function r(e) {
                    return e ? e.__accessor__ ? e.__accessor__ : e.propertyInvalidated ?
                        e : null : null
                }

                function f(e, d, h) {
                    return d ? Object.keys(d).reduce(function(p, l) {
                        let n = null;
                        var u = "merge";
                        h && (n = h.path ? `${h.path}.${l}` : l, u = h.policy(n));
                        if ("replace" === u) return p[l] = d[l], p;
                        if (void 0 === p[l]) return p[l] = k.clone(d[l]), p;
                        let y = p[l];
                        u = d[l];
                        if (y === u) return p;
                        if (Array.isArray(u) || Array.isArray(p)) y = y ? Array.isArray(y) ? p[l] = y.concat() : p[l] = [y] : p[l] = [], u && (Array.isArray(u) || (u = [u]), u.forEach(x => {
                            -1 === y.indexOf(x) && y.push(x)
                        }));
                        else if (u && "object" === typeof u)
                            if (h) {
                                const x = h.path;
                                h.path = w.assumeNonNull(n);
                                p[l] = f(y, u, h);
                                h.path = x
                            } else p[l] = f(y, u, null);
                        else if (!p.hasOwnProperty(l) || d.hasOwnProperty(l)) p[l] = u;
                        return p
                    }, e || {}) : e
                }

                function b(e) {
                    return Array.isArray(e) ? e : e.split(".")
                }

                function c(e) {
                    return -1 < e.indexOf(",") ? e.split(",").map(d => d.trim()) : [e.trim()]
                }

                function g(e) {
                    if (Array.isArray(e)) {
                        const d = [];
                        for (const h of e) d.push(...c(h));
                        return d
                    }
                    return c(e)
                }
                a.getDependsInfo = function(e, d) {
                    const h = r(e);
                    return h ? h.getDependsInfo(e, d, "") : ""
                };
                a.getProperties = r;
                a.isPropertyDeclared = function(e, d) {
                    return null !=
                        e && e.metadatas && null != e.metadatas[d]
                };
                a.merge = function(e, d, h) {
                    return h ? f(e, d, {
                        policy: h,
                        path: ""
                    }) : f(e, d, null)
                };
                a.once = function(e) {
                    let d = !1;
                    return () => {
                        d || (d = !0, e())
                    }
                };
                a.parse = function(e, d, h, p) {
                    d = g(d);
                    return 1 !== d.length ? (d = d.map(l => p(e, l, h)), t.handlesGroup(d)) : p(e, d[0], h)
                };
                a.parseConditionalPath = function(e) {
                    if (-1 === e.indexOf("?")) return null;
                    e = b(e);
                    const d = Array(e.length);
                    for (let h = 0; h < e.length; h++) {
                        const p = e[h];
                        d[h] = "?" === p[p.length - 1];
                        d[h] && (e[h] = p.slice(0, -1))
                    }
                    return {
                        fullPath: e.join("."),
                        conditional: d
                    }
                };
                a.pathToArray = b;
                a.pathToStringOrArray = function(e) {
                    return !e || "string" === typeof e && -1 === e.indexOf(".") ? e : b(e)
                };
                a.splitPath = g;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/handleUtils": function() {
            define(["exports", "./maybe"], function(a, k) {
                function w(t) {
                    return {
                        remove: () => {
                            t && (t(), t = void 0)
                        }
                    }
                }
                a.asyncHandle = function(t, r) {
                    let f = !1,
                        b = null;
                    t.then(c => {
                        f ? c.remove() : b = c
                    });
                    return w(() => {
                        f = !0;
                        k.isSome(b) ? b.remove() : k.isSome(r) && (r.abort(), r = null)
                    })
                };
                a.destroyHandle = function(t) {
                    return w(k.isSome(t) ?
                        () => t.destroy() : void 0)
                };
                a.handlesGroup = function(t) {
                    return w(() => t.forEach(r => k.isSome(r) && r.remove()))
                };
                a.makeHandle = w;
                a.refHandle = function(t) {
                    return w(() => {
                        const r = t();
                        k.isSome(r) && r.remove()
                    })
                };
                a.timeoutHandle = function(t, r) {
                    const f = setTimeout(t, r);
                    return w(() => clearTimeout(f))
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/metadata": function() {
            define(["exports", "../lang", "../maybe", "./utils"], function(a, k, w, t) {
                function r(h) {
                    let p = h.constructor.__accessorMetadata__;
                    var l = Object.prototype.hasOwnProperty.call(h.constructor, "__accessorMetadata__");
                    if (!p) p = new g({}), Object.defineProperty(h.constructor, "__accessorMetadata__", {
                        value: p,
                        enumerable: !1,
                        configurable: !0,
                        writable: !0
                    });
                    else if (!l) {
                        l = Object.create(p.properties);
                        const n = p.autoDestroy;
                        for (const u in l) l[u] = k.clone(l[u]);
                        p = new g(l);
                        p.autoDestroy = n;
                        Object.defineProperty(h.constructor, "__accessorMetadata__", {
                            value: p,
                            enumerable: !1,
                            configurable: !0,
                            writable: !0
                        })
                    }
                    return w.assumeNonNull(h.constructor.__accessorMetadata__)
                }

                function f(h) {
                    return r(h).properties
                }

                function b(h) {
                    return e.test(h) ? "replace" : "merge"
                }

                function c(h) {
                    return d.test(h) ? b(h.slice(11)) : "merge"
                }
                let g = function(h) {
                    this.autoDestroy = !1;
                    this.properties = h
                };
                const e = /^(?:[^.]+\.)?(?:value|type|(?:json\.type|json\.origins\.[^.]\.type))$/,
                    d = /^properties\./;
                a.ClassMetadata = g;
                a.getOwnClassMetadata = r;
                a.getOwnPropertiesMetadata = f;
                a.getOwnPropertyMetadata = function(h, p) {
                    h = f(h);
                    let l = h[p];
                    l || (l = h[p] = {});
                    return l
                };
                a.merge = function(h, p) {
                    return t.merge(h, p, c)
                };
                a.mergeProperty =
                    function(h, p) {
                        return t.merge(h, p, b)
                    };
                a.setPropertyMetadata = function(h, p, l) {
                    f(h)[p] = l
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/set": function() {
            define(["exports", "../has", "../Logger", "./get"], function(a, k, w, t) {
                function r(f, b, c) {
                    if (f && b)
                        if ("object" === typeof b)
                            for (var g of Object.getOwnPropertyNames(b)) r(f, g, b[g]);
                        else -1 !== b.indexOf(".") ? (b = b.split("."), g = b.splice(b.length - 1, 1)[0], r(t.get(f, b), g, c)) : f[b] = c
                }
                w.getLogger("esri.core.accessorSupport.set");
                a.default = r;
                a.set = r;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/jsonMap": function() {
            define(["exports"], function(a) {
                let k = function() {
                    function w(r, f = {
                        ignoreUnknown: !1
                    }) {
                        this.jsonToAPI = r;
                        this.options = f;
                        this.apiValues = [];
                        this.jsonValues = [];
                        this.apiToJSON = this.invertMap(r);
                        this.apiValues = this.getKeysSorted(this.apiToJSON);
                        this.jsonValues = this.getKeysSorted(this.jsonToAPI);
                        this.read = b => this.fromJSON(b);
                        this.write = (b, c, g) => {
                            b = this.toJSON(b);
                            void 0 !== b && (c[g] = b)
                        };
                        this.write.isJSONMapWriter = !0
                    }
                    var t =
                        w.prototype;
                    t.toJSON = function(r) {
                        return this.apiToJSON.hasOwnProperty(r) ? this.apiToJSON[r] : this.options.ignoreUnknown ? void 0 : r
                    };
                    t.fromJSON = function(r) {
                        return this.jsonToAPI.hasOwnProperty(r) ? this.jsonToAPI[r] : this.options.ignoreUnknown ? void 0 : r
                    };
                    t.invertMap = function(r) {
                        const f = {};
                        for (const b in r) f[r[b]] = b;
                        return f
                    };
                    t.getKeysSorted = function(r) {
                        const f = [];
                        for (const b in r) f.push(b);
                        f.sort();
                        return f
                    };
                    return w
                }();
                a.JSONMap = k;
                a.default = k;
                a.strict = function() {
                    return function(w) {
                        return new k(w, {
                            ignoreUnknown: !0
                        })
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/decorators/subclass": function() {
            define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../has", "../metadata", "../extensions"], function(a, k, w, t, r) {
                function f(e, d) {
                    return null == d.get ? function() {
                        return this.__accessor__.getterStatic(e)
                    } : function() {
                        return this.__accessor__.getterComputed(e)
                    }
                }

                function b(e) {
                    var d = e.prototype,
                        h = d.declaredClass;
                    d = t.getOwnClassMetadata(d).properties;
                    r.processClassMetadatas(d, h);
                    h = {};
                    for (const p of Object.getOwnPropertyNames(d)) {
                        const l = d[p];
                        h[p] = {
                            enumerable: !0,
                            configurable: !0,
                            get: f(p, l),
                            set(n) {
                                const u = this.__accessor__;
                                if (void 0 === u) Object.defineProperty(this, p, {
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0,
                                    value: n
                                });
                                else if (!Object.isFrozen(this)) {
                                    if (u.initialized && l.readOnly) throw new TypeError(`[accessor] cannot assign to read-only property '${p}' of ${this.declaredClass}`);
                                    if (2 === u.lifecycle && l.constructOnly) throw new TypeError(`[accessor] cannot assign to construct-only property '${p}' of ${this.declaredClass}`);
                                    u.set(p, n)
                                }
                            }
                        }
                    }
                    Object.defineProperties(e.prototype, h)
                }
                const c = new Set,
                    g = new Set;
                a.processClass = b;
                a.subclass = function(e) {
                    return d => {
                        d.prototype.declaredClass = e;
                        r.processPrototypeMetadatas(t.getOwnClassMetadata(d.prototype).properties, e);
                        b(d);
                        const h = [],
                            p = [];
                        for (var l = d.prototype; l;) l.hasOwnProperty("initialize") && !c.has(l.initialize) && (c.add(l.initialize), h.push(l.initialize)), l.hasOwnProperty("destroy") && !g.has(l.destroy) && (g.add(l.destroy), p.push(l.destroy)), l = Object.getPrototypeOf(l);
                        c.clear();
                        g.clear();
                        l = function(n) {
                            function u(...y) {
                                var x = n.call(this, ...y) || this;
                                if (x.constructor === u && "function" === typeof x.postscript) {
                                    h.length && Object.defineProperty(k._assertThisInitialized(x), "initialize", {
                                        enumerable: !1,
                                        configurable: !0,
                                        value() {
                                            for (let q = h.length - 1; 0 <= q; q--) h[q].call(this)
                                        }
                                    });
                                    if (p.length) {
                                        let q = !1;
                                        Object.defineProperty(k._assertThisInitialized(x), "destroy", {
                                            enumerable: !1,
                                            configurable: !0,
                                            value() {
                                                if (!q) {
                                                    q = !0;
                                                    for (let B = 0; B < p.length; B++) p[B].call(this)
                                                }
                                            }
                                        })
                                    }
                                    x.postscript(...y)
                                }
                                return x
                            }
                            k._inheritsLoose(u,
                                n);
                            return u
                        }(d);
                        l.__accessorMetadata__ = t.getOwnClassMetadata(d.prototype);
                        l.prototype.declaredClass = e;
                        return l
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/extensions": function() {
            define(["exports", "./extensions/serializableProperty"], function(a, k) {
                const w = [k.SerializablePropertyExtension];
                a.instanceCreated = function(t, r) {
                    const f = Object.getOwnPropertyNames(r);
                    for (const b of w) b.instanceCreated && b.instanceCreated(t, r, f)
                };
                a.processClassMetadatas = function(t, r) {
                    for (const f of w)
                        if (f.processClassPropertyMetadata)
                            for (const b in t) f.processClassPropertyMetadata(b,
                                t[b], t, r)
                };
                a.processPrototypeMetadatas = function(t, r) {
                    for (const f of w)
                        if (f.processPrototypePropertyMetadata)
                            for (const b in t) f.processPrototypePropertyMetadata(b, t[b], t, r)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/extensions/serializableProperty": function() {
            define("exports ../ensureType ./serializableProperty/originAliases ./serializableProperty/reader ./serializableProperty/shorthands ./serializableProperty/writer".split(" "), function(a, k, w, t, r, f) {
                function b(g,
                    e, d) {
                    let h = g && g.json;
                    g && g.json && g.json.origins && d && (g = g.json.origins[d.origin]) && ("any" === e || e in g) && (h = g);
                    return h
                }
                const c = {
                    processPrototypePropertyMetadata(g, e) {
                        if (r.process(e)) {
                            w.process(e);
                            if (e.type)
                                if (e.type) {
                                    g = 0;
                                    for (var d = e.type; Array.isArray(d) && !k.isOneOf(d);) d = d[0], g++;
                                    g = {
                                        type: d,
                                        ndimArray: g
                                    }
                                } else g = void 0;
                            else if (e.types) {
                                g = 0;
                                for (d = e.types; Array.isArray(d);) d = d[0], g++;
                                g = {
                                    types: d,
                                    ndimArray: g
                                }
                            } else g = void 0;
                            if (e.json.origins)
                                for (const h in e.json.origins) d = e.json.origins[h], t.create(g, d, !1),
                                    f.create(g, d);
                            t.create(g, e.json, !0);
                            f.create(g, e.json)
                        }
                    }
                };
                a.SerializablePropertyExtension = c;
                a.default = c;
                a.originSpecificPropertyDefinition = b;
                a.originSpecificReadPropertyDefinition = function(g, e) {
                    return b(g, "read", e)
                };
                a.originSpecificWritePropertyDefinition = function(g, e) {
                    return b(g, "write", e)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/extensions/serializableProperty/originAliases": function() {
            define(["exports"], function(a) {
                a.process = function(k) {
                    if (k.json && k.json.origins) {
                        const w =
                            k.json.origins;
                        k = {
                            "web-document": ["web-scene", "web-map"]
                        };
                        for (const t in k)
                            if (w[t]) {
                                const r = w[t];
                                k[t].forEach(f => {
                                    w[f] = r
                                });
                                delete w[t]
                            }
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/extensions/serializableProperty/reader": function() {
            define("exports ../../../object ../../../Logger ../../metadata ../../../Warning ./type".split(" "), function(a, k, w, t, r, f) {
                function b(x) {
                    var q;
                    const B = null != (q = x.ndimArray) ? q : 0;
                    if (1 < B) return d(x);
                    if (1 === B) return h(x);
                    if ("type" in x && p(x.type)) {
                        var z,
                            v;
                        q = null == (z = x.type.prototype) ? void 0 : null == (v = z.itemType) ? void 0 : v.Type;
                        const A = h("function" === typeof q ? {
                            type: q
                        } : {
                            types: q
                        });
                        return (m, E, C) => (m = A(m, E, C)) ? new x.type(m) : m
                    }
                    return c(x)
                }

                function c(x) {
                    return "type" in x ? g(x.type) : u(x.types)
                }

                function g(x) {
                    return x.prototype.read ? (q, B, z) => {
                        if (null == q) return q;
                        B = typeof q;
                        if ("object" !== B) y.error(`Expected JSON value of type 'object' to deserialize type '${x.prototype.declaredClass}', but got '${B}'`);
                        else return B = new x, B.read(q, z), B
                    } : x.fromJSON
                }

                function e(x,
                    q, B, z) {
                    return 0 !== z && Array.isArray(q) ? q.map(v => e(x, v, B, z - 1)) : x(q, void 0, B)
                }

                function d(x) {
                    var q;
                    const B = c(x),
                        z = e.bind(null, B),
                        v = null != (q = x.ndimArray) ? q : 0;
                    return (A, m, E) => {
                        if (null == A) return A;
                        A = z(A, E, v);
                        m = v;
                        for (E = A; 0 < m && Array.isArray(E);) m--, E = E[0];
                        if (void 0 !== E)
                            for (E = 0; E < m; E++) A = [A];
                        return A
                    }
                }

                function h(x) {
                    const q = c(x);
                    return (B, z, v) => {
                        if (null == B) return B;
                        if (Array.isArray(B)) {
                            z = [];
                            for (const A of B) B = q(A, void 0, v), void 0 !== B && z.push(B);
                            return z
                        }
                        v = q(B, void 0, v);
                        return void 0 !== v ? [v] : void 0
                    }
                }

                function p(x) {
                    return f.isCollection(x) ?
                        (x = x.prototype.itemType) && x.Type ? "function" === typeof x.Type ? l(x.Type) : n(x.Type) : !1 : !1
                }

                function l(x) {
                    return Array.isArray(x) ? !1 : !!x && x.prototype && ("read" in x.prototype || "fromJSON" in x || p(x))
                }

                function n(x) {
                    for (const q in x.typeMap)
                        if (!l(x.typeMap[q])) return !1;
                    return !0
                }

                function u(x) {
                    var q;
                    let B = null;
                    const z = null != (q = x.errorContext) ? q : "type";
                    return (v, A, m) => {
                        if (null == v) return v;
                        A = typeof v;
                        if ("object" !== A) y.error(`Expected JSON value of type 'object' to deserialize, but got '${A}'`);
                        else {
                            if (!B) {
                                A = {};
                                for (const D in x.typeMap) {
                                    var E,
                                        C;
                                    const H = x.typeMap[D];
                                    var G = t.getOwnClassMetadata(H.prototype);
                                    if ("function" === typeof x.key) continue;
                                    G = G.properties[x.key];
                                    if (!G) continue;
                                    null != (E = G.json) && E.type && Array.isArray(G.json.type) && 1 === G.json.type.length && "string" === typeof G.json.type[0] && (A[G.json.type[0]] = H);
                                    G = null == (C = G.json) ? void 0 : C.write;
                                    if (!G || !G.writer) {
                                        A[D] = H;
                                        continue
                                    }
                                    var F = G.target;
                                    F = "string" === typeof F ? F : x.key;
                                    const I = {};
                                    G.writer(D, I, F);
                                    I[F] && (A[I[F]] = H)
                                }
                                B = A
                            }
                            E = x.key;
                            if ("string" === typeof E) {
                                if (C = (E = v[E]) ? B[E] : x.defaultKeyValue ?
                                    x.typeMap[x.defaultKeyValue] : void 0) return E = new C, E.read(v, m), E;
                                E = `Type '${E||"unknown"}' is not supported`;
                                m && m.messages && v && m.messages.push(new r(`${z}:unsupported`, E, {
                                    definition: v,
                                    context: m
                                }));
                                y.error(E)
                            }
                        }
                    }
                }
                const y = w.getLogger("esri.core.accessorSupport.extensions.serializableProperty.reader");
                a.create = function(x, q, B) {
                    var z, v;
                    !x || !B && !q.read || null != (z = q.read) && z.reader || !1 === (null == (v = q.read) ? void 0 : v.enabled) || (B = "types" in x ? n(x.types) : l(x.type), B && k.setDeepValue("read.reader", b(x), q))
                };
                a.createTypeReader =
                    b;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/Warning": function() {
            define(["../chunks/_rollupPluginBabelHelpers", "./Message"], function(a, k) {
                k = function(w) {
                    function t(r, f, b) {
                        var c = w.call(this, r, f, b) || this;
                        return a._assertThisInitialized(c) instanceof t ? c : new t(r, f, b)
                    }
                    a._inheritsLoose(t, w);
                    return t
                }(k);
                k.prototype.type = "warning";
                return k
            })
        },
        "esri/core/accessorSupport/extensions/serializableProperty/type": function() {
            define(["exports"], function(a) {
                a.isCollection = function(k) {
                    return !!k &&
                        k.prototype && k.prototype.declaredClass && 0 === k.prototype.declaredClass.indexOf("esri.core.Collection")
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/extensions/serializableProperty/shorthands": function() {
            define(["exports"], function(a) {
                function k(r) {
                    r.name && (r.read ? "object" === typeof r.read ? void 0 === r.read.source && (r.read.source = r.name) : r.read = {
                        source: r.name
                    } : r.read = {
                        source: r.name
                    }, r.write ? "object" === typeof r.write ? void 0 === r.write.target && (r.write.target = r.name) : r.write = {
                        target: r.name
                    } : r.write = {
                        target: r.name
                    })
                }

                function w(r) {
                    "boolean" === typeof r.read ? r.read = {
                        enabled: r.read
                    } : "function" === typeof r.read ? r.read = {
                        enabled: !0,
                        reader: r.read
                    } : r.read && "object" === typeof r.read && void 0 === r.read.enabled && (r.read.enabled = !0)
                }

                function t(r) {
                    "boolean" === typeof r.write ? r.write = {
                        enabled: r.write
                    } : "function" === typeof r.write ? r.write = {
                        enabled: !0,
                        writer: r.write
                    } : r.write && "object" === typeof r.write && void 0 === r.write.enabled && (r.write.enabled = !0)
                }
                a.process = function(r) {
                    r.json || (r.json = {});
                    w(r.json);
                    t(r.json);
                    k(r.json);
                    if (r.json.origins)
                        for (const f in r.json.origins) w(r.json.origins[f]), t(r.json.origins[f]), k(r.json.origins[f]);
                    return !0
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/extensions/serializableProperty/writer": function() {
            define(["exports", "../../../object", "./type"], function(a, k, w) {
                function t(e, d, h, p) {
                    k.setDeepValue(h, r(e, p), d)
                }

                function r(e, d) {
                    return e && "function" === typeof e.write ? e.write({}, d) : e && "function" === typeof e.toJSON ? e.toJSON() :
                        "number" === typeof e ? f(e) : e
                }

                function f(e) {
                    return -Infinity === e ? -Number.MAX_VALUE : Infinity === e ? Number.MAX_VALUE : isNaN(e) ? null : e
                }

                function b(e, d, h, p) {
                    null === e ? e = null : e && "function" === typeof e.map ? (e = e.map(l => r(l, p)), "function" === typeof e.toArray && (e = e.toArray())) : e = [r(e, p)];
                    k.setDeepValue(h, e, d)
                }

                function c(e, d, h) {
                    return 0 !== h && Array.isArray(e) ? e.map(p => c(p, d, h - 1)) : r(e, d)
                }

                function g(e) {
                    return function(d, h, p, l) {
                        if (null === d) d = null;
                        else {
                            d = c(d, l, e);
                            l = e;
                            for (var n = d; 0 < l && Array.isArray(n);) l--, n = n[0];
                            if (void 0 !==
                                n)
                                for (n = 0; n < l; n++) d = [d]
                        }
                        k.setDeepValue(p, d, h)
                    }
                }
                a.create = function(e, d) {
                    var h;
                    if (d.write && !d.write.writer && (!1 !== d.write.enabled || d.write.overridePolicy)) {
                        var p = null != (h = null == e ? void 0 : e.ndimArray) ? h : 0;
                        e && (1 === p || "type" in e && w.isCollection(e.type)) ? d.write.writer = b : d.write.writer = 1 < p ? g(p) : t
                    }
                };
                a.numberToJSON = f;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/uuid": function() {
            define(["exports", "./global"], function(a, k) {
                const w = k.crypto || k.msCrypto;
                a.generateUUID = function() {
                    const t = w.getRandomValues(new Uint16Array(8));
                    t[3] = t[3] & 4095 | 16384;
                    t[4] = t[4] & 16383 | 32768;
                    return t[0].toString(16) + t[1].toString(16) + "-" + t[2].toString(16) + "-" + t[3].toString(16) + "-" + t[4].toString(16) + "-" + t[5].toString(16) + t[6].toString(16) + t[7].toString(16)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/portal/support/resourceExtension": function() {
            define(["exports", "../../core/urlUtils"], function(a, k) {
                const w = {},
                    t = w["text/plain"],
                    r = {
                        png: "image/png",
                        jpeg: "image/jpeg",
                        jpg: "image/jpg",
                        bmp: "image/bmp",
                        gif: "image/gif",
                        json: "application/json",
                        txt: "text/plain",
                        xml: "application/xml",
                        svg: "image/svg+xml",
                        zip: "application/zip",
                        pbf: "application/vnd.mapbox-vector-tile",
                        gz: "application/gzip"
                    };
                for (const f in r) w[r[f]] = f;
                a.getResourceContentExtension = function(f) {
                    f instanceof Blob ? f = f.type : (f = k.getPathExtension(f.url), f = r[f] || "text/plain");
                    return w[f] || t
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/PerformanceSampler": function() {
            define(["../chunks/_rollupPluginBabelHelpers"], function(a) {
                return function() {
                    function k(w, t = 29) {
                        this.name =
                            w;
                        this._counter = 0;
                        this._items = Array(t)
                    }
                    k.prototype.record = function(w) {
                        this._items[++this._counter % this._items.length] = w
                    };
                    a._createClass(k, [{
                        key: "median",
                        get: function() {
                            return this._items.slice().sort()[Math.floor(this._items.length / 2)]
                        }
                    }, {
                        key: "average",
                        get: function() {
                            return this._items.reduce((w, t) => w + t, 0) / this._items.length
                        }
                    }, {
                        key: "last",
                        get: function() {
                            return this._items[this._counter % this._items.length]
                        }
                    }]);
                    return k
                }()
            })
        },
        "esri/core/PooledArray": function() {
            define(["../chunks/_rollupPluginBabelHelpers",
                "./arrayUtils", "./HeapSort"
            ], function(a, k, w) {
                function t(r) {
                    r.data.length > 1.5 * r.length && (r.data.length = Math.floor(1.1 * r.length))
                }
                return function() {
                    function r(b) {
                        this.data = [];
                        this._length = 0;
                        this._allocator = void 0;
                        this._deallocator = () => null;
                        this._shrink = () => {};
                        this._hint = new k.PositionHint;
                        b && (b.initialSize && (this.data = Array(b.initialSize)), b.allocator && (this._allocator = b.allocator), void 0 !== b.deallocator && (this._deallocator = b.deallocator), b.shrink && (this._shrink = () => t(this)))
                    }
                    var f = r.prototype;
                    f.toArray =
                        function() {
                            return this.data.slice(0, this.length)
                        };
                    f.getItemAt = function(b) {
                        if (!(0 > b || b >= this._length)) return this.data[b]
                    };
                    f.clear = function() {
                        this.length = 0
                    };
                    f.prune = function() {
                        this.clear();
                        this.data = []
                    };
                    f.push = function(b) {
                        this.data[this._length++] = b
                    };
                    f.pushArray = function(b, c = b.length) {
                        for (let g = 0; g < c; g++) this.data[this._length++] = b[g]
                    };
                    f.fill = function(b, c) {
                        for (let g = 0; g < c; g++) this.data[this._length++] = b
                    };
                    f.pushNew = function() {
                        this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
                        const b = this.data[this._length];
                        ++this._length;
                        return b
                    };
                    f.unshift = function(b) {
                        this.data.unshift(b);
                        this._length++;
                        t(this)
                    };
                    f.pop = function() {
                        if (0 !== this.length) {
                            var b = this.data[this.length - 1];
                            --this.length;
                            this._shrink();
                            return b
                        }
                    };
                    f.remove = function(b) {
                        const c = k.indexOf(this.data, b, this.length, this._hint);
                        if (-1 !== c) return this.data.splice(c, 1), --this.length, b
                    };
                    f.removeUnordered = function(b) {
                        b = k.removeUnordered(this.data, b, this.length, this._hint);
                        void 0 !== b && --this.length;
                        this._shrink();
                        return b
                    };
                    f.removeUnorderedIndex =
                        function(b) {
                            if (!(b >= this.length || 0 > b)) return this.swapElements(b, this.length - 1), this.pop()
                        };
                    f.removeUnorderedMany = function(b, c = b.length, g) {
                        this.length = k.removeUnorderedMany(this.data, b, this.length, c, this._hint, g);
                        this._shrink()
                    };
                    f.front = function() {
                        if (0 !== this.length) return this.data[0]
                    };
                    f.back = function() {
                        if (0 !== this.length) return this.data[this.length - 1]
                    };
                    f.swapElements = function(b, c) {
                        b >= this.length || c >= this.length || b === c || ([this.data[b], this.data[c]] = [this.data[c], this.data[b]])
                    };
                    f.sort = function(b) {
                        w.sort(this.data,
                            0, this.length, b)
                    };
                    f.iterableSort = function(b) {
                        return w.iterableSort(this.data, 0, this.length, b)
                    };
                    f.some = function(b, c) {
                        for (let g = 0; g < this.length; ++g)
                            if (b.call(c, this.data[g], g, this.data)) return !0;
                        return !1
                    };
                    f.filterInPlace = function(b, c) {
                        let g = 0;
                        for (let e = 0; e < this._length; ++e) {
                            const d = this.data[e];
                            b.call(c, d, e, this.data) && (this.data[e] = this.data[g], this.data[g] = d, g++)
                        }
                        if (this._deallocator)
                            for (b = g; b < this._length; b++) this.data[b] = this._deallocator(this.data[b]);
                        this._length = g;
                        this._shrink();
                        return this
                    };
                    f.forAll = function(b, c) {
                        const g = this.length,
                            e = this.data;
                        for (let d = 0; d < g; ++d) b.call(c, e[d], d, e)
                    };
                    f.map = function(b, c) {
                        const g = Array(this.length);
                        for (let e = 0; e < this.length; ++e) g[e] = b.call(c, this.data[e], e, this.data);
                        return g
                    };
                    f.reduce = function(b, c) {
                        for (let g = 0; g < this.length; ++g) c = b(c, this.data[g], g, this.data);
                        return c
                    };
                    f.has = function(b) {
                        const c = this.length,
                            g = this.data;
                        for (let e = 0; e < c; ++e)
                            if (g[e] === b) return !0;
                        return !1
                    };
                    a._createClass(r, [{
                        key: "length",
                        get: function() {
                            return this._length
                        },
                        set: function(b) {
                            if (b >
                                this._length)
                                if (this._allocator)
                                    for (; this._length < b;) this.data[this._length++] = this._allocator(this.data[this._length]);
                                else this._length = b;
                            else {
                                if (this._deallocator)
                                    for (let c = b; c < this._length; ++c) this.data[c] = this._deallocator(this.data[c]);
                                this._length = b;
                                this._shrink()
                            }
                        }
                    }]);
                    return r
                }()
            })
        },
        "esri/core/arrayUtils": function() {
            define(["exports", "./maybe", "./RandomLCG"], function(a, k, w) {
                function t(p) {
                    return p
                }

                function r(p, l = t) {
                    if (p && 0 !== p.length) {
                        var n = p[0],
                            u = l(n);
                        for (let y = 1; y < p.length; ++y) {
                            const x = p[y],
                                q = Number(l(x));
                            q > u && (u = q, n = x)
                        }
                        return n
                    }
                }

                function f(p, l, n, u) {
                    u = u || e;
                    var y = Math.max(0, u.last - 10);
                    for (let x = y; x < n; ++x)
                        if (p[x] === l) return u.last = x;
                    n = Math.min(y, n);
                    for (y = 0; y < n; ++y)
                        if (p[y] === l) return u.last = y;
                    return -1
                }

                function b(p) {
                    return p ? (h.seed = p, () => h.getFloat()) : Math.random
                }
                const c = !!Array.prototype.fill;
                let g = function() {
                    this.last = 0
                };
                const e = new g,
                    d = new Set,
                    h = new w;
                a.PositionHint = g;
                a.binaryFindClosest = function(p, l, n) {
                    if (p && 0 !== p.length) {
                        var u = p.length - 1,
                            y = p[0];
                        if (l <= n(y)) return y;
                        y = p[u];
                        if (l >= n(y)) return y;
                        var x = 0;
                        y = 0;
                        for (var q = u; x < q;) {
                            y = x + Math.floor((q - x) / 2);
                            const z = p[y],
                                v = n(z);
                            if (v === l) return z;
                            if (l < v) {
                                if (0 < y) {
                                    q = p[y - 1];
                                    var B = n(q);
                                    if (l > B) return l - B >= v - l ? z : q
                                }
                                q = y
                            } else {
                                if (y < u && (x = p[y + 1], B = n(x), l < B)) return l - v >= B - l ? x : z;
                                x = y + 1
                            }
                        }
                        return p[y]
                    }
                };
                a.binaryIndexOf = function(p, l, n) {
                    const u = p.length;
                    let y = 0;
                    for (var x = u - 1; y < x;) {
                        const q = y + Math.floor((x - y) / 2);
                        l > p[q] ? y = q + 1 : x = q
                    }
                    x = p[y];
                    return n ? l >= p[u - 1] ? -1 : x === l ? y : y - 1 : x === l ? y : -1
                };
                a.constant = function(p, l) {
                    if (c) return Array(p).fill(l);
                    const n = Array(p);
                    for (let u = 0; u < p; u++) n[u] =
                        l;
                    return n
                };
                a.difference = function(p, l, n) {
                    let u, y;
                    n ? (u = l.filter(x => !p.some(q => n(q, x))), y = p.filter(x => !l.some(q => n(q, x)))) : (u = l.filter(x => !p.includes(x)), y = p.filter(x => !l.includes(x)));
                    return {
                        added: u,
                        removed: y
                    }
                };
                a.equals = function(p, l, n) {
                    if (k.isNone(p) && k.isNone(l)) return !0;
                    if (k.isNone(p) || k.isNone(l) || p.length !== l.length) return !1;
                    if (n)
                        for (let u = 0; u < p.length; u++) {
                            if (!n(p[u], l[u])) return !1
                        } else
                            for (n = 0; n < p.length; n++)
                                if (p[n] !== l[n]) return !1;
                    return !0
                };
                a.first = function(p) {
                    if (p) return 0 < p.length ? p[0] : void 0
                };
                a.flatten = function(p) {
                    return p.reduce((l, n) => l.concat(n || []), [])
                };
                a.indexOf = f;
                a.intersect = function(p, l, n) {
                    return p && l ? n ? p.filter(function(u) {
                        return -1 < l.findIndex(function(y) {
                            return n(u, y)
                        })
                    }) : p.filter(function(u) {
                        return -1 < l.indexOf(u)
                    }) : []
                };
                a.isArrayLike = function(p) {
                    return p && "number" === typeof p.length
                };
                a.last = function(p) {
                    if (p) {
                        var l = p.length;
                        return 0 < l ? p[l - 1] : void 0
                    }
                };
                a.max = r;
                a.min = function(p, l = t) {
                    return r(p, n => -l(n))
                };
                a.pickRandom = function(p, l, n) {
                    const u = p.length;
                    if (l >= u) return p.slice(0);
                    n = b(n);
                    const y = new Set,
                        x = [];
                    for (; x.length < l;) {
                        const q = Math.floor(n() * u);
                        y.has(q) || (y.add(q), x.push(p[q]))
                    }
                    return x
                };
                a.range = function(p, l) {
                    void 0 === l && (l = p, p = 0);
                    const n = Array(l - p);
                    for (let u = p; u < l; u++) n[u - p] = u;
                    return n
                };
                a.remove = function(p, l) {
                    const n = p.indexOf(l);
                    return -1 !== n ? (p.splice(n, 1), l) : null
                };
                a.removeUnordered = function(p, l, n, u) {
                    const y = null == n ? p.length : n;
                    u = f(p, l, y, u);
                    if (-1 !== u) return p[u] = p[y - 1], null == n && p.pop(), l
                };
                a.removeUnorderedMany = function(p, l, n = p.length, u = l.length, y, x) {
                    if (0 === u || 0 === n) return n;
                    d.clear();
                    for (let q = 0; q < u; ++q) d.add(l[q]);
                    y = y || e;
                    l = Math.max(0, y.last - 10);
                    for (u = l; u < n; ++u)
                        if (d.has(p[u]) && (x && x.push(p[u]), d.delete(p[u]), p[u] = p[n - 1], --n, --u, 0 === d.size || 0 === n)) return d.clear(), n;
                    for (u = 0; u < l; ++u)
                        if (d.has(p[u]) && (x && x.push(p[u]), d.delete(p[u]), p[u] = p[n - 1], --n, --u, 0 === d.size || 0 === n)) return d.clear(), n;
                    d.clear();
                    return n
                };
                a.shuffle = function(p, l) {
                    l = b(l);
                    for (let n = p.length - 1; 0 < n; n--) {
                        const u = Math.floor(l() * (n + 1)),
                            y = p[n];
                        p[n] = p[u];
                        p[u] = y
                    }
                    return p
                };
                a.splitIntoChunks = function(p, l) {
                    const n =
                        p.length;
                    if (0 === n) return [];
                    const u = [];
                    for (let y = 0; y < n; y += l) u.push(p.slice(y, y + l));
                    return u
                };
                a.unique = function(p, l) {
                    return l ? p.filter((n, u, y) => y.findIndex(l.bind(null, n)) === u) : p.filter((n, u, y) => y.indexOf(n) === u)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/RandomLCG": function() {
            define(["../chunks/_rollupPluginBabelHelpers"], function(a) {
                let k = function() {
                    function w(r = 1) {
                        this._seed = r
                    }
                    var t = w.prototype;
                    t.getInt = function() {
                        return this._seed = (w._a * this._seed + w._c) % w._m
                    };
                    t.getFloat = function() {
                        return this.getInt() /
                            (w._m - 1)
                    };
                    t.getIntRange = function(r, f) {
                        return Math.round(this.getFloatRange(r, f))
                    };
                    t.getFloatRange = function(r, f) {
                        f -= r;
                        const b = this.getInt() / w._m;
                        return r + b * f
                    };
                    a._createClass(w, [{
                        key: "seed",
                        set: function(r) {
                            this._seed = null == r ? Math.random() * w._m : r
                        }
                    }]);
                    return w
                }();
                k._m = 2147483647;
                k._a = 48271;
                k._c = 0;
                return k
            })
        },
        "esri/core/HeapSort": function() {
            define(function() {
                var a;
                (function(k) {
                    const w = (r, f, b, c) => {
                            let g = f;
                            const e = b >>> 1,
                                d = r[g - 1];
                            for (; f <= e;) {
                                f = g << 1;
                                f < b && 0 > c(r[f - 1], r[f]) && ++f;
                                const h = r[f - 1];
                                if (0 >= c(h, d)) break;
                                r[g - 1] = h;
                                g = f
                            }
                            r[g - 1] = d
                        },
                        t = (r, f) => r < f ? -1 : r > f ? 1 : 0;
                    k.sort = function(r, f, b, c) {
                        void 0 === f && (f = 0);
                        void 0 === b && (b = r.length);
                        void 0 === c && (c = t);
                        for (var g = b >>> 1; g > f; g--) w(r, g, b, c);
                        g = f + 1;
                        for (--b; b > f; b--) {
                            const e = r[f];
                            r[f] = r[b];
                            r[b] = e;
                            w(r, g, b, c)
                        }
                    };
                    k.iterableSort = function*(r, f, b, c) {
                        void 0 === f && (f = 0);
                        void 0 === b && (b = r.length);
                        void 0 === c && (c = t);
                        for (var g = b >>> 1; g > f; g--) w(r, g, b, c), yield;
                        g = f + 1;
                        for (--b; b > f; b--) {
                            const e = r[f];
                            r[f] = r[b];
                            r[b] = e;
                            w(r, g, b, c);
                            yield
                        }
                    }
                })(a || (a = {}));
                return a
            })
        },
        "esri/core/Accessor": function() {
            define("../chunks/_rollupPluginBabelHelpers ./Logger ./accessorSupport/get ./accessorSupport/metadata ./accessorSupport/set ./accessorSupport/decorators/property ./deprecate ./accessorSupport/decorators/subclass ./accessorSupport/Properties ./accessorSupport/watch".split(" "),
                function(a, k, w, t, r, f, b, c, g, e) {
                    function d(h) {
                        if (null == h) return {
                            value: h
                        };
                        if (Array.isArray(h)) return {
                            type: [h[0]],
                            value: null
                        };
                        switch (typeof h) {
                            case "object":
                                return h.constructor && h.constructor.__accessorMetadata__ || h instanceof Date ? {
                                    type: h.constructor,
                                    value: h
                                } : h;
                            case "boolean":
                                return {
                                    type: Boolean,
                                    value: h
                                };
                            case "string":
                                return {
                                    type: String,
                                    value: h
                                };
                            case "number":
                                return {
                                    type: Number,
                                    value: h
                                };
                            case "function":
                                return {
                                    type: h,
                                    value: null
                                }
                        }
                    }
                    return function() {
                        function h(...l) {
                            if (this.constructor === h) throw Error("[accessor] cannot instantiate Accessor. This can be fixed by creating a subclass of Accessor");
                            Object.defineProperty(this, "__accessor__", {
                                enumerable: !1,
                                value: new g(this)
                            });
                            0 < l.length && this.normalizeCtorArgs && (this.__accessor__.ctorArgs = this.normalizeCtorArgs.apply(this, l))
                        }
                        h.createSubclass = function(l = {}) {
                            if (Array.isArray(l)) throw Error("Multi-inheritance unsupported since 4.16");
                            const {
                                properties: n,
                                declaredClass: u,
                                constructor: y
                            } = l;
                            delete l.declaredClass;
                            delete l.properties;
                            delete l.constructor;
                            const x = this;
                            let q = function(B) {
                                function z(...v) {
                                    var A = B.call(this, ...v) || this;
                                    A.inherited = null;
                                    y &&
                                        y.apply(a._assertThisInitialized(A), v);
                                    return A
                                }
                                a._inheritsLoose(z, B);
                                return z
                            }(x);
                            t.getOwnClassMetadata(q.prototype);
                            for (const B in l) {
                                const z = l[B];
                                q.prototype[B] = "function" === typeof z ? function(...v) {
                                    const A = this.inherited;
                                    this.inherited = function(...E) {
                                        if (x.prototype[B]) return x.prototype[B].apply(this, E)
                                    };
                                    let m = void 0;
                                    try {
                                        m = z.apply(this, v)
                                    } catch (E) {
                                        throw this.inherited = A, E;
                                    }
                                    this.inherited = A;
                                    return m
                                } : l[B]
                            }
                            for (const B in n) l = d(n[B]), f.property(l)(q.prototype, B);
                            return c.subclass(u)(q)
                        };
                        var p = h.prototype;
                        p.postscript = function(l) {
                            const n = this.__accessor__;
                            l = n.ctorArgs || l;
                            n.initialize();
                            l && (this.set(l), n.ctorArgs = null);
                            n.constructed();
                            this.initialize()
                        };
                        p.initialize = function() {};
                        p.destroy = function() {
                            this.destroyed || (e.removeTarget(this), this.__accessor__.destroy())
                        };
                        p.commitProperty = function(l) {
                            this.get(l)
                        };
                        p.get = function(l) {
                            return w.get(this, l)
                        };
                        p.hasOwnProperty = function(l) {
                            return this.__accessor__ ? this.__accessor__.has(l) : Object.prototype.hasOwnProperty.call(this, l)
                        };
                        p.isInstanceOf = function(l) {
                            b.deprecatedFunction(k.getLogger(this.declaredClass),
                                "isInstanceOf", {
                                    replacement: "Use instanceof directly",
                                    version: "4.16"
                                });
                            return this instanceof l
                        };
                        p.keys = function() {
                            return this.__accessor__ ? this.__accessor__.keys() : []
                        };
                        p.set = function(l, n) {
                            r.set(this, l, n);
                            return this
                        };
                        p.watch = function(l, n, u) {
                            return e.watch(this, l, n, u)
                        };
                        p._clearOverride = function(l) {
                            return this.__accessor__.clearOverride(l)
                        };
                        p._override = function(l, n) {
                            return this.__accessor__.override(l, n)
                        };
                        p._isOverridden = function(l) {
                            return this.__accessor__.isOverridden(l)
                        };
                        p.notifyChange = function(l) {
                            this.__accessor__.propertyInvalidated(l)
                        };
                        p._get = function(l) {
                            return this.__accessor__.internalGet(l)
                        };
                        p._set = function(l, n) {
                            this.__accessor__.internalSet(l, n);
                            return this
                        };
                        a._createClass(h, [{
                            key: "initialized",
                            get: function() {
                                return this.__accessor__ && this.__accessor__.initialized || !1
                            }
                        }, {
                            key: "constructed",
                            get: function() {
                                return this.__accessor__ && 2 === this.__accessor__.lifecycle || !1
                            }
                        }, {
                            key: "destroyed",
                            get: function() {
                                return this.__accessor__ && this.__accessor__.destroyed || !1
                            }
                        }]);
                        return h
                    }()
                })
        },
        "esri/core/deprecate": function() {
            define(["exports",
                "./has"
            ], function(a, k) {
                function w(f, b, c = !1) {
                    c && r.has(b) || (c && r.add(b), f.warn(`\ud83d\uded1 DEPRECATED - ${b}`))
                }

                function t(f, b, c = {}) {
                    if (k("esri-deprecation-warnings")) {
                        const {
                            replacement: g,
                            version: e,
                            see: d,
                            warnOnce: h
                        } = c;
                        g && (b += `\n\t\ud83d\udee0\ufe0f Replacement: ${g}`);
                        e && (b += `\n\t\u2699\ufe0f Version: ${e}`);
                        d && (b += `\n\t\ud83d\udd17 See ${d} for more details.`);
                        w(f, b, h)
                    }
                }
                const r = new Set;
                a.deprecated = t;
                a.deprecatedFunction = function(f, b, c = {}) {
                    if (k("esri-deprecation-warnings")) {
                        const {
                            moduleName: g
                        } =
                        c;
                        t(f, `Function: ${(g?g+"::":"")+b+"()"}`, c)
                    }
                };
                a.deprecatedModule = function(f, b, c = {}) {
                    k("esri-deprecation-warnings") && t(f, `Module: ${b}`, c)
                };
                a.deprecatedProperty = function(f, b, c = {}) {
                    if (k("esri-deprecation-warnings")) {
                        const {
                            moduleName: g
                        } = c;
                        t(f, `Property: ${(g?g+"::":"")+b}`, c)
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/Properties": function() {
            define("../../chunks/_rollupPluginBabelHelpers ../has ../lang ../Logger ./utils ./PropertyOrigin ../ObjectPool ./Property ./Store ./tracking".split(" "),
                function(a, k, w, t, r, f, b, c, g, e) {
                    t.getLogger("esri.core.accessorSupport.Properties");
                    k = function() {
                        function h(l) {
                            this.host = l;
                            this.properties = new Map;
                            this.ctorArgs = null;
                            this.destroyed = !1;
                            this.lifecycle = 0;
                            this.store = new g.Store;
                            this._origin = 6;
                            const n = this.host.constructor.__accessorMetadata__,
                                u = n.properties;
                            for (const y in u) {
                                const x = new c.Property(l, y, u[y]);
                                this.properties.set(y, x)
                            }
                            this.metadatas = u;
                            this._autoDestroy = n.autoDestroy
                        }
                        var p = h.prototype;
                        p.initialize = function() {
                            this.lifecycle = 1
                        };
                        p.constructed =
                            function() {
                                this.lifecycle = 2
                            };
                        p.destroy = function() {
                            this.destroyed = !0;
                            if (this._autoDestroy)
                                for (const [n, u] of this.properties) {
                                    var l = this.internalGet(n);
                                    l && l && "function" === typeof l.destroy && (l.destroy(), ~u.flags & 8 && this._internalSet(u, null));
                                    u.destroy()
                                } else
                                    for ([, l] of this.properties) l.destroy()
                        };
                        p.get = function(l) {
                            return this.properties.get(l).metadata.get ? this.getterComputed(l) : this.getterStatic(l)
                        };
                        p.getterStatic = function(l) {
                            const n = this.properties.get(l);
                            if (void 0 !== n) return e.trackAccess(n), this.store.has(l) ?
                                this.store.get(l) : n.metadata.value
                        };
                        p.getterComputed = function(l) {
                            const n = this.properties.get(l);
                            e.trackAccess(n);
                            const u = this.store;
                            var y = n.flags;
                            const x = this.store.get(l);
                            if (y & 4 || u.has(l) && (~y & 1 || c.isInvalidating())) return x;
                            n.flags |= 4;
                            const q = n.metadata.get;
                            y & 64 ? y = e.runTracked(n, q, this.host) : (e.trackExplicitDependencies(this.host, n), y = q.call(this.host));
                            u.set(l, y, 1);
                            l = this.store.get(l);
                            l === x ? n.flags &= -2 : n.commit();
                            n.flags &= -5;
                            return l
                        };
                        p.originOf = function(l) {
                            const n = this.store.originOf(l);
                            return void 0 ===
                                n && (l = this.properties.get(l), void 0 !== l && l.flags & 16) ? "defaults" : f.idToName(n)
                        };
                        p.has = function(l) {
                            return this.properties.has(l) ? this.store.has(l) : !1
                        };
                        p.keys = function() {
                            return [...this.properties.keys()]
                        };
                        p.internalGet = function(l) {
                            const n = this.properties.get(l);
                            if (void 0 !== n) return this.store.has(l) ? this.store.get(l) : n.metadata.value
                        };
                        p.internalSet = function(l, n) {
                            l = this.properties.get(l);
                            void 0 !== l && this._internalSet(l, n)
                        };
                        p.getDependsInfo = function(l, n, u) {
                            const y = this.properties.get(n);
                            if (void 0 === y) return "";
                            const x = new Set;
                            var q = e.runTracked({
                                    onObservableAccessed: z => x.add(z),
                                    onTrackingEnd: () => {}
                                }, () => {
                                    var z;
                                    return null == (z = y.metadata.get) ? void 0 : z.call(l)
                                }),
                                B = l.declaredClass.split(".").pop();
                            n = `${u}${B}.${n}: ${q}\n`;
                            if (0 === x.size) return n;
                            u += "  ";
                            for (const z of x) {
                                if (!(z instanceof c.Property)) continue;
                                q = z.host;
                                B = z.propertyName;
                                const v = r.getProperties(q);
                                n = v ? n + v.getDependsInfo(q, B, u) : n + `${u}${B}: undefined\n`
                            }
                            return n
                        };
                        p.setAtOrigin = function(l, n, u) {
                            l = this.properties.get(l);
                            if (void 0 !== l) return this._setAtOrigin(l,
                                n, u)
                        };
                        p.isOverridden = function(l) {
                            l = this.properties.get(l);
                            return void 0 !== l && !!(l.flags & 2)
                        };
                        p.clearOverride = function(l) {
                            l = this.properties.get(l);
                            void 0 !== l && l.flags & 2 && (l.flags &= -3, l.invalidate())
                        };
                        p.override = function(l, n) {
                            l = this.properties.get(l);
                            if (!(void 0 === l || null == n && l.flags & 8)) {
                                var u = l.metadata.cast;
                                if (u) {
                                    n = this._cast(u, n);
                                    const {
                                        valid: y,
                                        value: x
                                    } = n;
                                    d.release(n);
                                    if (!y) return;
                                    n = x
                                }
                                l.flags |= 2;
                                this._internalSet(l, n)
                            }
                        };
                        p.set = function(l, n) {
                            l = this.properties.get(l);
                            if (!(void 0 === l || null == n && l.flags &
                                    8)) {
                                var u = l.metadata.cast;
                                if (u) {
                                    n = this._cast(u, n);
                                    const {
                                        valid: y,
                                        value: x
                                    } = n;
                                    d.release(n);
                                    if (!y) return;
                                    n = x
                                }(u = l.metadata.set) ? u.call(this.host, n): this._internalSet(l, n)
                            }
                        };
                        p.setDefaultOrigin = function(l) {
                            this._origin = f.nameToId(l)
                        };
                        p.getDefaultOrigin = function() {
                            return f.idToName(this._origin)
                        };
                        p.propertyInvalidated = function(l) {
                            l = this.properties.get(l);
                            void 0 !== l && l.invalidate()
                        };
                        p.propertyCommitted = function(l) {
                            l = this.properties.get(l);
                            void 0 !== l && l.commit()
                        };
                        p._internalSet = function(l, n) {
                            this._setAtOrigin(l,
                                n, 0 !== this.lifecycle ? this._origin : 0)
                        };
                        p._setAtOrigin = function(l, n, u) {
                            const y = this.store,
                                x = l.propertyName;
                            y.has(x, u) && w.equals(n, y.get(x)) && ~l.flags & 2 && u === y.originOf(x) || (c.startInvalidating(), l.invalidate(), c.stopInvalidating(), y.set(x, n, u), l.commit(), e.initializeDependencyTracking(this.host, l))
                        };
                        p._cast = function(l, n) {
                            const u = d.acquire();
                            u.valid = !0;
                            u.value = n;
                            l && (u.value = l.call(this.host, n, u));
                            return u
                        };
                        a._createClass(h, [{
                            key: "initialized",
                            get: function() {
                                return 0 !== this.lifecycle
                            }
                        }]);
                        return h
                    }();
                    t = function() {
                        function h() {
                            this.value = null;
                            this.valid = !0
                        }
                        var p = h.prototype;
                        p.acquire = function() {
                            this.valid = !0
                        };
                        p.release = function() {
                            this.value = null
                        };
                        return h
                    }();
                    const d = new b(t);
                    return k
                })
        },
        "esri/core/accessorSupport/PropertyOrigin": function() {
            define(["exports", "../maybe"], function(a, k) {
                function w(r) {
                    switch (r) {
                        case "defaults":
                            return 0;
                        case "service":
                            return 2;
                        case "portal-item":
                            return 3;
                        case "web-scene":
                            return 4;
                        case "web-map":
                            return 5;
                        case "user":
                            return 6
                    }
                }

                function t(r) {
                    switch (r) {
                        case 0:
                            return "defaults";
                        case 2:
                            return "service";
                        case 3:
                            return "portal-item";
                        case 4:
                            return "web-scene";
                        case 5:
                            return "web-map";
                        case 6:
                            return "user"
                    }
                    return k.assumeNonNull(void 0)
                }
                a.OriginIdNum = 7;
                a.idToName = t;
                a.idToReadableName = function(r) {
                    return t(r)
                };
                a.idToWritableName = function(r) {
                    return t(r)
                };
                a.nameToId = w;
                a.readableNameToId = function(r) {
                    return w(r)
                };
                a.writableNameToId = function(r) {
                    return w(r)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/ObjectPool": function() {
            define(function() {
                let a = function() {
                    function k(t,
                        r, f, b = 1, c = 0) {
                        this.ctor = t;
                        this.acquireFunction = r;
                        this.releaseFunction = f;
                        this.allocationSize = b;
                        this._pool = Array(c);
                        this._initialSize = c;
                        if (this.ctor)
                            for (t = 0; t < c; t++) this._pool[t] = new this.ctor;
                        this.allocationSize = Math.max(b, 1)
                    }
                    var w = k.prototype;
                    w.destroy = function() {
                        this.prune(0)
                    };
                    w.acquire = function(...t) {
                        if (k.test.disabled) var r = new this.ctor;
                        else {
                            if (0 === this._pool.length) {
                                r = this.allocationSize;
                                for (let f = 0; f < r; f++) this._pool[f] = new this.ctor
                            }
                            r = this._pool.pop()
                        }
                        this.acquireFunction ? this.acquireFunction(r,
                            ...t) : r && r.acquire && "function" === typeof r.acquire && r.acquire(...t);
                        return r
                    };
                    w.release = function(t) {
                        t && !k.test.disabled && (this.releaseFunction ? this.releaseFunction(t) : t && t.release && "function" === typeof t.release && t.release(), this._pool.push(t))
                    };
                    w.prune = function(t = this._initialSize) {
                        if (!(t >= this._pool.length)) {
                            for (let r = t; r < this._pool.length; ++r) this._dispose(this._pool[r]);
                            this._pool.length = t
                        }
                    };
                    w._dispose = function(t) {
                        t.dispose && "function" === typeof t.dispose && t.dispose()
                    };
                    return k
                }();
                a.test = {
                    disabled: !1
                };
                return a
            })
        },
        "esri/core/accessorSupport/Property": function() {
            define(["exports", "./tracking/ObservationHandle"], function(a, k) {
                let w = !1,
                    t = function() {
                        function r(b, c, g) {
                            this.host = b;
                            this.propertyName = c;
                            this.metadata = g;
                            this.flags = 1;
                            this._accessed = this._observers = null;
                            this._handles = [];
                            this.flags = 1 | (g.nonNullable ? 8 : 0) | (g.hasOwnProperty("value") ? 16 : 0) | (void 0 === g.get ? 32 : 0) | (void 0 === g.dependsOn ? 64 : 0)
                        }
                        var f = r.prototype;
                        f.destroy = function() {
                            this._accessed && (this._accessed.clear(), this._accessed = null);
                            this._observers &&
                                (this._observers.clear(), this._observers = null);
                            this._clearObservationHandles()
                        };
                        f.onObservableAccessed = function(b) {
                            b !== this && (null === this._accessed && (this._accessed = new Set), this._accessed.add(b))
                        };
                        f.onTrackingEnd = function() {
                            this._clearObservationHandles();
                            this.flags |= 32;
                            const b = this._accessed;
                            if (null !== b) {
                                var c = this._handles;
                                for (const g of b) c.push(g.observe(this));
                                b.clear()
                            }
                        };
                        f.observe = function(b) {
                            null === this._observers && (this._observers = new Set);
                            return new k.ObservationHandle(this._observers.add(b),
                                b)
                        };
                        f.notify = function() {
                            ~this.flags & 2 && (this.flags |= 1);
                            this._notifyObservers()
                        };
                        f.invalidate = function() {
                            this.notify()
                        };
                        f.commit = function() {
                            this.flags &= -2;
                            this._notifyObservers()
                        };
                        f._notifyObservers = function() {
                            if (null !== this._observers) {
                                var b = this._observers.size,
                                    c = Array(b);
                                --b;
                                for (var g of this._observers) c[b--] = g;
                                for (g = !w; c.length;)
                                    if (b = c.pop(), void 0 !== b.flags) {
                                        if (~b.flags & 2 && (b.flags |= 1), null !== b._observers)
                                            for (const e of b._observers) c.push(e)
                                    } else g && b.notify()
                            }
                        };
                        f._clearObservationHandles = function() {
                            for (const b of this._handles) b.remove();
                            this._handles.length = 0
                        };
                        return r
                    }();
                a.Property = t;
                a.isInvalidating = function() {
                    return w
                };
                a.startInvalidating = function() {
                    w = !0
                };
                a.stopInvalidating = function() {
                    w = !1
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/tracking/ObservationHandle": function() {
            define(["exports"], function(a) {
                let k = function() {
                    function w(t, r) {
                        this._observers = t;
                        this._observer = r
                    }
                    w.prototype.remove = function() {
                        this._observers.delete(this._observer)
                    };
                    return w
                }();
                a.ObservationHandle = k;
                Object.defineProperty(a,
                    "__esModule", {
                        value: !0
                    })
            })
        },
        "esri/core/accessorSupport/Store": function() {
            define(["exports", "../lang"], function(a, k) {
                let w = function() {
                    function t() {
                        this._values = new Map
                    }
                    var r = t.prototype;
                    r.clone = function(f) {
                        const b = new t;
                        this._values.forEach((c, g) => {
                            f && f.has(g) || b.set(g, k.clone(c))
                        });
                        return b
                    };
                    r.get = function(f) {
                        return this._values.get(f)
                    };
                    r.originOf = function() {
                        return 6
                    };
                    r.keys = function() {
                        return [...this._values.keys()]
                    };
                    r.set = function(f, b) {
                        this._values.set(f, b)
                    };
                    r.delete = function(f) {
                        this._values.delete(f)
                    };
                    r.has = function(f) {
                        return this._values.has(f)
                    };
                    r.forEach = function(f) {
                        this._values.forEach(f)
                    };
                    return t
                }();
                a.Store = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/tracking": function() {
            define(["exports", "../has", "../Logger", "./utils"], function(a, k, w, t) {
                function r(y) {
                    if (void 0 !== h) h.onObservableAccessed(y)
                }

                function f(y, x, q) {
                    const B = l;
                    l = !0;
                    h = y;
                    d.push(y);
                    y = null;
                    try {
                        y = x.call(q)
                    } catch (z) {
                        n && p.error(z)
                    }
                    b();
                    l = B;
                    return y
                }

                function b() {
                    const y = d.pop();
                    h = 0 < d.length ? d[d.length - 1] :
                        void 0;
                    if (void 0 !== y) y.onTrackingEnd()
                }

                function c(y, x) {
                    if (!(x.flags & 32)) {
                        var q = n;
                        n = !1;
                        x.flags & 64 ? f(x, x.metadata.get, y) : g(y, x);
                        n = q
                    }
                }

                function g(y, x) {
                    x.flags & 128 || (x.flags |= 128, f(x, () => {
                        var q = x.metadata.dependsOn || u;
                        for (const B of q)
                            if ("string" === typeof B && -1 === B.indexOf(".")) e(y, B, !1);
                            else {
                                q = t.pathToArray(B);
                                for (let z = 0, v = y; z < q.length && null != v && "object" === typeof v; ++z) v = e(v, q[z], z !== q.length - 1)
                            }
                    }), x.flags &= -129)
                }

                function e(y, x, q) {
                    x = "?" === x[x.length - 1] ? x.slice(0, -1) : x;
                    if (null != y.getItemAt || Array.isArray(y)) {
                        var B =
                            parseInt(x, 10);
                        if (!isNaN(B)) return Array.isArray(y) ? y[B] : y.getItemAt(B)
                    }
                    B = t.getProperties(y);
                    if (B = null == B ? void 0 : B.properties.get(x)) r(B), c(y, B);
                    return q ? y[x] : void 0
                }
                let d = [],
                    h = void 0;
                const p = w.getLogger("esri.core.Accessor");
                let l = !1,
                    n = !1;
                const u = [];
                a.initializeDependencyTracking = c;
                a.resetGlobalTarget = function() {
                    d = []
                };
                a.runTracked = function(y, x, q) {
                    if (l) return f(y, x, q);
                    h = y;
                    d.push(y);
                    y = x.call(q);
                    b();
                    return y
                };
                a.runTrackedNoThrow = f;
                a.trackAccess = r;
                a.trackExplicitDependencies = g;
                Object.defineProperty(a,
                    "__esModule", {
                        value: !0
                    })
            })
        },
        "esri/core/accessorSupport/watch": function() {
            define("exports ../lang ./utils ./get ../ArrayPool ../ReentrantObjectPool ../scheduling ./trackingUtils".split(" "), function(a, k, w, t, r, f, b, c) {
                function g(z) {
                    y.has(z) ? x.splice(x.indexOf(z), 1) : y.add(z);
                    x.push(z);
                    q || (q = b.schedule(d))
                }

                function e(z) {
                    if (!z.removed) {
                        var {
                            callback: v,
                            path: A,
                            oldValue: m,
                            target: E
                        } = z, C = z.getValue();
                        k.equals(m, C) || (z.oldValue = C, v.call(E, C, m, A, E))
                    }
                }

                function d() {
                    let z = 10;
                    for (; q && z--;) {
                        q = null;
                        const A = x;
                        x = u.acquire();
                        y.clear();
                        const m = u.acquire();
                        for (const E of A) {
                            var v = E.uid;
                            e(E);
                            v === E.uid && E.removed && m.push(E)
                        }
                        for (v = 0; v < x.length; v++) {
                            const E = x[v];
                            E.removed && (m.push(E), y.delete(E), x.splice(v, 1), --v)
                        }
                        for (v = 0; v < m.length; v++) n.pool.release(m[v]);
                        u.release(A);
                        u.release(m);
                        B.forEach(E => E())
                    }
                }

                function h(z, v, A) {
                    let m = w.parse(z, v, A, (E, C, G) => {
                        let F, D, H = c.reactionAsync(() => t.valueOf(E, C), (I, Q) => {
                            E.__accessor__.destroyed || F && F.uid !== D ? m.remove() : (F || (F = n.pool.acquire(E, C, I, G, Q), D = F.uid), g(F))
                        });
                        return {
                            remove: w.once(function() {
                                H.remove();
                                F && (F.uid !== D || F.removed || (F.removed = !0, g(F)), F = null);
                                m = H = null
                            })
                        }
                    });
                    return m
                }

                function p(z, v, A) {
                    const m = w.parse(z, v, A, (E, C, G) => {
                        let F = !1;
                        return c.reaction(() => t.valueOf(E, C), (D, H) => {
                            E.__accessor__.destroyed ? m.remove() : F || (F = !0, k.equals(H, D) || G.call(E, D, H, C, E), F = !1)
                        })
                    });
                    return m
                }

                function l(z, v, A, m = !1) {
                    return !z.__accessor__ || z.__accessor__.destroyed ? {
                        remove() {}
                    } : m ? p(z, v, A) : h(z, v, A)
                }
                let n = function() {
                    function z() {
                        this.uid = 0;
                        this.getValue = this.callback = this.oldValue = this.path = this.target = null;
                        this.removed = !1;
                        this.propertyPath = null
                    }
                    var v = z.prototype;
                    v.acquire = function(A, m, E, C, G) {
                        this.target = A;
                        this.path = m;
                        this.oldValue = E;
                        this.callback = C;
                        this.getValue = G;
                        this.propertyPath = w.pathToStringOrArray(m);
                        this.uid = ++z.uid;
                        this.removed = !1
                    };
                    v.release = function() {
                        this.target = this.path = this.propertyPath = this.callback = this.oldValue = null;
                        this.uid = ++z.uid;
                        this.removed = !0
                    };
                    return z
                }();
                n.pool = new f.ReentrantObjectPool(n);
                n.uid = 0;
                const u = new r,
                    y = new Set;
                let x = u.acquire(),
                    q;
                const B = new Set;
                a.afterDispatch = function(z) {
                    B.add(z);
                    return {
                        remove() {
                            B.delete(z)
                        }
                    }
                };
                a.default = l;
                a.dispatch = d;
                a.dispatchTarget = function(z) {
                    const v = u.copy(x);
                    for (let A = 0; A < v.length; A++) {
                        const m = v[A];
                        m.target === z && (e(m), y.delete(m), x.splice(x.indexOf(m), 1))
                    }
                };
                a.isValueInUse = function(z) {
                    return x.some(v => v.oldValue === z)
                };
                a.removeTarget = function(z) {
                    for (let v = 0; v < x.length; v++) {
                        const A = x[v];
                        A.target === z && (A.removed = !0)
                    }
                };
                a.watch = l;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/ArrayPool": function() {
            define(["./ObjectPool"], function(a) {
                function k(f) {
                    f.length =
                        0
                }
                const w = Array.prototype.splice;
                let t = function() {
                    function f(c = 50, g = 50) {
                        this._pool = new a(Array, void 0, k, g, c)
                    }
                    var b = f.prototype;
                    b.acquire = function() {
                        return this._pool.acquire()
                    };
                    b.copy = function(c) {
                        const g = this.acquire();
                        c.unshift(0, 0);
                        w.apply(g, c);
                        c.splice(0, 2);
                        return g
                    };
                    b.release = function(c) {
                        this._pool.release(c)
                    };
                    b.prune = function() {
                        this._pool.prune(0)
                    };
                    f.acquire = function() {
                        return r.acquire()
                    };
                    f.copy = function(c) {
                        return r.copy(c)
                    };
                    f.release = function(c) {
                        return r.release(c)
                    };
                    f.prune = function() {
                        r.prune()
                    };
                    return f
                }();
                const r = new t(100);
                return t
            })
        },
        "esri/core/ReentrantObjectPool": function() {
            define(["exports", "../chunks/_rollupPluginBabelHelpers", "./maybe", "./ObjectPool"], function(a, k, w, t) {
                t = function(r) {
                    function f() {
                        var c = r.apply(this, arguments) || this;
                        c._set = new Set;
                        return c
                    }
                    k._inheritsLoose(f, r);
                    var b = f.prototype;
                    b.destroy = function() {
                        r.prototype.destroy.call(this);
                        this._set = w.nullifyNonnullableForDispose(this._set)
                    };
                    b.acquire = function(...c) {
                        c = r.prototype.acquire.call(this, ...c);
                        this._set.delete(c);
                        return c
                    };
                    b.release = function(c) {
                        c && !this._set.has(c) && (r.prototype.release.call(this, c), this._set.add(c))
                    };
                    b._dispose = function(c) {
                        this._set.delete(c);
                        r.prototype._dispose.call(this, c)
                    };
                    return f
                }(t);
                a.ReentrantObjectPool = t;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/scheduling": function() {
            define("exports ./maybe ./nextTick ./PerformanceSampler ./PooledArray ./promiseUtils".split(" "), function(a, k, w, t, r, f) {
                function b() {
                    const m = performance.now();
                    B = null;
                    B = 0 < y.length ? requestAnimationFrame(b) :
                        null;
                    q.executeFrameTasks(m)
                }

                function c() {
                    y.forAll(m => {
                        m.removed && z.push(m)
                    });
                    y.removeUnorderedMany(z.data, z.length);
                    z.clear()
                }

                function g() {
                    for (; u.length;) {
                        const m = k.assumeNonNull(u.shift());
                        m.isActive && m.callback()
                    }
                    q.willDispatch = !1
                }
                let e = function(m) {
                        this.phases = m;
                        this.paused = !1;
                        this.ticks = -1;
                        this.removed = !1
                    },
                    d = function() {
                        function m(E) {
                            this.callback = E;
                            this.isActive = !0
                        }
                        m.prototype.remove = function() {
                            this.isActive = !1
                        };
                        return m
                    }(),
                    h = 0,
                    p = 0;
                const l = {
                        time: 0,
                        deltaTime: 0,
                        elapsedFrameTime: 0,
                        frameDuration: 0
                    },
                    n = ["prepare", "preRender", "render", "postRender", "update"],
                    u = [],
                    y = new r;
                let x = function() {
                    function m(C) {
                        this._task = C
                    }
                    var E = m.prototype;
                    E.remove = function() {
                        this._task.removed = !0
                    };
                    E.pause = function() {
                        this._task.paused = !0
                    };
                    E.resume = function() {
                        this._task.paused = !1
                    };
                    return m
                }();
                const q = {
                    frameTasks: y,
                    willDispatch: !1,
                    clearFrameTasks: function(m = !1) {
                        y.forAll(E => {
                            E.removed = !0
                        });
                        m && c()
                    },
                    dispatch: g,
                    executeFrameTasks: function(m) {
                        const E = m - h;
                        h = m;
                        const C = 0 < p ? p : 1E3 / 60,
                            G = Math.max(0, E - C);
                        for (let F = 0; F < n.length; F++) {
                            const D =
                                performance.now(),
                                H = n[F];
                            y.forAll(I => {
                                var Q;
                                I.paused || I.removed || (0 === F && I.ticks++, I.phases[H] && (l.time = m, l.deltaTime = 0 === I.ticks ? 0 : E, l.elapsedFrameTime = performance.now() - m, l.frameDuration = C - G, null == (Q = I.phases[H]) ? void 0 : Q.call(I, l)))
                            });
                            v[F].record(performance.now() - D)
                        }
                        c();
                        A.record(performance.now() - m)
                    }
                };
                let B = null;
                const z = new r,
                    v = n.map(m => new t(m)),
                    A = new t("total");
                a.FrameTaskHandle = x;
                a.addFrameTask = function(m) {
                    m = new e(m);
                    y.push(m);
                    null == B && (h = performance.now(), B = requestAnimationFrame(b));
                    return new x(m)
                };
                a.debug = q;
                a.performanceInfo = v;
                a.performanceTotal = A;
                a.schedule = function(m) {
                    m = new d(m);
                    u.push(m);
                    q.willDispatch || (q.willDispatch = !0, w(g));
                    return m
                };
                a.setFrameDuration = function(m) {
                    p = Math.max(0, m)
                };
                a.waitTicks = function(m = 1, E) {
                    const C = f.createResolver(),
                        G = () => {
                            f.isAborted(E) ? C.reject(f.createAbortError()) : 0 === m ? C() : (--m, w(() => G()))
                        };
                    G();
                    return C.promise
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/nextTick": function() {
            define(["./global"], function(a) {
                function k(f) {
                    t.push(f);
                    1 === t.length &&
                        w(() => {
                            for (var b of r) b();
                            b = t.slice();
                            t.length = 0;
                            for (const c of b) c()
                        })
                }
                const w = function() {
                        return a.queueMicrotask ? a.queueMicrotask : f => {
                            a.Promise.resolve().then(f)
                        }
                    }(),
                    t = [];
                let r = [];
                (function(f) {
                    f.before = function(b) {
                        r.push(b);
                        return {
                            remove() {
                                r = r.filter(c => c !== b)
                            }
                        }
                    }
                })(k || (k = {}));
                return k
            })
        },
        "esri/core/accessorSupport/trackingUtils": function() {
            define(["exports", "./tracking", "./tracking/SimpleTrackingTarget"], function(a, k, w) {
                function t(f, b, c = r) {
                    let g = new w.SimpleTrackingTarget(function() {
                            if (g && !d) {
                                var h =
                                    e;
                                g.clear();
                                d = !0;
                                e = k.runTracked(g, f);
                                d = !1;
                                b(e, h)
                            }
                        }),
                        e = null,
                        d = !1;
                    d = !0;
                    e = k.runTracked(g, f);
                    d = !1;
                    c.runImmediately && b(e, e);
                    return {
                        remove: function() {
                            g && (g.destroy(), e = g = null)
                        }
                    }
                }
                const r = {
                    runImmediately: !1
                };
                a.autorun = function(f) {
                    let b = new w.SimpleTrackingTarget(function() {
                            b && !c && (b.clear(), c = !0, k.runTracked(b, f), c = !1)
                        }),
                        c = !1;
                    c = !0;
                    k.runTracked(b, f);
                    c = !1;
                    return {
                        remove: function() {
                            b && (b.destroy(), b = null)
                        }
                    }
                };
                a.reaction = t;
                a.reactionAsync = function(f, b) {
                    function c() {
                        if (!g) return null;
                        g.clear();
                        return e = k.runTracked(g,
                            f)
                    }
                    let g = new w.SimpleTrackingTarget(function() {
                            b(e, c)
                        }),
                        e = null;
                    c();
                    return {
                        remove: function() {
                            g && (g.destroy(), g = null);
                            e = null
                        }
                    }
                };
                a.reactionInit = function(f, b) {
                    return t(f, b, {
                        runImmediately: !0
                    })
                };
                a.when = function(f, b) {
                    return t(() => f(), c => {
                        c && b()
                    }, {
                        runImmediately: !0
                    })
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/tracking/SimpleTrackingTarget": function() {
            define(["exports"], function(a) {
                let k = function() {
                    function w(r) {
                        this.notify = r;
                        this._accessed = new Set;
                        this._handles = []
                    }
                    var t =
                        w.prototype;
                    t.destroy = function() {
                        this._accessed.clear();
                        this.clear()
                    };
                    t.onObservableAccessed = function(r) {
                        this._accessed.add(r)
                    };
                    t.onTrackingEnd = function() {
                        for (const r of this._accessed) this._handles.push(r.observe(this));
                        this._accessed.clear()
                    };
                    t.clear = function() {
                        for (const r of this._handles) r.remove();
                        this._handles.length = 0
                    };
                    return w
                }();
                a.SimpleTrackingTarget = k;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/watchUtils": function() {
            define(["exports", "./lang", "./events", "./promiseUtils"],
                function(a, k, w, t) {
                    function r(n, u, y, x, q) {
                        q = n.watch(u, (z, v, A, m) => {
                            if (!y || y(z)) null == x ? void 0 : x.call(n, z, v, A, m)
                        }, q);
                        if (Array.isArray(u))
                            for (var B of u) {
                                const z = n.get(B);
                                y && y(z) && (null == x ? void 0 : x.call(n, z, z, u, n))
                            } else B = n.get(u), y && y(B) && (null == x ? void 0 : x.call(n, B, B, u, n));
                        return q
                    }

                    function f(n, u, y, x, q) {
                        function B() {
                            m && (m.remove(), m = null)
                        }
                        const z = "function" === typeof x ? x : null,
                            v = "object" === typeof x ? x : null;
                        "boolean" === typeof x && (q = x);
                        let A = !1,
                            m;
                        const E = t.createDeferred();
                        t.onAbort(v, () => {
                            B();
                            E.reject(t.createAbortError())
                        });
                        x = {
                            then: E.promise.then.bind(E.promise),
                            catch: E.promise.catch.bind(E.promise),
                            remove: B
                        };
                        Object.freeze(x);
                        m = r(n, u, y, (C, G, F, D) => {
                            A = !0;
                            B();
                            z && z.call(n, C, G, F, D);
                            E.resolve({
                                value: C,
                                oldValue: G,
                                propertyName: F,
                                target: D
                            })
                        }, q);
                        A && B();
                        return x
                    }

                    function b(n) {
                        return !!n
                    }

                    function c(n) {
                        return !n
                    }

                    function g(n) {
                        return !0 === n
                    }

                    function e(n) {
                        return !1 === n
                    }

                    function d(n) {
                        return void 0 !== n
                    }

                    function h(n) {
                        return void 0 === n
                    }

                    function p(n, u, y, x) {
                        var q = Array.isArray(u) ? u : -1 < u.indexOf(",") ? u.split(",") : [u];
                        u = n.watch(u, y, x);
                        for (const B of q) q =
                            B.trim().replace(l, "$1"), x = n.get(q), y.call(n, x, x, q, n);
                        return u
                    }
                    const l = /\?(\.|$)/g;
                    a.init = p;
                    a.on = function(n, u, y, x, q, B, z) {
                        function v(E) {
                            const C = A[E];
                            C && (B && B(C.target, E, n, y), C.handle.remove(), delete A[E])
                        }
                        const A = {},
                            m = p(n, u, (E, C, G) => {
                                v(G);
                                w.isEventTarget(E) && (A[G] = {
                                    handle: w.on(E, y, x),
                                    target: E
                                }, q && q(E, G, n, y))
                            }, z);
                        return {
                            remove() {
                                m.remove();
                                for (const E in A) v(E)
                            }
                        }
                    };
                    a.once = function(n, u, y, x) {
                        return f(n, u, null, y, x)
                    };
                    a.pausable = function(n, u, y, x) {
                        let q = !1;
                        const B = n.watch(u, (z, v, A, m) => {
                                q || y.call(n, z, v, A, m)
                            },
                            x);
                        return {
                            remove() {
                                B.remove()
                            },
                            pause() {
                                q = !0
                            },
                            resume() {
                                q = !1
                            }
                        }
                    };
                    a.watch = function(n, u, y, x) {
                        return n.watch(u, y, x)
                    };
                    a.when = function(n, u, y, x) {
                        return r(n, u, b, y, x)
                    };
                    a.whenDefined = function(n, u, y, x) {
                        return r(n, u, d, y, x)
                    };
                    a.whenDefinedOnce = function(n, u, y, x) {
                        return f(n, u, d, y, x)
                    };
                    a.whenEqual = function(n, u, y, x, q) {
                        return r(n, u, B => k.equals(y, B), x, q)
                    };
                    a.whenEqualOnce = function(n, u, y, x, q) {
                        return f(n, u, B => k.equals(y, B), x, q)
                    };
                    a.whenFalse = function(n, u, y, x) {
                        return r(n, u, e, y, x)
                    };
                    a.whenFalseOnce = function(n, u, y, x) {
                        return f(n,
                            u, e, y, x)
                    };
                    a.whenNot = function(n, u, y, x) {
                        return r(n, u, c, y, x)
                    };
                    a.whenNotOnce = function(n, u, y, x) {
                        return f(n, u, c, y, x)
                    };
                    a.whenOnce = function(n, u, y, x) {
                        return f(n, u, b, y, x)
                    };
                    a.whenTrue = function(n, u, y, x) {
                        return r(n, u, g, y, x)
                    };
                    a.whenTrueOnce = function(n, u, y, x) {
                        return f(n, u, g, y, x)
                    };
                    a.whenUndefined = function(n, u, y, x) {
                        return r(n, u, h, y, x)
                    };
                    a.whenUndefinedOnce = function(n, u, y, x) {
                        return f(n, u, h, y, x)
                    };
                    a.whenValidOnce = f;
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/layers/support/PromiseQueue": function() {
            define(["../../chunks/_rollupPluginBabelHelpers",
                "../../core/promiseUtils"
            ], function(a, k) {
                let w = function(t, r, f, b) {
                    this.resolve = t;
                    this.reject = r;
                    this.callback = f;
                    this.signal = b
                };
                return function() {
                    function t() {
                        this._tasks = []
                    }
                    var r = t.prototype;
                    r.push = function(f, b) {
                        return new Promise((c, g) => this._tasks.push(new w(c, g, f, b)))
                    };
                    r.unshift = function(f, b) {
                        return new Promise((c, g) => this._tasks.unshift(new w(c, g, f, b)))
                    };
                    r.process = function() {
                        if (0 === this._tasks.length) return !1;
                        const f = this._tasks.shift();
                        try {
                            k.throwIfAborted(f.signal);
                            const b = f.callback();
                            b && "object" ===
                                typeof b && "then" in b && "function" === typeof b.then ? b.then(f.resolve, f.reject) : f.resolve(b)
                        } catch (b) {
                            f.reject(b)
                        }
                        return !0
                    };
                    r.cancelAll = function() {
                        const f = k.createAbortError();
                        for (const b of this._tasks) b.reject(f);
                        this._tasks.length = 0
                    };
                    a._createClass(t, [{
                        key: "length",
                        get: function() {
                            return this._tasks.length
                        }
                    }]);
                    return t
                }()
            })
        },
        "esri/views/support/debugFlags": function() {
            define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/has ../../core/Logger ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/property ../../core/jsonMap ../../core/accessorSupport/decorators/subclass ../../core/urlUtils ../../core/uuid ../../portal/support/resourceExtension ../../core/Accessor".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h) {
                    w = function(p) {
                        function l() {
                            var n = p.apply(this, arguments) || this;
                            n.SCHEDULER_LOG_SLOW_TASKS = !1;
                            n.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = !1;
                            return n
                        }
                        a._inheritsLoose(l, p);
                        return l
                    }(h);
                    k.__decorate([f.property()], w.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0);
                    k.__decorate([f.property()], w.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0);
                    w = k.__decorate([c.subclass("esri.views.support.DebugFlags")], w);
                    return new w
                })
        },
        "esri/core/workers/registry": function() {
            define(["require",
                "exports"
            ], function(a, k) {
                function w(t) {
                    return Object.freeze({
                        __proto__: null,
                        "default": t
                    })
                }
                k.registry = {
                    geometryEngineWorker: () => new Promise(function(t, r) {
                        a(["../../geometry/geometryEngineWorker"], t, r)
                    }),
                    CSVSourceWorker: () => new Promise(function(t, r) {
                        a(["../../layers/graphics/sources/support/CSVSourceWorker"], t, r)
                    }),
                    EdgeProcessingWorker: () => new Promise(function(t, r) {
                        a(["../../views/3d/webgl-engine/lib/edgeRendering/EdgeProcessingWorker"], t, r)
                    }),
                    ElevationSamplerWorker: () => new Promise(function(t, r) {
                        a(["../../geometry/support/meshUtils/ElevationSamplerWorker"],
                            t, r)
                    }),
                    GeoJSONSourceWorker: () => new Promise(function(t, r) {
                        a(["../../layers/graphics/sources/geojson/GeoJSONSourceWorker"], function(f) {
                            t(w(f))
                        }, r)
                    }),
                    LercWorker: () => new Promise(function(t, r) {
                        a(["../../layers/support/LercWorker"], function(f) {
                            t(w(f))
                        }, r)
                    }),
                    MemorySourceWorker: () => new Promise(function(t, r) {
                        a(["../../layers/graphics/sources/support/MemorySourceWorker"], function(f) {
                            t(w(f))
                        }, r)
                    }),
                    PBFDecoderWorker: () => new Promise(function(t, r) {
                        a(["../../views/3d/support/PBFDecoderWorker"], function(f) {
                                t(w(f))
                            },
                            r)
                    }),
                    Pipeline: () => new Promise(function(t, r) {
                        a(["../../views/2d/layers/features/Pipeline"], t, r)
                    }),
                    PointCloudWorker: () => new Promise(function(t, r) {
                        a(["../../views/3d/layers/PointCloudWorker"], function(f) {
                            t(w(f))
                        }, r)
                    }),
                    RasterWorker: () => new Promise(function(t, r) {
                        a(["../../layers/support/RasterWorker"], function(f) {
                            t(w(f))
                        }, r)
                    }),
                    SceneLayerWorker: () => new Promise(function(t, r) {
                        a(["../../views/3d/layers/SceneLayerWorker"], t, r)
                    }),
                    WorkerTileHandler: () => new Promise(function(t, r) {
                        a(["../../views/2d/engine/vectorTiles/WorkerTileHandler"],
                            function(f) {
                                t(w(f))
                            }, r)
                    }),
                    FeatureServiceSnappingSourceWorker: () => new Promise(function(t, r) {
                        a(["../../views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker"], t, r)
                    })
                };
                Object.defineProperty(k, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/workers/utils": function() {
            define(["exports", "../has"], function(a, k) {
                function w(f) {
                    return f && "object" === typeof f && ("result" in f || "transferList" in f)
                }

                function t(f) {
                    if (!f || !f.length) return null;
                    if (k("esri-workers-arraybuffer-transfer")) return f;
                    f = f.filter(b => !(b instanceof ArrayBuffer || b && b.constructor && "ArrayBuffer" === b.constructor.name));
                    return f.length ? f : null
                }(function(f) {
                    f[f.HANDSHAKE = 0] = "HANDSHAKE";
                    f[f.OPEN = 1] = "OPEN";
                    f[f.OPENED = 2] = "OPENED";
                    f[f.RESPONSE = 3] = "RESPONSE";
                    f[f.INVOKE = 4] = "INVOKE";
                    f[f.ABORT = 5] = "ABORT";
                    f[f.CLOSE = 6] = "CLOSE";
                    f[f.OPEN_PORT = 7] = "OPEN_PORT";
                    f[f.ON = 8] = "ON"
                })(a.MessageType || (a.MessageType = {}));
                let r = 0;
                a.isTranferableResult = w;
                a.newJobId = function() {
                    return r++
                };
                a.postMessage = function(f, b, c, g) {
                    b.type === a.MessageType.OPEN_PORT ?
                        f.postMessage(b, [b.port]) : b.type !== a.MessageType.INVOKE && b.type !== a.MessageType.RESPONSE ? f.postMessage(b) : (w(c) ? (g = t(c.transferList), b.data = c.result) : (g = t(g), b.data = c), g ? f.postMessage(b, g) : f.postMessage(b))
                };
                a.receiveMessage = function(f) {
                    return f ? (f = f.data) ? "string" === typeof f ? JSON.parse(f) : f : null : null
                };
                a.toInvokeError = function(f) {
                    return f ? "string" === typeof f ? JSON.stringify({
                            name: "message",
                            message: f
                        }) : f.toJSON ? JSON.stringify(f) : JSON.stringify({
                            name: f.name,
                            message: f.message,
                            details: f.details || {
                                stack: f.stack
                            }
                        }) :
                        null
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/workers/request": function() {
            define(["exports", "../global", "../Error"], function(a, k, w) {
                let t;
                a.execute = function(r, f = {}) {
                    let b = f.responseType;
                    b ? "json" !== b && "text" !== b && "blob" !== b && "array-buffer" !== b && (b = "text") : b = "json";
                    const c = f && f.signal;
                    delete f.signal;
                    return k.invokeStaticMessage("request", {
                        url: r,
                        options: f
                    }, {
                        signal: c
                    }).then(g => {
                        var e = g.data;
                        let d, h, p;
                        if (e && ("json" === b || "text" === b || "blob" === b) && (d = new Blob([e]), "json" === b || "text" ===
                                b) && (t || (t = new FileReaderSync), h = t.readAsText(d), "json" === b)) {
                            try {
                                p = JSON.parse(h || null)
                            } catch (l) {
                                throw new w("request:server", l.message, { ...l,
                                    url: r,
                                    requestOptions: f
                                });
                            }
                            if (p.error) throw new w("request:server", p.error.message, { ...p.error,
                                url: r,
                                requestOptions: f
                            });
                        }
                        switch (b) {
                            case "json":
                                e = p;
                                break;
                            case "text":
                                e = h;
                                break;
                            case "blob":
                                e = d
                        }
                        return {
                            data: e,
                            requestOptions: f,
                            ssl: g.ssl,
                            url: r
                        }
                    })
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/WorkerTileHandler": function() {
            define(["../../../../core/promiseUtils",
                "./style/StyleRepository", "./WorkerTile"
            ], function(a, k, w) {
                return function() {
                    function t() {
                        this._spriteInfo = {};
                        this._glyphInfo = {}
                    }
                    var r = t.prototype;
                    r.reset = function() {
                        this._spriteInfo = {};
                        this._glyphInfo = {};
                        return Promise.resolve()
                    };
                    r.getLayers = function() {
                        var f;
                        return null == (f = this._styleRepository) ? void 0 : f.layers
                    };
                    r.createTileAndParse = async function(f, b) {
                        var {
                            key: c
                        } = f;
                        const g = {};
                        for (const e of Object.keys(f.sourceName2DataAndRefKey)) g[e] = f.sourceName2DataAndRefKey[e].refKey;
                        c = new w(c, g, this, this._styleRepository);
                        try {
                            return await c.parse(f, this._vectorTileLayerMaxBuffers, b)
                        } catch (e) {
                            c.setObsolete();
                            c.release();
                            if (!a.isAbortError(e)) throw e;
                            return null
                        }
                    };
                    r.updateStyle = function(f) {
                        if (f && 0 !== f.length && this._styleRepository) {
                            var b = this._styleRepository;
                            for (const c of f) switch (f = c.data, c.type) {
                                case 0:
                                    b.setPaintProperties(f.layerName, f.paint);
                                    break;
                                case 1:
                                    b.setLayoutProperties(f.layerName, f.layout);
                                    break;
                                case 3:
                                    b.deleteStyleLayer(f.layerName);
                                    break;
                                case 2:
                                    b.setStyleLayer(f.layer, f.index)
                            }
                        }
                    };
                    r.setStyle = function(f) {
                        this._styleRepository =
                            new k(f.style);
                        this._spriteInfo = {};
                        this._glyphInfo = {};
                        this._vectorTileLayerMaxBuffers = f.vectorTileLayerMaxBuffers
                    };
                    r.fetchSprites = function(f, b, c) {
                        const g = [],
                            e = this._spriteInfo;
                        f.forEach(d => {
                            void 0 === e[d] && g.push(d)
                        });
                        return 0 === g.length ? Promise.resolve() : b.invoke("getSprites", g, {
                            signal: c && c.signal
                        }).then(d => {
                            for (const h in d) e[h] = d[h]
                        })
                    };
                    r.getSpriteItems = function() {
                        return this._spriteInfo
                    };
                    r.fetchGlyphs = function(f, b, c, g, e) {
                        const d = [];
                        let h = this._glyphInfo[b];
                        h ? c.forEach(p => {
                            h[p] || d.push(p)
                        }) : (h = this._glyphInfo[b] = [], c.forEach(p => d.push(p)));
                        return 0 === d.length ? Promise.resolve() : g.invoke("getGlyphs", {
                            tileID: f,
                            font: b,
                            codePoints: d
                        }, e).then(p => {
                            for (let l = 0; l < p.length; l++) p[l] && (h[l] = p[l])
                        })
                    };
                    r.getGlyphItems = function(f) {
                        return this._glyphInfo[f]
                    };
                    return t
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/style/StyleRepository": function() {
            define(["./StyleLayer"], function(a) {
                return function() {
                    function k(t, r) {
                        this.backgroundBucketIds = [];
                        this._uidToLayer = new Map;
                        this._layerByName = {};
                        this._runningId = 0;
                        t.layers || (t.layers = []);
                        this.version = parseFloat(t.version);
                        this.sprite = r ? r.spriteUrl : t.sprite;
                        this.glyphs = r ? r.glyphsUrl : t.glyphs;
                        if (this.layers = t.layers.map((f, b, c) => this._create(f, b, c)))
                            for (r = 0; r < this.layers.length; r++) t = this.layers[r], this._layerByName[t.id.toLowerCase()] = t, this._uidToLayer.set(t.uid, t), 0 === t.type && this.backgroundBucketIds.push(t.id);
                        this._identifyRefLayers()
                    }
                    var w = k.prototype;
                    w.isPainterDataDriven = function(t) {
                        return (t = this._layerByName[t.toLowerCase()]) ? t.isPainterDataDriven() : !1
                    };
                    w.getStyleLayerId = function(t) {
                        return t >=
                            this.layers.length ? null : this.layers[t].id
                    };
                    w.getStyleLayerByUID = function(t) {
                        t = this._uidToLayer.get(t);
                        return null != t ? t : null
                    };
                    w.getStyleLayerIndex = function(t) {
                        return (t = this._layerByName[t.toLowerCase()]) ? this.layers.indexOf(t) : -1
                    };
                    w.setStyleLayer = function(t, r) {
                        if (t && t.id) {
                            r && r >= this.layers.length && (r = this.layers.length - 1);
                            var f = !0,
                                b;
                            if (b = this._layerByName[t.id.toLowerCase()]) {
                                const c = this.layers.indexOf(b);
                                r || (r = c);
                                r === c ? (f = !1, b = k._recreateLayer(t, b), this.layers[r] = b) : (this.layers.splice(c, 1), b = this._create(t,
                                    r, this.layers), this.layers.splice(r, 0, b))
                            } else b = this._create(t, r, this.layers), !r || r >= this.layers.length ? this.layers.push(b) : this.layers.splice(r, 0, b);
                            this._layerByName[t.id.toLowerCase()] = b;
                            this._uidToLayer.set(b.uid, b);
                            f && this._recomputeZValues();
                            this._identifyRefLayers()
                        }
                    };
                    w.getStyleLayer = function(t) {
                        return (t = this._layerByName[t.toLowerCase()]) ? {
                                type: t.typeName,
                                id: t.id,
                                source: t.source,
                                "source-layer": t.sourceLayer,
                                minzoom: t.minzoom,
                                maxzoom: t.maxzoom,
                                filter: t.filter,
                                layout: t.layout,
                                paint: t.paint
                            } :
                            null
                    };
                    w.deleteStyleLayer = function(t) {
                        const r = this._layerByName[t.toLowerCase()];
                        r && (delete this._layerByName[t.toLowerCase()], this._uidToLayer.delete(r.uid), t = this.layers.indexOf(r), this.layers.splice(t, 1), this._recomputeZValues(), this._identifyRefLayers())
                    };
                    w.getLayerById = function(t) {
                        return this._layerByName[t.toLowerCase()]
                    };
                    w.getLayoutProperties = function(t) {
                        return (t = this._layerByName[t.toLowerCase()]) ? t.layout : null
                    };
                    w.getPaintProperties = function(t) {
                        return (t = this._layerByName[t.toLowerCase()]) ?
                            t.paint : null
                    };
                    w.setPaintProperties = function(t, r) {
                        t = this._layerByName[t.toLowerCase()];
                        if (!t) return "";
                        r = k._recreateLayer({
                            type: t.typeName,
                            id: t.id,
                            source: t.source,
                            "source-layer": t.sourceLayer,
                            minzoom: t.minzoom,
                            maxzoom: t.maxzoom,
                            filter: t.filter,
                            layout: t.layout,
                            paint: r
                        }, t);
                        const f = this.layers.indexOf(t);
                        this.layers[f] = r;
                        this._layerByName[t.id.toLowerCase()] = r;
                        this._uidToLayer.set(t.uid, r);
                        return t.id
                    };
                    w.setLayoutProperties = function(t, r) {
                        t = this._layerByName[t.toLowerCase()];
                        if (!t) return "";
                        r = k._recreateLayer({
                            type: t.typeName,
                            id: t.id,
                            source: t.source,
                            "source-layer": t.sourceLayer,
                            minzoom: t.minzoom,
                            maxzoom: t.maxzoom,
                            filter: t.filter,
                            layout: r,
                            paint: t.paint
                        }, t);
                        const f = this.layers.indexOf(t);
                        this.layers[f] = r;
                        this._layerByName[t.id.toLowerCase()] = r;
                        this._uidToLayer.set(t.uid, r);
                        return t.id
                    };
                    w.setStyleLayerVisibility = function(t, r) {
                        if (t = this._layerByName[t.toLowerCase()]) {
                            var f = t.layout || {};
                            f.visibility = r;
                            r = k._recreateLayer({
                                type: t.typeName,
                                id: t.id,
                                source: t.source,
                                "source-layer": t.sourceLayer,
                                minzoom: t.minzoom,
                                maxzoom: t.maxzoom,
                                filter: t.filter,
                                layout: f,
                                paint: t.paint
                            }, t);
                            f = this.layers.indexOf(t);
                            this.layers[f] = r;
                            this._layerByName[t.id.toLowerCase()] = r;
                            this._uidToLayer.set(t.uid, r)
                        }
                    };
                    w.getStyleLayerVisibility = function(t) {
                        var r;
                        t = this._layerByName[t.toLowerCase()];
                        if (!t) return "none";
                        t = t.layout;
                        return null != (r = null == t ? void 0 : t.visibility) ? r : "visible"
                    };
                    w._recomputeZValues = function() {
                        const t = this.layers,
                            r = 1 / (t.length + 1);
                        for (let f = 0; f < t.length; f++) t[f].z = 1 - (1 + f) * r
                    };
                    w._identifyRefLayers = function() {
                        const t = [],
                            r = [];
                        let f = 0;
                        for (const g of this.layers) {
                            if (1 ===
                                g.type) {
                                var b = g,
                                    c = g.source + "|" + g.sourceLayer;
                                c += "|" + JSON.stringify(g.layout && g.layout.visibility);
                                c += "|" + JSON.stringify(g.minzoom);
                                c += "|" + JSON.stringify(g.maxzoom);
                                c += "|" + JSON.stringify(g.filter);
                                if (b.hasDataDrivenFill || b.hasDataDrivenOutline) c += "|" + JSON.stringify(f);
                                t.push({
                                    key: c,
                                    layer: g
                                })
                            }
                            2 === g.type && (b = g, c = g.source + "|" + g.sourceLayer, c += "|" + JSON.stringify(g.layout && g.layout.visibility), c += "|" + JSON.stringify(g.minzoom), c += "|" + JSON.stringify(g.maxzoom), c += "|" + JSON.stringify(g.filter), c += "|" + JSON.stringify(g.layout &&
                                g.layout["line-cap"]), c += "|" + JSON.stringify(g.layout && g.layout["line-join"]), b.hasDataDrivenLine && (c += "|" + JSON.stringify(f)), r.push({
                                key: c,
                                layer: g
                            }));
                            ++f
                        }
                        this._assignRefLayers(t);
                        this._assignRefLayers(r)
                    };
                    w._assignRefLayers = function(t) {
                        t.sort((c, g) => c.key < g.key ? -1 : c.key > g.key ? 1 : 0);
                        let r, f;
                        const b = t.length;
                        for (let c = 0; c < b; c++) {
                            const g = t[c];
                            if (g.key === r) g.layer.refLayerId = f;
                            else if (r = g.key, f = g.layer.id, 1 === g.layer.type && !g.layer.getPaintProperty("fill-outline-color"))
                                for (let e = c + 1; e < b; e++) {
                                    const d =
                                        t[e];
                                    if (d.key === r) {
                                        if (d.layer.getPaintProperty("fill-outline-color")) {
                                            t[c] = d;
                                            t[e] = g;
                                            f = d.layer.id;
                                            break
                                        }
                                    } else break
                                }
                        }
                    };
                    w._create = function(t, r, f) {
                        r = 1 - 1 / (f.length + 1) * (1 + r);
                        f = this._runningId++;
                        switch (t.type) {
                            case "background":
                                return new a.BackgroundStyleLayer(0, t, r, f);
                            case "fill":
                                return new a.FillStyleLayer(1, t, r, f);
                            case "line":
                                return new a.LineStyleLayer(2, t, r, f);
                            case "symbol":
                                return new a.SymbolStyleLayer(3, t, r, f);
                            case "raster":
                                throw Error("Unsupported vector tile raster layer");
                            case "circle":
                                return new a.CircleStyleLayer(4,
                                    t, r, f)
                        }
                        throw Error("Unknown vector tile layer");
                    };
                    k._recreateLayer = function(t, r) {
                        switch (t.type) {
                            case "background":
                                return new a.BackgroundStyleLayer(0, t, r.z, r.uid);
                            case "fill":
                                return new a.FillStyleLayer(1, t, r.z, r.uid);
                            case "line":
                                return new a.LineStyleLayer(2, t, r.z, r.uid);
                            case "symbol":
                                return new a.SymbolStyleLayer(3, t, r.z, r.uid);
                            case "raster":
                                throw Error("Unsupported vector tile raster layer");
                            case "circle":
                                return new a.CircleStyleLayer(4, t, r.z, r.uid)
                        }
                    };
                    return k
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/style/StyleLayer": function() {
            define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../shaders/VTLBackgroundMaterial ../shaders/VTLCircleMaterial ../shaders/VTLFillMaterial ../shaders/VTLLineMaterial ../shaders/VTLSymbolMaterial ./Filter ./StyleDefinition ./StyleProperty ../../webgl/definitions".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d) {
                    let h = function() {
                            function B(v, A, m, E) {
                                this.type = v;
                                this.typeName = A.type;
                                this.id = A.id;
                                this.source = A.source;
                                this.sourceLayer = A["source-layer"];
                                this.minzoom = A.minzoom;
                                this.maxzoom = A.maxzoom;
                                this.filter = A.filter;
                                this.layout = A.layout;
                                this.paint = A.paint;
                                this.z = m;
                                this.uid = E;
                                switch (v) {
                                    case 0:
                                        this._layoutDefinition = g.StyleDefinition.backgroundLayoutDefinition;
                                        this._paintDefinition = g.StyleDefinition.backgroundPaintDefinition;
                                        break;
                                    case 1:
                                        this._layoutDefinition = g.StyleDefinition.fillLayoutDefinition;
                                        this._paintDefinition = g.StyleDefinition.fillPaintDefinition;
                                        break;
                                    case 2:
                                        this._layoutDefinition = g.StyleDefinition.lineLayoutDefinition;
                                        this._paintDefinition = g.StyleDefinition.linePaintDefinition;
                                        break;
                                    case 3:
                                        this._layoutDefinition = g.StyleDefinition.symbolLayoutDefinition;
                                        this._paintDefinition = g.StyleDefinition.symbolPaintDefinition;
                                        break;
                                    case 4:
                                        this._layoutDefinition = g.StyleDefinition.circleLayoutDefinition, this._paintDefinition = g.StyleDefinition.circlePaintDefinition
                                }
                                this._layoutProperties = this._parseLayout(this.layout);
                                this._paintProperties = this._parsePaint(this.paint)
                            }
                            var z = B.prototype;
                            z.getFeatureFilter = function() {
                                return void 0 !== this._featureFilter ? this._featureFilter : this._featureFilter = c.createFilter(this.filter)
                            };
                            z.getLayoutProperty = function(v) {
                                return this._layoutProperties[v]
                            };
                            z.getPaintProperty = function(v) {
                                return this._paintProperties[v]
                            };
                            z.getLayoutValue = function(v, A, m) {
                                let E;
                                const C = this._layoutProperties[v];
                                C && (E = C.getValue(A, m));
                                void 0 === E && (E = this._layoutDefinition[v]["default"]);
                                return E
                            };
                            z.getPaintValue =
                                function(v, A, m) {
                                    let E;
                                    const C = this._paintProperties[v];
                                    C && (E = C.getValue(A, m));
                                    void 0 === E && (E = this._paintDefinition[v]["default"]);
                                    return E
                                };
                            z.isPainterDataDriven = function() {
                                const v = this._paintProperties;
                                if (v)
                                    for (const A in v)
                                        if (v[A].isDataDriven) return !0;
                                return !1
                            };
                            z._parseLayout = function(v) {
                                const A = {};
                                for (const m in v) {
                                    const E = this._layoutDefinition[m];
                                    E && (A[m] = new e(E, v[m]))
                                }
                                return A
                            };
                            z._parsePaint = function(v) {
                                const A = {};
                                for (const m in v) {
                                    const E = this._paintDefinition[m];
                                    E && (A[m] = new e(E, v[m]))
                                }
                                return A
                            };
                            z.computeAttributesKey = function(v, A) {
                                let m = 0,
                                    E = 0;
                                for (const C of A) A = "icon-size" === C || "text-size" === C ? this.getLayoutProperty(C) : this.getPaintProperty(C), E |= (null != A && A.interpolator ? 2 : null != A && A.isDataDriven ? 1 : 0) << m, m += 2;
                                return E << 3 | v
                            };
                            return B
                        }(),
                        p = function(B) {
                            function z(v, A, m, E) {
                                v = B.call(this, v, A, m, E) || this;
                                v.backgroundMaterial = new w.VTLBackgroundMaterial(v.computeAttributesKey(0, w.VTLBackgroundMaterial.ATTRIBUTES));
                                return v
                            }
                            k._inheritsLoose(z, B);
                            return z
                        }(h),
                        l = function(B) {
                            function z(v, A, m, E) {
                                v = B.call(this,
                                    v, A, m, E) || this;
                                A = v.getPaintProperty("fill-color");
                                m = v.getPaintProperty("fill-opacity");
                                E = v.getPaintProperty("fill-pattern");
                                v.hasDataDrivenColor = null == A ? void 0 : A.isDataDriven;
                                v.hasDataDrivenOpacity = null == m ? void 0 : m.isDataDriven;
                                v.hasDataDrivenFill = v.hasDataDrivenColor || v.hasDataDrivenOpacity || (null == E ? void 0 : E.isDataDriven);
                                m = v.getPaintProperty("fill-outline-color");
                                v.outlineUsesFillColor = !m;
                                v.hasDataDrivenOutlineColor = null == m ? void 0 : m.isDataDriven;
                                v.hasDataDrivenOutline = m ? m.isDataDriven : A ? A.isDataDriven :
                                    !1;
                                v.hasDataDrivenOutline = (m ? v.hasDataDrivenOutlineColor : v.hasDataDrivenColor) || v.hasDataDrivenOpacity;
                                v.fillMaterial = new r.VTLFillMaterial(v.computeAttributesKey(1, r.VTLFillMaterial.ATTRIBUTES));
                                v.outlineMaterial = new r.VTLOutlineMaterial(v.computeAttributesKey(2, v.outlineUsesFillColor ? r.VTLOutlineMaterial.ATTRIBUTES_FILL : r.VTLOutlineMaterial.ATTRIBUTES_OUTLINE), v.outlineUsesFillColor);
                                return v
                            }
                            k._inheritsLoose(z, B);
                            return z
                        }(h),
                        n = function(B) {
                            function z(v, A, m, E) {
                                var C, G, F, D, H, I, Q;
                                v = B.call(this, v,
                                    A, m, E) || this;
                                v.lineMaterial = new f.VTLLineMaterial(v.computeAttributesKey(3, f.VTLLineMaterial.ATTRIBUTES));
                                v.hasDataDrivenLine = (null == (C = v.getPaintProperty("line-blur")) ? void 0 : C.isDataDriven) || (null == (G = v.getPaintProperty("line-color")) ? void 0 : G.isDataDriven) || (null == (F = v.getPaintProperty("line-gap-width")) ? void 0 : F.isDataDriven) || (null == (D = v.getPaintProperty("line-offset")) ? void 0 : D.isDataDriven) || (null == (H = v.getPaintProperty("line-opacity")) ? void 0 : H.isDataDriven) || (null == (I = v.getPaintProperty("line-pattern")) ?
                                    void 0 : I.isDataDriven) || (null == (Q = v.getPaintProperty("line-width")) ? void 0 : Q.isDataDriven);
                                A = A.paint["line-width"];
                                A || (A = g.StyleDefinition.linePaintDefinition["line-width"].default);
                                C = v.getPaintProperty("line-width");
                                v.isThinLine = !(null != C && C.isDataDriven) && "number" === typeof A && A < d.THIN_LINE_THRESHOLD;
                                return v
                            }
                            k._inheritsLoose(z, B);
                            return z
                        }(h),
                        u = function(B) {
                            function z(v, A, m, E) {
                                var C, G, F, D, H, I, Q, P, Y, W, X, ba;
                                v = B.call(this, v, A, m, E) || this;
                                v.iconMaterial = new b.VTLIconMaterial(v.computeAttributesKey(4,
                                    b.VTLIconMaterial.ATTRIBUTES));
                                v.textMaterial = new b.VTLTextMaterial(v.computeAttributesKey(6, b.VTLTextMaterial.ATTRIBUTES));
                                v.hasDataDrivenIcon = (null == (C = v.getPaintProperty("icon-color")) ? void 0 : C.isDataDriven) || (null == (G = v.getPaintProperty("icon-halo-blur")) ? void 0 : G.isDataDriven) || (null == (F = v.getPaintProperty("icon-halo-color")) ? void 0 : F.isDataDriven) || (null == (D = v.getPaintProperty("icon-halo-width")) ? void 0 : D.isDataDriven) || (null == (H = v.getPaintProperty("icon-opacity")) ? void 0 : H.isDataDriven) || (null ==
                                    (I = v.getLayoutProperty("icon-size")) ? void 0 : I.isDataDriven);
                                v.hasDataDrivenText = (null == (Q = v.getPaintProperty("text-color")) ? void 0 : Q.isDataDriven) || (null == (P = v.getPaintProperty("text-halo-blur")) ? void 0 : P.isDataDriven) || (null == (Y = v.getPaintProperty("text-halo-color")) ? void 0 : Y.isDataDriven) || (null == (W = v.getPaintProperty("text-halo-width")) ? void 0 : W.isDataDriven) || (null == (X = v.getPaintProperty("text-opacity")) ? void 0 : X.isDataDriven) || (null == (ba = v.getLayoutProperty("text-size")) ? void 0 : ba.isDataDriven);
                                return v
                            }
                            k._inheritsLoose(z, B);
                            return z
                        }(h),
                        y = function(B) {
                            function z(v, A, m, E) {
                                v = B.call(this, v, A, m, E) || this;
                                v.circleMaterial = new t.VTLCircleMaterial(v.computeAttributesKey(5, t.VTLCircleMaterial.ATTRIBUTES));
                                return v
                            }
                            k._inheritsLoose(z, B);
                            return z
                        }(h),
                        x = function() {
                            function B(z, v, A) {
                                var m, E, C, G, F;
                                this.allowOverlap = z.getLayoutValue("icon-allow-overlap", v);
                                this.ignorePlacement = z.getLayoutValue("icon-ignore-placement", v);
                                this.keepUpright = z.getLayoutValue("icon-keep-upright", v);
                                this.optional = z.getLayoutValue("icon-optional",
                                    v);
                                this.rotationAlignment = z.getLayoutValue("icon-rotation-alignment", v);
                                2 === this.rotationAlignment && (this.rotationAlignment = A ? 0 : 1);
                                A = z.getLayoutProperty("icon-anchor");
                                null != (m = A) && m.isDataDriven ? this._anchorProp = A : this.anchor = z.getLayoutValue("icon-anchor", v);
                                A = z.getLayoutProperty("icon-offset");
                                null != (E = A) && E.isDataDriven ? this._offsetProp = A : this.offset = z.getLayoutValue("icon-offset", v);
                                A = z.getLayoutProperty("icon-padding");
                                null != (C = A) && C.isDataDriven ? this._paddingProp = A : this.padding = z.getLayoutValue("icon-padding",
                                    v);
                                A = z.getLayoutProperty("icon-rotate");
                                null != (G = A) && G.isDataDriven ? this._rotateProp = A : this.rotate = z.getLayoutValue("icon-rotate", v);
                                A = z.getLayoutProperty("icon-size");
                                null != (F = A) && F.isDataDriven ? this._sizeProp = A : this.size = z.getLayoutValue("icon-size", v)
                            }
                            B.prototype.update = function(z, v) {
                                this._anchorProp && (this.anchor = this._anchorProp.getValue(z, v));
                                this._offsetProp && (this.offset = this._offsetProp.getValue(z, v));
                                this._paddingProp && (this.padding = this._paddingProp.getValue(z, v));
                                this._rotateProp && (this.rotate =
                                    this._rotateProp.getValue(z, v));
                                this._sizeProp && (this.size = this._sizeProp.getValue(z, v))
                            };
                            return B
                        }(),
                        q = function() {
                            function B(z, v, A) {
                                var m, E, C, G, F, D, H, I, Q, P, Y;
                                this.allowOverlap = z.getLayoutValue("text-allow-overlap", v);
                                this.ignorePlacement = z.getLayoutValue("text-ignore-placement", v);
                                this.keepUpright = z.getLayoutValue("text-keep-upright", v);
                                this.optional = z.getLayoutValue("text-optional", v);
                                this.rotationAlignment = z.getLayoutValue("text-rotation-alignment", v);
                                2 === this.rotationAlignment && (this.rotationAlignment =
                                    A ? 0 : 1);
                                A = z.getLayoutProperty("text-anchor");
                                null != (m = A) && m.isDataDriven ? this._anchorProp = A : this.anchor = z.getLayoutValue("text-anchor", v);
                                A = z.getLayoutProperty("text-justify");
                                null != (E = A) && E.isDataDriven ? this._justifyProp = A : this.justify = z.getLayoutValue("text-justify", v);
                                A = z.getLayoutProperty("text-letter-spacing");
                                null != (C = A) && C.isDataDriven ? this._letterSpacingProp = A : this.letterSpacing = z.getLayoutValue("text-letter-spacing", v);
                                A = z.getLayoutProperty("text-line-height");
                                null != (G = A) && G.isDataDriven ?
                                    this._lineHeightProp = A : this.lineHeight = z.getLayoutValue("text-line-height", v);
                                A = z.getLayoutProperty("text-max-angle");
                                null != (F = A) && F.isDataDriven ? this._maxAngleProp = A : this.maxAngle = z.getLayoutValue("text-max-angle", v);
                                A = z.getLayoutProperty("text-max-width");
                                null != (D = A) && D.isDataDriven ? this._maxWidthProp = A : this.maxWidth = z.getLayoutValue("text-max-width", v);
                                A = z.getLayoutProperty("text-offset");
                                null != (H = A) && H.isDataDriven ? this._offsetProp = A : this.offset = z.getLayoutValue("text-offset", v);
                                A = z.getLayoutProperty("text-padding");
                                null != (I = A) && I.isDataDriven ? this._paddingProp = A : this.padding = z.getLayoutValue("text-padding", v);
                                A = z.getLayoutProperty("text-rotate");
                                null != (Q = A) && Q.isDataDriven ? this._rotateProp = A : this.rotate = z.getLayoutValue("text-rotate", v);
                                A = z.getLayoutProperty("text-size");
                                null != (P = A) && P.isDataDriven ? this._sizeProp = A : this.size = z.getLayoutValue("text-size", v);
                                A = z.getLayoutProperty("text-writing-mode");
                                null != (Y = A) && Y.isDataDriven ? this._writingModeProp = A : this.writingMode = z.getLayoutValue("text-writing-mode", v)
                            }
                            B.prototype.update =
                                function(z, v) {
                                    this._anchorProp && (this.anchor = this._anchorProp.getValue(z, v));
                                    this._justifyProp && (this.justify = this._justifyProp.getValue(z, v));
                                    this._letterSpacingProp && (this.letterSpacing = this._letterSpacingProp.getValue(z, v));
                                    this._lineHeightProp && (this.lineHeight = this._lineHeightProp.getValue(z, v));
                                    this._maxAngleProp && (this.maxAngle = this._maxAngleProp.getValue(z, v));
                                    this._maxWidthProp && (this.maxWidth = this._maxWidthProp.getValue(z, v));
                                    this._offsetProp && (this.offset = this._offsetProp.getValue(z, v));
                                    this._paddingProp && (this.padding = this._paddingProp.getValue(z, v));
                                    this._rotateProp && (this.rotate = this._rotateProp.getValue(z, v));
                                    this._sizeProp && (this.size = this._sizeProp.getValue(z, v));
                                    this._writingModeProp && (this.writingMode = this._writingModeProp.getValue(z, v))
                                };
                            return B
                        }();
                    a.BackgroundStyleLayer = p;
                    a.CircleStyleLayer = y;
                    a.FillStyleLayer = l;
                    a.IconLayout = x;
                    a.LineStyleLayer = n;
                    a.StyleLayer = h;
                    a.SymbolStyleLayer = u;
                    a.TextLayout = q;
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/views/2d/engine/vectorTiles/shaders/VTLBackgroundMaterial": function() {
            define(["exports",
                "../../../../../chunks/_rollupPluginBabelHelpers", "./VTLMaterial"
            ], function(a, k, w) {
                w = function(t) {
                    function r(b) {
                        return t.call(this, b) || this
                    }
                    k._inheritsLoose(r, t);
                    var f = r.prototype;
                    f.geometryInfo = function() {
                        return r.GEOMETRY_LAYOUT
                    };
                    f.opacityInfo = function() {
                        return null
                    };
                    f.attributes = function() {
                        return r.ATTRIBUTES
                    };
                    f.attributesInfo = function() {
                        return r.ATTRIBUTES_INFO
                    };
                    return r
                }(w.VTLMaterial);
                w.ATTRIBUTES = [];
                w.GEOMETRY_LAYOUT = [{
                    name: "a_pos",
                    count: 2,
                    type: 5120,
                    offset: 0,
                    stride: 2,
                    normalized: !1,
                    divisor: 0
                }];
                w.ATTRIBUTES_INFO = {};
                a.VTLBackgroundMaterial = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/shaders/VTLMaterial": function() {
            define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "../../../../../chunks/vec4f32", "../MemoryBuffer"], function(a, k, w, t) {
                let r = function() {
                    function b(g) {
                        this._color = w.create();
                        this._key = g
                    }
                    var c = b.prototype;
                    c.defines = function() {
                        return []
                    };
                    c.getStride = function() {
                        this._layoutInfo || this._buildAttributesInfo();
                        return this._stride
                    };
                    c.getAttributeLocations = function() {
                        this._locations || this._buildAttributesInfo();
                        return this._locations
                    };
                    c.getLayoutInfo = function() {
                        this._layoutInfo || this._buildAttributesInfo();
                        return this._layoutInfo
                    };
                    c.getEncodingInfos = function() {
                        this._propertyEncodingInfo || this._buildAttributesInfo();
                        return this._propertyEncodingInfo
                    };
                    c.getUniforms = function() {
                        this._uniforms || this._buildAttributesInfo();
                        return this._uniforms
                    };
                    c.getShaderHeader = function() {
                        this._shaderHeader || this._buildAttributesInfo();
                        return this._shaderHeader
                    };
                    c.getShaderMain = function() {
                        this._shaderMain || this._buildAttributesInfo();
                        return this._shaderMain
                    };
                    c.setDataUniforms = function(g, e, d, h) {
                        const p = this.getUniforms();
                        for (const l in p) {
                            const n = p[l];
                            switch (n.type) {
                                case "float":
                                    g.setUniform1f(n.name, n.getValue(d, e, h));
                                    break;
                                case "vec2":
                                    g.setUniform2fv(n.name, n.getValue(d, e, h));
                                    break;
                                case "vec4":
                                    {
                                        const u = n.getValue(d, e, h),
                                            y = u[3];this._color[0] = y * u[0];this._color[1] = y * u[1];this._color[2] = y * u[2];this._color[3] = y;g.setUniform4fv(n.name, this._color)
                                    }
                            }
                        }
                    };
                    c.encodeAttributes =
                        function(g, e, d) {
                            const h = this.attributesInfo(),
                                p = this.getEncodingInfos(),
                                l = [];
                            for (const y of Object.keys(p)) {
                                var n, u = p[y];
                                const {
                                    type: x,
                                    precisionFactor: q,
                                    isLayout: B
                                } = h[y], z = B ? d.getLayoutProperty(y) : d.getPaintProperty(y), v = null == (n = z.interpolator) ? void 0 : n.getInterpolationRange(e);
                                let A = 0;
                                for (const m of u) {
                                    m.dataIndex >= l.length && l.push(0);
                                    u = z.getValue(v ? v[A] : e, g);
                                    switch (x) {
                                        case 0:
                                            l[m.dataIndex] |= this._encodeByte(u * (q || 1), 8 * m.offset);
                                            break;
                                        case 1:
                                            l[m.dataIndex] |= this._encodeByte(u * (q || 1) + 128, 8 * m.offset);
                                            break;
                                        case 2:
                                            l[m.dataIndex] = this._encodeColor(u);
                                            break;
                                        default:
                                            throw Error("Unsupported encoding type");
                                    }++A
                                }
                            }
                            return l
                        };
                    c.getAtributeState = function(g) {
                        const e = 3 + 2 * g;
                        g = 0 | this._bit(e);
                        return g |= this._bit(e + 1) << 1
                    };
                    c._buildAttributesInfo = function() {
                        const g = [],
                            e = {};
                        var d = {},
                            h = -1,
                            p = this.attributesInfo(),
                            l = this.attributes();
                        let n = -1;
                        for (const x of l) {
                            ++n;
                            l = this.getAtributeState(n);
                            if (0 === l) continue;
                            var u = p[x];
                            const q = [];
                            e[x] = q;
                            u = u.type;
                            for (let B = 0; B < l; ++B) {
                                const {
                                    dataType: z,
                                    bytesPerElement: v,
                                    count: A,
                                    normalized: m
                                } =
                                b._encodingInfo[u], E = z << 2 | A;
                                let C = d[E];
                                C && 4 !== C.offset || (++h, d[E] = C = {
                                    dataIndex: h,
                                    offset: 0
                                }, g.push({
                                    location: -1,
                                    name: "a_data_" + h,
                                    count: 4 / v,
                                    type: z,
                                    normalized: m
                                }));
                                q.push({
                                    dataIndex: C.dataIndex,
                                    offset: C.offset
                                });
                                C.offset += v * A
                            }
                        }
                        this._buildVertexBufferLayout(g);
                        d = {};
                        h = 0;
                        p = this._layoutInfo.geometry;
                        for (var y of p) d[y.name] = h++;
                        if (y = this._layoutInfo.opacity)
                            for (const x of y) d[x.name] = h++;
                        this._buildShaderInfo(g, e);
                        this._propertyEncodingInfo = e;
                        this._locations = d
                    };
                    c._buildVertexBufferLayout = function(g) {
                        const e = {};
                        var d = this.geometryInfo();
                        let h = d[0].stride;
                        if (0 === g.length) e.geometry = d;
                        else {
                            const p = [];
                            let l = h;
                            h += 4 * g.length;
                            for (const n of d) d = { ...n
                            }, d.stride = h, p.push(d);
                            for (const n of g) p.push({
                                name: n.name,
                                count: n.count,
                                type: n.type,
                                offset: l,
                                stride: h,
                                normalized: n.normalized || !1,
                                divisor: 0
                            }), l += f(n.type) * n.count;
                            e.geometry = p
                        }
                        this.opacityInfo() && (e.opacity = this.opacityInfo());
                        this._layoutInfo = e;
                        this._stride = h
                    };
                    c._buildShaderInfo = function(g, e) {
                        let d = "\n",
                            h = "\n";
                        const p = [];
                        for (var l of g) d += `attribute ${this._getType(l.count)} ${l.name};\n`;
                        var n = this.attributes();
                        g = this.attributesInfo();
                        l = -1;
                        for (const x of n) {
                            ++l;
                            const {
                                name: q,
                                type: B,
                                precisionFactor: z,
                                isLayout: v
                            } = g[x];
                            n = z && 1 !== z ? ` * ${1/z}` : "";
                            const {
                                bytesPerElement: A,
                                count: m
                            } = b._encodingInfo[B];
                            var u = E => `a_data_${E.dataIndex}${2===B?"":`[${E.offset/A}]`}`;
                            switch (this.getAtributeState(l)) {
                                case 0:
                                    n = this._getType(m);
                                    var y = `u_${q}`;
                                    p.push({
                                        name: y,
                                        type: n,
                                        getValue: (E, C) => v ? E.getLayoutValue(x, C) : E.getPaintValue(x, C)
                                    });
                                    d += `uniform ${n} ${y};\n`;
                                    h += `${n} ${q} = ${y};\n`;
                                    break;
                                case 1:
                                    y = u(e[x][0]);
                                    h += `${this._getType(m)} ${q} = ${y}${n};\n`;
                                    break;
                                case 2:
                                    {
                                        y = `u_t_${q}`;p.push({
                                            name: y,
                                            type: "float",
                                            getValue: (C, G, F) => (v ? C.getLayoutProperty(x) : C.getPaintProperty(x)).interpolator.interpolationUniformValue(F, G)
                                        });d += `uniform float ${y};\n`;
                                        const E = u(e[x][0]);u = u(e[x][1]);h += `${this._getType(m)} ${q} = mix(${E}${n}, ${u}${n}, ${y});\n`
                                    }
                            }
                        }
                        this._shaderHeader = d;
                        this._shaderMain = h;
                        this._uniforms = p
                    };
                    c._bit = function(g) {
                        return (this._key & 1 << g) >> g
                    };
                    c._getType = function(g) {
                        switch (g) {
                            case 1:
                                return "float";
                            case 2:
                                return "vec2";
                            case 4:
                                return "vec4"
                        }
                        throw Error("Invalid count");
                    };
                    c._encodeColor = function(g) {
                        const e = 255 * g[3];
                        return t.i8888to32(g[0] * e, g[1] * e, g[2] * e, e)
                    };
                    c._encodeByte = function(g, e) {
                        return (g & 255) << e
                    };
                    k._createClass(b, [{
                        key: "key",
                        get: function() {
                            return this._key
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._key & 7
                        }
                    }]);
                    return b
                }();
                r._encodingInfo = [{
                    dataType: 5121,
                    bytesPerElement: 1,
                    count: 1,
                    normalized: !1
                }, {
                    dataType: 5121,
                    bytesPerElement: 1,
                    count: 1,
                    normalized: !1
                }, {
                    dataType: 5121,
                    bytesPerElement: 1,
                    count: 4,
                    normalized: !0
                }];
                const f =
                    b => {
                        switch (b) {
                            case 5126:
                                return 4;
                            case 5124:
                                return 4;
                            case 5125:
                                return 4;
                            case 5122:
                                return 2;
                            case 5123:
                                return 2;
                            case 5120:
                                return 1;
                            case 5121:
                                return 1
                        }
                    };
                a.VTLMaterial = r;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/chunks/vec4f32": function() {
            define(["exports"], function(a) {
                function k() {
                    return new Float32Array(4)
                }

                function w(q) {
                    const B = new Float32Array(4);
                    B[0] = q[0];
                    B[1] = q[1];
                    B[2] = q[2];
                    B[3] = q[3];
                    return B
                }

                function t(q, B, z, v) {
                    const A = new Float32Array(4);
                    A[0] = q;
                    A[1] = B;
                    A[2] = z;
                    A[3] = v;
                    return A
                }

                function r(q,
                    B) {
                    return new Float32Array(q, B, 4)
                }

                function f() {
                    return k()
                }

                function b() {
                    return t(1, 1, 1, 1)
                }

                function c() {
                    return t(1, 0, 0, 0)
                }

                function g() {
                    return t(0, 1, 0, 0)
                }

                function e() {
                    return t(0, 0, 1, 0)
                }

                function d() {
                    return t(0, 0, 0, 1)
                }
                const h = k(),
                    p = b(),
                    l = c(),
                    n = g(),
                    u = e(),
                    y = d();
                var x = Object.freeze({
                    __proto__: null,
                    create: k,
                    clone: w,
                    fromValues: t,
                    createView: r,
                    zeros: f,
                    ones: b,
                    unitX: c,
                    unitY: g,
                    unitZ: e,
                    unitW: d,
                    ZEROS: h,
                    ONES: p,
                    UNIT_X: l,
                    UNIT_Y: n,
                    UNIT_Z: u,
                    UNIT_W: y
                });
                a.ONES = p;
                a.UNIT_W = y;
                a.UNIT_X = l;
                a.UNIT_Y = n;
                a.UNIT_Z = u;
                a.ZEROS = h;
                a.clone =
                    w;
                a.create = k;
                a.createView = r;
                a.fromValues = t;
                a.ones = b;
                a.unitW = d;
                a.unitX = c;
                a.unitY = g;
                a.unitZ = e;
                a.vec4f32 = x;
                a.zeros = f
            })
        },
        "esri/views/2d/engine/vectorTiles/MemoryBuffer": function() {
            define(["../../../../chunks/_rollupPluginBabelHelpers"], function(a) {
                return function() {
                    function k(t) {
                        this._array = [];
                        0 >= t && console.error("strideInBytes must be positive!");
                        this._stride = t
                    }
                    var w = k.prototype;
                    w.reset = function() {
                        this.array.length = 0
                    };
                    w.toBuffer = function() {
                        return (new Uint32Array(this._array)).buffer
                    };
                    k.i1616to32 = function(t,
                        r) {
                        return 65535 & t | r << 16
                    };
                    k.i8888to32 = function(t, r, f, b) {
                        return t & 255 | (r & 255) << 8 | (f & 255) << 16 | b << 24
                    };
                    k.i8816to32 = function(t, r, f) {
                        return t & 255 | (r & 255) << 8 | f << 16
                    };
                    a._createClass(k, [{
                        key: "array",
                        get: function() {
                            return this._array
                        }
                    }, {
                        key: "index",
                        get: function() {
                            return 4 * this._array.length / this._stride
                        }
                    }, {
                        key: "itemSize",
                        get: function() {
                            return this._stride
                        }
                    }, {
                        key: "sizeInBytes",
                        get: function() {
                            return 4 * this._array.length
                        }
                    }]);
                    return k
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/shaders/VTLCircleMaterial": function() {
            define(["exports",
                "../../../../../chunks/_rollupPluginBabelHelpers", "./VTLMaterial"
            ], function(a, k, w) {
                w = function(t) {
                    function r(b) {
                        return t.call(this, b) || this
                    }
                    k._inheritsLoose(r, t);
                    var f = r.prototype;
                    f.geometryInfo = function() {
                        return r.GEOMETRY_LAYOUT
                    };
                    f.opacityInfo = function() {
                        return null
                    };
                    f.attributes = function() {
                        return r.ATTRIBUTES
                    };
                    f.attributesInfo = function() {
                        return r.ATTRIBUTES_INFO
                    };
                    return r
                }(w.VTLMaterial);
                w.ATTRIBUTES = "circle-radius circle-color circle-opacity circle-stroke-width circle-stroke-color circle-stroke-opacity circle-blur".split(" ");
                w.GEOMETRY_LAYOUT = [{
                    name: "a_pos",
                    count: 2,
                    type: 5122,
                    offset: 0,
                    stride: 4,
                    normalized: !1,
                    divisor: 0
                }];
                w.ATTRIBUTES_INFO = {
                    "circle-radius": {
                        name: "radius",
                        type: 0
                    },
                    "circle-color": {
                        name: "color",
                        type: 2
                    },
                    "circle-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    },
                    "circle-stroke-width": {
                        name: "stroke_width",
                        type: 0,
                        precisionFactor: 4
                    },
                    "circle-stroke-color": {
                        name: "stroke_color",
                        type: 2
                    },
                    "circle-stroke-opacity": {
                        name: "stroke_opacity",
                        type: 0,
                        precisionFactor: 100
                    },
                    "circle-blur": {
                        name: "blur",
                        type: 0,
                        precisionFactor: 32
                    }
                };
                a.VTLCircleMaterial = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/shaders/VTLFillMaterial": function() {
            define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "./VTLMaterial"], function(a, k, w) {
                let t = function(r) {
                    function f(c) {
                        return r.call(this, c) || this
                    }
                    k._inheritsLoose(f, r);
                    var b = f.prototype;
                    b.geometryInfo = function() {
                        return f.GEOMETRY_LAYOUT
                    };
                    b.opacityInfo = function() {
                        return null
                    };
                    b.attributes = function() {
                        return f.ATTRIBUTES
                    };
                    b.attributesInfo = function() {
                        return f.ATTRIBUTES_INFO
                    };
                    return f
                }(w.VTLMaterial);
                t.ATTRIBUTES = ["fill-color", "fill-opacity"];
                t.GEOMETRY_LAYOUT = [{
                    name: "a_pos",
                    count: 2,
                    type: 5122,
                    offset: 0,
                    stride: 4,
                    normalized: !1,
                    divisor: 0
                }];
                t.ATTRIBUTES_INFO = {
                    "fill-color": {
                        name: "color",
                        type: 2
                    },
                    "fill-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    }
                };
                w = function(r) {
                    function f(c, g) {
                        c = r.call(this, c) || this;
                        c.usefillColor = g;
                        return c
                    }
                    k._inheritsLoose(f, r);
                    var b = f.prototype;
                    b.geometryInfo = function() {
                        return f.GEOMETRY_LAYOUT
                    };
                    b.opacityInfo = function() {
                        return null
                    };
                    b.attributes = function() {
                        return this.usefillColor ?
                            f.ATTRIBUTES_FILL : f.ATTRIBUTES_OUTLINE
                    };
                    b.attributesInfo = function() {
                        return this.usefillColor ? f.ATTRIBUTES_INFO_FILL : f.ATTRIBUTES_INFO_OUTLINE
                    };
                    return f
                }(w.VTLMaterial);
                w.ATTRIBUTES_OUTLINE = ["fill-outline-color", "fill-opacity"];
                w.ATTRIBUTES_FILL = ["fill-color", "fill-opacity"];
                w.GEOMETRY_LAYOUT = [{
                    name: "a_pos",
                    count: 2,
                    type: 5122,
                    offset: 0,
                    stride: 8,
                    normalized: !1,
                    divisor: 0
                }, {
                    name: "a_offset",
                    count: 2,
                    type: 5120,
                    offset: 4,
                    stride: 8,
                    normalized: !1,
                    divisor: 0
                }, {
                    name: "a_xnormal",
                    count: 2,
                    type: 5120,
                    offset: 6,
                    stride: 8,
                    normalized: !1,
                    divisor: 0
                }];
                w.ATTRIBUTES_INFO_OUTLINE = {
                    "fill-outline-color": {
                        name: "color",
                        type: 2
                    },
                    "fill-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    }
                };
                w.ATTRIBUTES_INFO_FILL = {
                    "fill-color": {
                        name: "color",
                        type: 2
                    },
                    "fill-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    }
                };
                a.VTLFillMaterial = t;
                a.VTLOutlineMaterial = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/shaders/VTLLineMaterial": function() {
            define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers",
                "./VTLMaterial"
            ], function(a, k, w) {
                w = function(t) {
                    function r(b) {
                        return t.call(this, b) || this
                    }
                    k._inheritsLoose(r, t);
                    var f = r.prototype;
                    f.geometryInfo = function() {
                        return r.GEOMETRY_LAYOUT
                    };
                    f.opacityInfo = function() {
                        return null
                    };
                    f.attributes = function() {
                        return r.ATTRIBUTES
                    };
                    f.attributesInfo = function() {
                        return r.ATTRIBUTES_INFO
                    };
                    return r
                }(w.VTLMaterial);
                w.ATTRIBUTES = "line-blur line-color line-gap-width line-offset line-opacity line-width".split(" ");
                w.GEOMETRY_LAYOUT = [{
                    name: "a_pos",
                    count: 2,
                    type: 5122,
                    offset: 0,
                    stride: 12,
                    normalized: !1,
                    divisor: 0
                }, {
                    name: "a_offsetAndNormal",
                    count: 4,
                    type: 5120,
                    offset: 4,
                    stride: 12,
                    normalized: !1,
                    divisor: 0
                }, {
                    name: "a_accumulatedDistance",
                    count: 2,
                    type: 5123,
                    offset: 8,
                    stride: 12,
                    normalized: !1,
                    divisor: 0
                }];
                w.ATTRIBUTES_INFO = {
                    "line-width": {
                        name: "width",
                        type: 0,
                        precisionFactor: 2
                    },
                    "line-gap-width": {
                        name: "gap_width",
                        type: 0,
                        precisionFactor: 2
                    },
                    "line-offset": {
                        name: "offset",
                        type: 1,
                        precisionFactor: 2
                    },
                    "line-color": {
                        name: "color",
                        type: 2
                    },
                    "line-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    },
                    "line-blur": {
                        name: "blur",
                        type: 0,
                        precisionFactor: 4
                    }
                };
                a.VTLLineMaterial = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/shaders/VTLSymbolMaterial": function() {
            define(["exports", "../../../../../chunks/_rollupPluginBabelHelpers", "./VTLMaterial"], function(a, k, w) {
                const t = [{
                        name: "a_pos",
                        count: 2,
                        type: 5122,
                        offset: 0,
                        stride: 16,
                        normalized: !1,
                        divisor: 0
                    }, {
                        name: "a_vertexOffset",
                        count: 2,
                        type: 5122,
                        offset: 4,
                        stride: 16,
                        normalized: !1,
                        divisor: 0
                    }, {
                        name: "a_texAngleRange",
                        count: 4,
                        type: 5121,
                        offset: 8,
                        stride: 16,
                        normalized: !1,
                        divisor: 0
                    }, {
                        name: "a_levelInfo",
                        count: 4,
                        type: 5121,
                        offset: 12,
                        stride: 16,
                        normalized: !1,
                        divisor: 0
                    }],
                    r = [{
                        name: "a_opacityInfo",
                        count: 1,
                        type: 5121,
                        offset: 0,
                        stride: 1,
                        normalized: !1,
                        divisor: 0
                    }];
                let f = function(b) {
                    function c(e) {
                        return b.call(this, e) || this
                    }
                    k._inheritsLoose(c, b);
                    var g = c.prototype;
                    g.geometryInfo = function() {
                        return t
                    };
                    g.opacityInfo = function() {
                        return r
                    };
                    g.attributes = function() {
                        return c.ATTRIBUTES
                    };
                    g.attributesInfo = function() {
                        return c.ATTRIBUTES_INFO
                    };
                    return c
                }(w.VTLMaterial);
                f.ATTRIBUTES =
                    "icon-color icon-opacity icon-halo-blur icon-halo-color icon-halo-width icon-size".split(" ");
                f.ATTRIBUTES_INFO = {
                    "icon-color": {
                        name: "color",
                        type: 2
                    },
                    "icon-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    },
                    "icon-halo-color": {
                        name: "halo_color",
                        type: 2
                    },
                    "icon-halo-width": {
                        name: "halo_width",
                        type: 0,
                        precisionFactor: 4
                    },
                    "icon-halo-blur": {
                        name: "halo_blur",
                        type: 0,
                        precisionFactor: 4
                    },
                    "icon-size": {
                        name: "size",
                        type: 0,
                        precisionFactor: 32,
                        isLayout: !0
                    }
                };
                w = function(b) {
                    function c(e) {
                        return b.call(this, e) || this
                    }
                    k._inheritsLoose(c,
                        b);
                    var g = c.prototype;
                    g.geometryInfo = function() {
                        return t
                    };
                    g.opacityInfo = function() {
                        return r
                    };
                    g.attributes = function() {
                        return c.ATTRIBUTES
                    };
                    g.attributesInfo = function() {
                        return c.ATTRIBUTES_INFO
                    };
                    return c
                }(w.VTLMaterial);
                w.ATTRIBUTES = "text-color text-opacity text-halo-blur text-halo-color text-halo-width text-size".split(" ");
                w.ATTRIBUTES_INFO = {
                    "text-color": {
                        name: "color",
                        type: 2
                    },
                    "text-opacity": {
                        name: "opacity",
                        type: 0,
                        precisionFactor: 100
                    },
                    "text-halo-color": {
                        name: "halo_color",
                        type: 2
                    },
                    "text-halo-width": {
                        name: "halo_width",
                        type: 0,
                        precisionFactor: 4
                    },
                    "text-halo-blur": {
                        name: "halo_blur",
                        type: 0,
                        precisionFactor: 4
                    },
                    "text-size": {
                        name: "size",
                        type: 0,
                        isLayout: !0
                    }
                };
                a.VTLIconMaterial = f;
                a.VTLTextMaterial = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/style/Filter": function() {
            define(["../expression/types", "../expression/expression"], function(a, k) {
                return function() {
                    function w(t) {
                        this._expression = t
                    }
                    w.prototype.filter = function(t, r) {
                        if (!this._expression) return !0;
                        try {
                            return this._expression.evaluate(t,
                                r)
                        } catch (f) {
                            return console.log(f.message), !0
                        }
                    };
                    w.createFilter = function(t) {
                        if (!t) return null;
                        this.isLegacyFilter(t) && (t = this.convertLegacyFilter(t));
                        try {
                            const r = k.createExpression(t, null, a.BooleanType);
                            return new w(r)
                        } catch (r) {
                            return console.log(r.message), null
                        }
                    };
                    w.isLegacyFilter = function(t) {
                        if (!Array.isArray(t) || 0 === t.length) return !0;
                        switch (t[0]) {
                            case "\x3d\x3d":
                            case "!\x3d":
                            case "\x3e":
                            case "\x3c":
                            case "\x3e\x3d":
                            case "\x3c\x3d":
                                return 3 === t.length && "string" === typeof t[1] && !Array.isArray(t[2]);
                            case "in":
                                return 3 <=
                                    t.length && "string" === typeof t[1] && !Array.isArray(t[2]);
                            case "!in":
                                return !0;
                            case "any":
                            case "all":
                                for (let r = 1; r < t.length; r++)
                                    if (!this.isLegacyFilter(t[1])) return !1;
                                return !0;
                            case "none":
                                return !0;
                            case "has":
                                return 2 === t.length && ("$id" === t[1] || "$type" === t[1]);
                            case "!has":
                                return !0;
                            default:
                                return !1
                        }
                    };
                    w.convertLegacyFilter = function(t) {
                        if (!Array.isArray(t) || 0 === t.length) return !0;
                        const r = t[0];
                        if (1 === t.length) return "any" !== r;
                        switch (r) {
                            case "\x3d\x3d":
                                return w.convertComparison("\x3d\x3d", t[1], t[2]);
                            case "!\x3d":
                                return w.negate(w.convertComparison("\x3d\x3d",
                                    t[1], t[2]));
                            case "\x3e":
                            case "\x3c":
                            case "\x3e\x3d":
                            case "\x3c\x3d":
                                return w.convertComparison(r, t[1], t[2]);
                            case "in":
                                return w.convertIn(t[1], t.slice(2));
                            case "!in":
                                return w.negate(w.convertIn(t[1], t.slice(2)));
                            case "any":
                            case "all":
                            case "none":
                                return w.convertCombining(r, t.slice(1));
                            case "has":
                                return w.convertHas(t[1]);
                            case "!has":
                                return w.negate(w.convertHas(t[1]));
                            default:
                                throw Error("Unexpected legacy filter.");
                        }
                    };
                    w.convertComparison = function(t, r, f) {
                        switch (r) {
                            case "$type":
                                return [t, ["geometry-type"],
                                    f
                                ];
                            case "$id":
                                return [t, ["id"], f];
                            default:
                                return [t, ["get", r], f]
                        }
                    };
                    w.convertIn = function(t, r) {
                        switch (t) {
                            case "$type":
                                return ["in", ["geometry-type"],
                                    ["literal", r]
                                ];
                            case "$id":
                                return ["in", ["id"],
                                    ["literal", r]
                                ];
                            default:
                                return ["in", ["get", t],
                                    ["literal", r]
                                ]
                        }
                    };
                    w.convertHas = function(t) {
                        switch (t) {
                            case "$type":
                                return !0;
                            case "$id":
                                return ["has-id"];
                            default:
                                return ["has", t]
                        }
                    };
                    w.convertCombining = function(t, r) {
                        return [t].concat(r.map(this.convertLegacyFilter))
                    };
                    w.negate = function(t) {
                        return ["!", t]
                    };
                    return w
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/expression/types": function() {
            define(["exports",
                "../../../../../Color"
            ], function(a, k) {
                function w(n, u) {
                    return {
                        kind: "array",
                        itemType: n,
                        n: u
                    }
                }

                function t(n) {
                    if ("array" === n.kind) {
                        const u = t(n.itemType);
                        return "number" === typeof n.n ? `array<${u}, ${n.n}>` : "value" === n.itemType.kind ? "array" : `array<${u}>`
                    }
                    return n.kind
                }

                function r(n) {
                    if (null === n) return b;
                    if ("string" === typeof n) return g;
                    if ("boolean" === typeof n) return e;
                    if ("number" === typeof n) return c;
                    if (n instanceof k) return d;
                    if (Array.isArray(n)) {
                        let u;
                        for (const y of n) {
                            const x = r(y);
                            if (!u) u = x;
                            else if (u !== x) {
                                u =
                                    p;
                                break
                            }
                        }
                        return w(u || p, n.length)
                    }
                    return "object" === typeof n ? h : p
                }

                function f(n, u) {
                    if ("array" === u.kind) return "array" === n.kind && (0 === n.n && "value" === n.itemType.kind || f(n.itemType, u.itemType)) && ("number" !== typeof u.n || u.n === n.n);
                    if ("value" === u.kind)
                        for (const y of l)
                            if (f(n, y)) return !0;
                    return u.kind === n.kind
                }
                const b = {
                        kind: "null"
                    },
                    c = {
                        kind: "number"
                    },
                    g = {
                        kind: "string"
                    },
                    e = {
                        kind: "boolean"
                    },
                    d = {
                        kind: "color"
                    },
                    h = {
                        kind: "object"
                    },
                    p = {
                        kind: "value"
                    },
                    l = [b, c, g, e, d, h, w(p)];
                a.BooleanType = e;
                a.ColorType = d;
                a.NullType = b;
                a.NumberType =
                    c;
                a.ObjectType = h;
                a.StringType = g;
                a.ValueType = p;
                a.arrayType = w;
                a.getType = r;
                a.matchType = f;
                a.typeToString = t;
                a.valueToString = function(n) {
                    if (null === n) return "";
                    const u = typeof n;
                    return "string" === u ? n : "number" === u || "boolean" === u ? String(n) : n instanceof k ? n.toString() : JSON.stringify(n)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/Color": function() {
            define(["./chunks/_rollupPluginBabelHelpers", "./core/maybe", "./core/accessorSupport/ensureType", "./colorUtils", "./core/mathUtils"], function(a, k, w, t, r) {
                function f(g) {
                    return r.clamp(w.ensureInteger(g),
                        0, 255)
                }

                function b(g, e, d) {
                    g = Number(g);
                    return isNaN(g) ? d : g < e ? e : g > d ? d : g
                }
                let c = function() {
                    function g(d) {
                        this.b = this.g = this.r = 255;
                        this.a = 1;
                        d && this.setColor(d)
                    }
                    g.blendColors = function(d, h, p, l = new g) {
                        l.r = Math.round(d.r + (h.r - d.r) * p);
                        l.g = Math.round(d.g + (h.g - d.g) * p);
                        l.b = Math.round(d.b + (h.b - d.b) * p);
                        l.a = d.a + (h.a - d.a) * p;
                        return l._sanitize()
                    };
                    g.fromRgb = function(d, h) {
                        var p = d.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
                        if (p) {
                            d = p[2].split(/\s*,\s*/);
                            p = p[1];
                            if ("rgb" === p && 3 === d.length || "rgba" === p && 4 ===
                                d.length) return p = d[0], "%" === p.charAt(p.length - 1) ? (p = d.map(l => 2.56 * parseFloat(l)), 4 === d.length && (p[3] = parseFloat(d[3])), g.fromArray(p, h)) : g.fromArray(d.map(l => parseFloat(l)), h);
                            if ("hsl" === p && 3 === d.length || "hsla" === p && 4 === d.length) return g.fromArray(t.hsla2rgba(parseFloat(d[0]), parseFloat(d[1]) / 100, parseFloat(d[2]) / 100, parseFloat(d[3])), h)
                        }
                        return null
                    };
                    g.fromHex = function(d, h = new g) {
                        if (4 !== d.length && 7 !== d.length || "#" !== d[0]) return null;
                        const p = 4 === d.length ? 4 : 8,
                            l = (1 << p) - 1;
                        let n = Number("0x" + d.substr(1));
                        if (isNaN(n)) return null;
                        ["b", "g", "r"].forEach(u => {
                            const y = n & l;
                            n >>= p;
                            h[u] = 4 === p ? 17 * y : y
                        });
                        h.a = 1;
                        return h
                    };
                    g.fromArray = function(d, h = new g) {
                        h._set(Number(d[0]), Number(d[1]), Number(d[2]), Number(d[3]));
                        isNaN(h.a) && (h.a = 1);
                        return h._sanitize()
                    };
                    g.fromString = function(d, h) {
                        const p = t.getNamedColor(d);
                        return p && g.fromArray(p, h) || g.fromRgb(d, h) || g.fromHex(d, h)
                    };
                    g.fromJSON = function(d) {
                        return d && new g([d[0], d[1], d[2], d[3] / 255])
                    };
                    g.toUnitRGB = function(d) {
                        return k.isSome(d) ? [d.r / 255, d.g / 255, d.b / 255] : null
                    };
                    g.toUnitRGBA =
                        function(d) {
                            return k.isSome(d) ? [d.r / 255, d.g / 255, d.b / 255, null != d.a ? d.a : 1] : null
                        };
                    var e = g.prototype;
                    e.setColor = function(d) {
                        if ("string" === typeof d) g.fromString(d, this);
                        else if (Array.isArray(d)) g.fromArray(d, this);
                        else {
                            var h, p, l, n;
                            this._set(null != (h = d.r) ? h : 0, null != (p = d.g) ? p : 0, null != (l = d.b) ? l : 0, null != (n = d.a) ? n : 1);
                            d instanceof g || this._sanitize()
                        }
                        return this
                    };
                    e.toRgb = function() {
                        return [this.r, this.g, this.b]
                    };
                    e.toRgba = function() {
                        return [this.r, this.g, this.b, this.a]
                    };
                    e.toHex = function() {
                        const d = this.r.toString(16),
                            h = this.g.toString(16),
                            p = this.b.toString(16);
                        return `#${2>d.length?"0"+d:d}${2>h.length?"0"+h:h}${2>p.length?"0"+p:p}`
                    };
                    e.toCss = function(d = !1) {
                        const h = this.r + ", " + this.g + ", " + this.b;
                        return d ? `rgba(${h}, ${this.a})` : `rgb(${h})`
                    };
                    e.toString = function() {
                        return this.toCss(!0)
                    };
                    e.toJSON = function() {
                        return this.toArray()
                    };
                    e.toArray = function(d = 0) {
                        const h = f(this.r),
                            p = f(this.g),
                            l = f(this.b);
                        return 0 === d || 1 !== this.a ? [h, p, l, f(255 * this.a)] : [h, p, l]
                    };
                    e.clone = function() {
                        return new g(this.toRgba())
                    };
                    e.hash = function() {
                        return this.r <<
                            24 | this.g << 16 | this.b << 8 | 255 * this.a
                    };
                    e._sanitize = function() {
                        this.r = Math.round(b(this.r, 0, 255));
                        this.g = Math.round(b(this.g, 0, 255));
                        this.b = Math.round(b(this.b, 0, 255));
                        this.a = b(this.a, 0, 1);
                        return this
                    };
                    e._set = function(d, h, p, l) {
                        this.r = d;
                        this.g = h;
                        this.b = p;
                        this.a = l
                    };
                    a._createClass(g, [{
                        key: "isBright",
                        get: function() {
                            return 127 <= .299 * this.r + .587 * this.g + .114 * this.b
                        }
                    }]);
                    return g
                }();
                c.prototype.declaredClass = "esri.Color";
                return c
            })
        },
        "esri/colorUtils": function() {
            define(["exports"], function(a) {
                function k(r) {
                    var f;
                    return null != (f = t[r.toLowerCase()]) ? f : null
                }

                function w(r, f, b) {
                    0 > b && ++b;
                    1 < b && --b;
                    const c = 6 * b;
                    return 1 > c ? r + (f - r) * c : 1 > 2 * b ? f : 2 > 3 * b ? r + (f - r) * (2 / 3 - b) * 6 : r
                }
                const t = {
                    transparent: [0, 0, 0, 0],
                    black: [0, 0, 0, 1],
                    silver: [192, 192, 192, 1],
                    gray: [128, 128, 128, 1],
                    white: [255, 255, 255, 1],
                    maroon: [128, 0, 0, 1],
                    red: [255, 0, 0, 1],
                    purple: [128, 0, 128, 1],
                    fuchsia: [255, 0, 255, 1],
                    green: [0, 128, 0, 1],
                    lime: [0, 255, 0, 1],
                    olive: [128, 128, 0, 1],
                    yellow: [255, 255, 0, 1],
                    navy: [0, 0, 128, 1],
                    blue: [0, 0, 255, 1],
                    teal: [0, 128, 128, 1],
                    aqua: [0, 255, 255, 1],
                    aliceblue: [240, 248,
                        255, 1
                    ],
                    antiquewhite: [250, 235, 215, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169,
                        169, 169, 1
                    ],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30,
                        144, 255, 1
                    ],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230,
                        1
                    ],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    mediumaquamarine: [102, 205, 170,
                        1
                    ],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    oldlace: [253, 245, 230, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238,
                        232, 170, 1
                    ],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    rebeccapurple: [102, 51, 153, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106,
                        90, 205, 1
                    ],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellowgreen: [154, 205, 5, 10]
                };
                a.getNamedColor = k;
                a.getNamedColorCopy = function(r) {
                    return (r = k(r)) ? [...r] : r
                };
                a.hex2rgba = function(r) {
                    var f = 5 < r.length;
                    const b = f ? 8 : 4,
                        c = (1 << b) - 1,
                        g = f ? 1 : 17;
                    f = f ? 9 === r.length : 5 === r.length;
                    r = Number("0x" + r.substr(1));
                    if (isNaN(r)) return null;
                    const e = [0, 0, 0, 1];
                    f && (f = r & c, r >>= b, e[3] = g * f / 255);
                    f = r & c;
                    r >>= b;
                    e[2] = g * f;
                    f = r & c;
                    r >>= b;
                    e[1] = g * f;
                    f = r & c;
                    r >>= b;
                    e[0] = g * f;
                    return e
                };
                a.hsla2rgba = function(r, f, b, c = 1) {
                    r = (r % 360 + 360) % 360 / 360;
                    f = .5 >= b ? b * (f + 1) : b + f - b * f;
                    b = 2 * b - f;
                    return [Math.round(256 * w(b, f, r + 1 / 3)), Math.round(256 * w(b, f, r)), Math.round(256 * w(b, f, r - 1 / 3)), c]
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/mathUtils": function() {
            define(["exports"], function(a) {
                function k(h, p, l) {
                    return h < p ? p : h >
                        l ? l : h
                }

                function w(h, p, l) {
                    return Math.min(Math.max(h, p), l)
                }

                function t(h, p, l) {
                    return h + (p - h) * l
                }

                function r(h) {
                    f[0] = h;
                    return f[0]
                }
                const f = new Float32Array(1),
                    b = Number.isFinite || function(h) {
                        return "number" === typeof h && window.isFinite(h)
                    },
                    c = Number.isNaN || function(h) {
                        return h !== h
                    },
                    g = Math.sign || function(h) {
                        return +(0 < h) - +(0 > h) || +h
                    },
                    e = Math.log2 || function(h) {
                        return Math.log(h) / Math.LN2
                    },
                    d = r(3.4028234663852886E38);
                a.NUMBER_MAX_FLOAT32 = d;
                a.acosClamped = function(h) {
                    return Math.acos(k(h, -1, 1))
                };
                a.asinClamped = function(h) {
                    return Math.asin(k(h, -1, 1))
                };
                a.clamp = k;
                a.clampFloat32 = function(h) {
                    return r(Math.max(-d, Math.min(h, d)))
                };
                a.deg2rad = function(h) {
                    return h * Math.PI / 180
                };
                a.floatEqualAbsolute = function(h, p, l = 1E-6) {
                    return c(h) || c(p) ? !1 : (h > p ? h - p : p - h) <= l
                };
                a.floatEqualRelative = function(h, p, l = 1E-6) {
                    if (c(h) || c(p)) return !1;
                    if (h === p) return !0;
                    const n = Math.abs(h - p),
                        u = Math.abs(h),
                        y = Math.abs(p);
                    if (0 === h || 0 === p || 1E-12 > u && 1E-12 > y) {
                        if (n > .01 * l) return !1
                    } else if (n / (u + y) > l) return !1;
                    return !0
                };
                a.glClamp = w;
                a.isFinite = b;
                a.isNaN = c;
                a.isPowerOfTwo = function(h) {
                    return 0 ===
                        (h & h - 1)
                };
                a.lerp = t;
                a.log2 = e;
                a.nextHighestPowerOfTen = function(h) {
                    return 10 ** Math.ceil(Math.LOG10E * Math.log(h))
                };
                a.nextHighestPowerOfTwo = function(h) {
                    --h;
                    for (let p = 1; 32 > p; p <<= 1) h |= h >> p;
                    return h + 1
                };
                a.nextPowerOfTwo = function(h) {
                    h--;
                    h |= h >> 1;
                    h |= h >> 2;
                    h |= h >> 4;
                    h |= h >> 8;
                    h |= h >> 16;
                    h++;
                    return h
                };
                a.rad2deg = function(h) {
                    return 180 * h / Math.PI
                };
                a.reciprocalClamped = function(h, p = 1E-6) {
                    return (0 > h ? -1 : 1) / Math.max(Math.abs(h), p)
                };
                a.scale = function(h, p, l, n, u) {
                    return t(n, u, (h - p) / (l - p))
                };
                a.sign = g;
                a.smoothstep = function(h, p, l) {
                    h =
                        w((l - h) / (p - h), 0, 1);
                    return h * h * (3 - 2 * h)
                };
                a.step = function(h, p) {
                    return p < h ? 0 : 1
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/expression/expression": function() {
            define("exports ../../../../../chunks/_rollupPluginBabelHelpers ../../../../../Color ../../../../../core/colorUtils ../../../unitBezier ../GeometryUtils ./types".split(" "), function(a, k, w, t, r, f, b) {
                function c(M, J, K) {
                    var O = typeof M;
                    if ("string" === O || "boolean" === O || "number" === O || null === M) {
                        if (K) switch (K.kind) {
                            case "string":
                                "string" !==
                                O && (M = R.toString(M));
                                break;
                            case "number":
                                "number" !== O && (M = R.toNumber(M));
                                break;
                            case "color":
                                M = R.toColor(M)
                        }
                        M = ["literal", M]
                    }
                    if (!Array.isArray(M) || 0 === M.length) throw Error("Expression must be a non empty array");
                    O = M[0];
                    if ("string" !== typeof O) throw Error("First element of expression must be a string");
                    const S = ka[O];
                    if (void 0 === S) throw Error(`Invalid expression operator "${O}"`);
                    if (!S) throw Error(`Unimplemented expression operator "${O}"`);
                    return S.parse(M, J, K)
                }
                let g = function() {
                        function M(K) {
                            this.parent =
                                K;
                            this.vars = {}
                        }
                        var J = M.prototype;
                        J.add = function(K, O) {
                            this.vars[K] = O
                        };
                        J.get = function(K) {
                            return this.vars[K] ? this.vars[K] : this.parent ? this.parent.get(K) : null
                        };
                        return M
                    }(),
                    e = function() {
                        function M() {
                            this.type = b.ValueType
                        }
                        M.parse = function(J) {
                            if (1 < J.length) throw Error('"id" does not expect arguments');
                            return new M
                        };
                        M.prototype.evaluate = function(J, K) {
                            return J.id || null
                        };
                        return M
                    }(),
                    d = function() {
                        function M() {
                            this.type = b.StringType
                        }
                        M.parse = function(J) {
                            if (1 < J.length) throw Error('"geometry-type" does not expect arguments');
                            return new M
                        };
                        M.prototype.evaluate = function(J, K) {
                            switch (J.type) {
                                case 1:
                                    return "Point";
                                case 2:
                                    return "LineString";
                                case 3:
                                    return "Polygon";
                                default:
                                    return null
                            }
                        };
                        return M
                    }(),
                    h = function() {
                        function M() {
                            this.type = b.ObjectType
                        }
                        M.parse = function(J) {
                            if (1 < J.length) throw Error('"properties" does not expect arguments');
                            return new M
                        };
                        M.prototype.evaluate = function(J, K) {
                            return J.values
                        };
                        return M
                    }(),
                    p = function() {
                        function M() {
                            this.type = b.NumberType
                        }
                        M.parse = function(J) {
                            if (1 < J.length) throw Error('"zoom" does not expect arguments');
                            return new M
                        };
                        M.prototype.evaluate = function(J, K) {
                            return K
                        };
                        return M
                    }(),
                    l = function() {
                        function M(J, K, O) {
                            this.lhs = J;
                            this.rhs = K;
                            this.compare = O;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K, O) {
                            if (3 !== J.length && 4 !== J.length) throw Error(`"${J[0]}" expects 2 or 3 arguments`);
                            if (4 === J.length) throw Error(`"${J[0]}" collator not supported`);
                            return new M(c(J[1], K), c(J[2], K), O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            return this.compare(this.lhs.evaluate(J, K), this.rhs.evaluate(J, K))
                        };
                        return M
                    }(),
                    n = function(M) {
                        function J() {
                            return M.apply(this,
                                arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return l.parse(K, O, (S, Z) => S === Z)
                        };
                        return J
                    }(l),
                    u = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return l.parse(K, O, (S, Z) => S !== Z)
                        };
                        return J
                    }(l),
                    y = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return l.parse(K, O, (S, Z) => S < Z)
                        };
                        return J
                    }(l),
                    x = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return l.parse(K, O, (S, Z) => S <= Z)
                        };
                        return J
                    }(l),
                    q = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return l.parse(K, O, (S, Z) => S > Z)
                        };
                        return J
                    }(l),
                    B = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return l.parse(K, O, (S, Z) => S >= Z)
                        };
                        return J
                    }(l),
                    z = function() {
                        function M(J) {
                            this.arg = J;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K) {
                            if (2 !== J.length) throw Error('"!" expects 1 argument');
                            return new M(c(J[1], K))
                        };
                        M.prototype.evaluate = function(J, K) {
                            return !this.arg.evaluate(J, K)
                        };
                        return M
                    }(),
                    v = function() {
                        function M(J) {
                            this.args = J;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K) {
                            const O = [];
                            for (let S = 1; S < J.length; S++) O.push(c(J[S], K));
                            return new M(O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            for (const O of this.args)
                                if (!O.evaluate(J, K)) return !1;
                            return !0
                        };
                        return M
                    }(),
                    A = function() {
                        function M(J) {
                            this.args = J;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K) {
                            const O = [];
                            for (let S = 1; S < J.length; S++) O.push(c(J[S],
                                K));
                            return new M(O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            for (const O of this.args)
                                if (O.evaluate(J, K)) return !0;
                            return !1
                        };
                        return M
                    }(),
                    m = function() {
                        function M(J) {
                            this.args = J;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K) {
                            const O = [];
                            for (let S = 1; S < J.length; S++) O.push(c(J[S], K));
                            return new M(O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            for (const O of this.args)
                                if (O.evaluate(J, K)) return !1;
                            return !0
                        };
                        return M
                    }(),
                    E = function() {
                        function M(J, K, O) {
                            this.type = J;
                            this.args = K;
                            this.fallback = O
                        }
                        M.parse = function(J, K, O) {
                            if (4 > J.length) throw Error('"case" expects at least 3 arguments');
                            if (1 === J.length % 2) throw Error('"case" expects an odd number of arguments');
                            let S;
                            const Z = [];
                            for (let ha = 1; ha < J.length - 1; ha += 2) {
                                const pa = c(J[ha], K),
                                    oa = c(J[ha + 1], K, O);
                                S || (S = oa.type);
                                Z.push({
                                    condition: pa,
                                    output: oa
                                })
                            }
                            J = c(J[J.length - 1], K, O);
                            S || (S = J.type);
                            return new M(S, Z, J)
                        };
                        M.prototype.evaluate = function(J, K) {
                            for (const O of this.args)
                                if (O.condition.evaluate(J, K)) return O.output.evaluate(J, K);
                            return this.fallback.evaluate(J, K)
                        };
                        return M
                    }(),
                    C = function() {
                        function M(J, K) {
                            this.type = J;
                            this.args = K
                        }
                        M.parse = function(J,
                            K) {
                            if (2 > J.length) throw Error('"coalesce" expects at least 1 argument');
                            let O;
                            const S = [];
                            for (let Z = 1; Z < J.length; Z++) {
                                const ha = c(J[Z], K);
                                O || (O = ha.type);
                                S.push(ha)
                            }
                            return new M(O, S)
                        };
                        M.prototype.evaluate = function(J, K) {
                            for (const O of this.args) {
                                const S = O.evaluate(J, K);
                                if (null !== S) return S
                            }
                            return null
                        };
                        return M
                    }(),
                    G = function() {
                        function M(J, K, O, S, Z) {
                            this.type = J;
                            this.input = K;
                            this.labels = O;
                            this.outputs = S;
                            this.fallback = Z
                        }
                        M.parse = function(J, K) {
                            if (3 > J.length) throw Error('"match" expects at least 3 arguments');
                            if (0 === J.length % 2) throw Error('"case" expects an even number of arguments');
                            let O;
                            const S = c(J[1], K),
                                Z = [],
                                ha = {};
                            let pa;
                            for (let ua = 2; ua < J.length - 1; ua += 2) {
                                var oa = J[ua];
                                Array.isArray(oa) || (oa = [oa]);
                                for (const Ca of oa) {
                                    oa = typeof Ca;
                                    if ("string" !== oa && "number" !== oa) throw Error('"match" requires string or number literal as labels');
                                    if (!pa) pa = oa;
                                    else if (oa !== pa) throw Error('"match" requires labels to have the same type');
                                    ha[Ca] = Z.length
                                }
                                oa = c(J[ua + 1], K);
                                O || (O = oa.type);
                                Z.push(oa)
                            }
                            return new M(O, S, ha, Z, c(J[J.length -
                                1], K))
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.input.evaluate(J, K);
                            return (this.outputs[this.labels[O]] || this.fallback).evaluate(J, K)
                        };
                        return M
                    }(),
                    F = function() {
                        function M(K, O, S, Z, ha) {
                            this.operator = K;
                            this.type = O;
                            this.interpolation = S;
                            this.input = Z;
                            this.stops = ha
                        }
                        M.parse = function(K, O, S) {
                            const Z = K[0];
                            if (5 > K.length) throw Error(`"${Z}" expects at least 4 arguments`);
                            const ha = K[1];
                            if (!Array.isArray(ha) || 0 === ha.length) throw Error(`"${ha}" is not a valid interpolation`);
                            switch (ha[0]) {
                                case "linear":
                                    if (1 !==
                                        ha.length) throw Error("Linear interpolation cannot have parameters");
                                    break;
                                case "exponential":
                                    if (2 !== ha.length || "number" !== typeof ha[1]) throw Error("Exponential interpolation requires one numeric argument");
                                    break;
                                case "cubic-bezier":
                                    if (5 !== ha.length) throw Error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1");
                                    for (var pa = 1; 5 > pa; pa++) {
                                        var oa = ha[pa];
                                        if ("number" !== typeof oa || 0 > oa || 1 < oa) throw Error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1");
                                    }
                                    break;
                                default:
                                    throw Error(`"${K[0]}" unknown interpolation type "${ha[0]}"`);
                            }
                            if (1 !== K.length % 2) throw Error(`"${Z}" expects an even number of arguments`);
                            pa = c(K[2], O, b.NumberType);
                            let ua;
                            "interpolate-hcl" === Z || "interpolate-lab" === Z ? ua = b.ColorType : S && "value" !== S.kind && (ua = S);
                            S = [];
                            for (oa = 3; oa < K.length; oa += 2) {
                                const Ca = K[oa];
                                if ("number" !== typeof Ca) throw Error(`"${Z}" requires stop inputs as literal numbers`);
                                if (S.length && S[S.length - 1][0] >= Ca) throw Error(`"${Z}" requires strictly ascending stop inputs`);
                                const Ia = c(K[oa + 1], O, ua);
                                ua || (ua = Ia.type);
                                S.push([Ca, Ia])
                            }
                            if (ua && ua !== b.ColorType && ua !== b.NumberType && ("array" !== ua.kind || ua.itemType !== b.NumberType)) throw Error(`"${Z}" cannot interpolate type ${b.typeToString(ua)}`);
                            return new M(Z, ua, ha, pa, S)
                        };
                        var J = M.prototype;
                        J.evaluate = function(K, O) {
                            var S = this.stops;
                            if (1 === S.length) return S[0][1].evaluate(K, O);
                            var Z = this.input.evaluate(K, O);
                            if (Z <= S[0][0]) return S[0][1].evaluate(K, O);
                            if (Z >= S[S.length - 1][0]) return S[S.length - 1][1].evaluate(K, O);
                            let ha = 0;
                            for (; ++ha <
                                S.length && !(Z < S[ha][0]););
                            const pa = M.interpolationRatio(this.interpolation, Z, S[ha - 1][0], S[ha][0]);
                            Z = S[ha - 1][1].evaluate(K, O);
                            const oa = S[ha][1].evaluate(K, O);
                            if ("interpolate" === this.operator) {
                                if ("array" === this.type.kind && Array.isArray(Z) && Array.isArray(oa)) return Z.map((ua, Ca) => f.interpolate(ua, oa[Ca], pa));
                                if ("color" === this.type.kind && Z instanceof w && oa instanceof w) return Z = new w(Z), K = new w(oa), new w([f.interpolate(Z.r, K.r, pa), f.interpolate(Z.g, K.g, pa), f.interpolate(Z.b, K.b, pa), f.interpolate(Z.a,
                                    K.a, pa)]);
                                if ("number" === this.type.kind && "number" === typeof Z && "number" === typeof oa) return f.interpolate(Z, oa, pa);
                                throw Error(`"${this.operator}" cannot interpolate type ${b.typeToString(this.type)}`);
                            }
                            if ("interpolate-hcl" === this.operator) return K = t.toLCH(Z), O = t.toLCH(oa), S = O.h - K.h, K = t.toRGB({
                                h: K.h + pa * (180 < S || -180 > S ? S - 360 * Math.round(S / 360) : S),
                                c: f.interpolate(K.c, O.c, pa),
                                l: f.interpolate(K.l, O.l, pa)
                            }), new w({
                                a: f.interpolate(Z.a, oa.a, pa),
                                ...K
                            });
                            if ("interpolate-lab" === this.operator) return K = t.toLAB(Z),
                                O = t.toLAB(oa), K = t.toRGB({
                                    l: f.interpolate(K.l, O.l, pa),
                                    a: f.interpolate(K.a, O.a, pa),
                                    b: f.interpolate(K.b, O.b, pa)
                                }), new w({
                                    a: f.interpolate(Z.a, oa.a, pa),
                                    ...K
                                });
                            throw Error(`Unexpected operator "${this.operator}"`);
                        };
                        J.interpolationUniformValue = function(K, O) {
                            const S = this.stops;
                            if (1 === S.length || K >= S[S.length - 1][0]) return 0;
                            let Z = 0;
                            for (; ++Z < S.length && !(K < S[Z][0]););
                            return M.interpolationRatio(this.interpolation, O, S[Z - 1][0], S[Z][0])
                        };
                        J.getInterpolationRange = function(K) {
                            const O = this.stops;
                            if (1 === O.length) return K =
                                O[0][0], [K, K];
                            var S = O[O.length - 1][0];
                            if (K >= S) return [S, S];
                            for (S = 0; ++S < O.length && !(K < O[S][0]););
                            return [O[S - 1][0], O[S][0]]
                        };
                        M.interpolationRatio = function(K, O, S, Z) {
                            let ha = 0;
                            "linear" === K[0] ? ha = M.exponentialInterpolationRatio(O, 1, S, Z) : "exponential" === K[0] ? ha = M.exponentialInterpolationRatio(O, K[1], S, Z) : "cubic-bezier" === K[0] && (ha = r.unitBezier(K[1], K[2], K[3], K[4])(M.exponentialInterpolationRatio(O, 1, S, Z), 1E-5));
                            0 > ha ? ha = 0 : 1 < ha && (ha = 1);
                            return ha
                        };
                        M.exponentialInterpolationRatio = function(K, O, S, Z) {
                            Z -= S;
                            if (0 ===
                                Z) return 0;
                            K -= S;
                            return 1 === O ? K / Z : (O ** K - 1) / (O ** Z - 1)
                        };
                        return M
                    }(),
                    D = function() {
                        function M(J, K, O) {
                            this.type = J;
                            this.input = K;
                            this.stops = O
                        }
                        M.parse = function(J, K) {
                            if (5 > J.length) throw Error('"step" expects at least 4 arguments');
                            if (1 !== J.length % 2) throw Error('"step" expects an even number of arguments');
                            const O = c(J[1], K, b.NumberType);
                            let S;
                            const Z = [];
                            Z.push([-Infinity, c(J[2], K)]);
                            for (let ha = 3; ha < J.length; ha += 2) {
                                const pa = J[ha];
                                if ("number" !== typeof pa) throw Error('"step" requires stop inputs as literal numbers');
                                if (Z.length && Z[Z.length - 1][0] >= pa) throw Error('"step" requires strictly ascending stop inputs');
                                const oa = c(J[ha + 1], K);
                                S || (S = oa.type);
                                Z.push([pa, oa])
                            }
                            return new M(S, O, Z)
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.stops;
                            if (1 === O.length) return O[0][1].evaluate(J, K);
                            const S = this.input.evaluate(J, K);
                            let Z = 0;
                            for (; ++Z < O.length && !(S < O[Z][0]););
                            return this.stops[Z - 1][1].evaluate(J, K)
                        };
                        return M
                    }(),
                    H = function() {
                        function M(J, K) {
                            this.type = J;
                            this.output = K
                        }
                        M.parse = function(J, K, O) {
                            if (4 > J.length) throw Error('"let" expects at least 3 arguments');
                            if (1 === J.length % 2) throw Error('"let" expects an odd number of arguments');
                            const S = new g(K);
                            for (let Z = 1; Z < J.length - 1; Z += 2) {
                                const ha = J[Z];
                                if ("string" !== typeof ha) throw Error(`"let" requires a string to define variable names - found ${ha}`);
                                S.add(ha, c(J[Z + 1], K))
                            }
                            J = c(J[J.length - 1], S, O);
                            return new M(J.type, J)
                        };
                        M.prototype.evaluate = function(J, K) {
                            return this.output.evaluate(J, K)
                        };
                        return M
                    }(),
                    I = function() {
                        function M(J, K) {
                            this.type = J;
                            this.output = K
                        }
                        M.parse = function(J, K, O) {
                            if (2 !== J.length || "string" !== typeof J[1]) throw Error('"var" requires just one literal string argument');
                            K = K.get(J[1]);
                            if (!K) throw Error(`${J[1]} must be defined before being used in a "var" expression`);
                            return new M(O || b.ValueType, K)
                        };
                        M.prototype.evaluate = function(J, K) {
                            return this.output.evaluate(J, K)
                        };
                        return M
                    }(),
                    Q = function() {
                        function M(J, K, O) {
                            this.type = J;
                            this.index = K;
                            this.array = O
                        }
                        M.parse = function(J, K) {
                            if (3 !== J.length) throw Error('"at" expects 2 arguments');
                            const O = c(J[1], K, b.NumberType);
                            J = c(J[2], K);
                            return new M(J.type.itemType, O, J)
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.index.evaluate(J,
                                K);
                            J = this.array.evaluate(J, K);
                            if (0 > O || O >= J.length) throw Error('"at" index out of bounds');
                            if (O !== Math.floor(O)) throw Error('"at" index must be an integer');
                            return J[O]
                        };
                        return M
                    }(),
                    P = function() {
                        function M(J, K) {
                            this.key = J;
                            this.obj = K;
                            this.type = b.ValueType
                        }
                        M.parse = function(J, K) {
                            let O;
                            switch (J.length) {
                                case 2:
                                    return O = c(J[1], K), new M(O);
                                case 3:
                                    return O = c(J[1], K), J = c(J[2], K), new M(O, J);
                                default:
                                    throw Error('"get" expects 1 or 2 arguments');
                            }
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.key.evaluate(J,
                                K);
                            return this.obj ? this.obj.evaluate(J, K)[O] : J.values[O]
                        };
                        return M
                    }(),
                    Y = function() {
                        function M(J, K) {
                            this.key = J;
                            this.obj = K;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K) {
                            let O;
                            switch (J.length) {
                                case 2:
                                    return O = c(J[1], K), new M(O);
                                case 3:
                                    return O = c(J[1], K), J = c(J[2], K), new M(O, J);
                                default:
                                    throw Error('"has" expects 1 or 2 arguments');
                            }
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.key.evaluate(J, K);
                            return this.obj ? (J = this.obj.evaluate(J, K), O in J) : void 0 !== J.values[O]
                        };
                        return M
                    }(),
                    W = function() {
                        function M(J,
                            K) {
                            this.key = J;
                            this.vals = K;
                            this.type = b.BooleanType
                        }
                        M.parse = function(J, K) {
                            if (3 !== J.length) throw Error('"in" expects 2 arguments');
                            return new M(c(J[1], K), c(J[2], K))
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.key.evaluate(J, K);
                            return -1 !== this.vals.evaluate(J, K).indexOf(O)
                        };
                        return M
                    }(),
                    X = function() {
                        function M(J, K, O) {
                            this.item = J;
                            this.array = K;
                            this.from = O;
                            this.type = b.NumberType
                        }
                        M.parse = function(J, K) {
                            if (3 > J.length || 4 < J.length) throw Error('"index-of" expects 3 or 4 arguments');
                            const O = c(J[1], K),
                                S = c(J[2],
                                    K);
                            return 4 === J.length ? (J = c(J[3], K, b.NumberType), new M(O, S, J)) : new M(O, S)
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.item.evaluate(J, K),
                                S = this.array.evaluate(J, K);
                            if (this.from) {
                                J = this.from.evaluate(J, K);
                                if (J !== Math.floor(J)) throw Error('"index-of" index must be an integer');
                                return S.indexOf(O, J)
                            }
                            return S.indexOf(O)
                        };
                        return M
                    }(),
                    ba = function() {
                        function M(J) {
                            this.arg = J;
                            this.type = b.NumberType
                        }
                        M.parse = function(J, K) {
                            if (2 !== J.length) throw Error('"length" expects 2 arguments');
                            J = c(J[1], K);
                            return new M(J)
                        };
                        M.prototype.evaluate = function(J, K) {
                            J = this.arg.evaluate(J, K);
                            if ("string" === typeof J || Array.isArray(J)) return J.length;
                            throw Error('"length" expects string or array');
                        };
                        return M
                    }(),
                    V = function() {
                        function M(J, K, O, S) {
                            this.type = J;
                            this.array = K;
                            this.from = O;
                            this.to = S
                        }
                        M.parse = function(J, K) {
                            if (3 > J.length || 4 < J.length) throw Error('"slice" expects 2 or 3 arguments');
                            const O = c(J[1], K),
                                S = c(J[2], K, b.NumberType);
                            if (S.type !== b.NumberType) throw Error('"slice" index must return a number');
                            if (4 === J.length) {
                                J = c(J[3], K,
                                    b.NumberType);
                                if (J.type !== b.NumberType) throw Error('"slice" index must return a number');
                                return new M(O.type, O, S, J)
                            }
                            return new M(O.type, O, S)
                        };
                        M.prototype.evaluate = function(J, K) {
                            const O = this.array.evaluate(J, K);
                            if (!Array.isArray(O) && "string" !== typeof O) throw Error('"slice" input must be an array or a string');
                            const S = this.from.evaluate(J, K);
                            if (0 > S || S >= O.length) throw Error('"slice" index out of bounds');
                            if (S !== Math.floor(S)) throw Error('"slice" index must be an integer');
                            if (this.to) {
                                J = this.to.evaluate(J,
                                    K);
                                if (0 > J || J >= O.length) throw Error('"slice" index out of bounds');
                                if (J !== Math.floor(J)) throw Error('"slice" index must be an integer');
                                return O.slice(S, J)
                            }
                            return O.slice(S)
                        };
                        return M
                    }(),
                    ca = function() {
                        function M() {
                            this.type = b.BooleanType
                        }
                        M.parse = function(J) {
                            if (1 !== J.length) throw Error('"has-id" expects no arguments');
                            return new M
                        };
                        M.prototype.evaluate = function(J, K) {
                            return void 0 !== J.id
                        };
                        return M
                    }(),
                    ea = function() {
                        function M(J, K) {
                            this.args = J;
                            this.calculate = K;
                            this.type = b.NumberType
                        }
                        M.parse = function(J,
                            K, O) {
                            J = J.slice(1).map(S => c(S, K));
                            return new M(J, O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            let O;
                            this.args && (O = this.args.map(S => S.evaluate(J, K)));
                            return this.calculate(O)
                        };
                        return M
                    }(),
                    sa = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            switch (K.length) {
                                case 2:
                                    return ea.parse(K, O, S => -S[0]);
                                case 3:
                                    return ea.parse(K, O, S => S[0] - S[1]);
                                default:
                                    throw Error('"-" expects 1 or 2 arguments');
                            }
                        };
                        return J
                    }(ea),
                    ma = function(M) {
                        function J() {
                            return M.apply(this,
                                arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return ea.parse(K, O, S => {
                                let Z = 1;
                                for (const ha of S) Z *= ha;
                                return Z
                            })
                        };
                        return J
                    }(ea),
                    ra = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            if (3 === K.length) return ea.parse(K, O, S => S[0] / S[1]);
                            throw Error('"/" expects 2 arguments');
                        };
                        return J
                    }(ea),
                    ta = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            if (3 === K.length) return ea.parse(K, O,
                                S => S[0] % S[1]);
                            throw Error('"%" expects 2 arguments');
                        };
                        return J
                    }(ea),
                    qa = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            if (3 === K.length) return ea.parse(K, O, S => S[0] ** S[1]);
                            throw Error('"^" expects 1 or 2 arguments');
                        };
                        return J
                    }(ea),
                    la = function(M) {
                        function J() {
                            return M.apply(this, arguments) || this
                        }
                        k._inheritsLoose(J, M);
                        J.parse = function(K, O) {
                            return ea.parse(K, O, S => {
                                let Z = 0;
                                for (const ha of S) Z += ha;
                                return Z
                            })
                        };
                        return J
                    }(ea),
                    na = function() {
                        function M(J,
                            K) {
                            this.args = J;
                            this.calculate = K;
                            this.type = b.NumberType
                        }
                        M.parse = function(J, K) {
                            const O = J.slice(1).map(S => c(S, K));
                            return new M(O, M.ops[J[0]])
                        };
                        M.prototype.evaluate = function(J, K) {
                            let O;
                            this.args && (O = this.args.map(S => S.evaluate(J, K)));
                            return this.calculate(O)
                        };
                        return M
                    }();
                na.ops = {
                    abs: M => Math.abs(M[0]),
                    acos: M => Math.acos(M[0]),
                    asin: M => Math.asin(M[0]),
                    atan: M => Math.atan(M[0]),
                    ceil: M => Math.ceil(M[0]),
                    cos: M => Math.cos(M[0]),
                    e: () => Math.E,
                    floor: M => Math.floor(M[0]),
                    ln: M => Math.log(M[0]),
                    ln2: () => Math.LN2,
                    log10: M =>
                        Math.log(M[0]) / Math.LN10,
                    log2: M => Math.log(M[0]) / Math.LN2,
                    max: M => Math.max(...M),
                    min: M => Math.min(...M),
                    pi: () => Math.PI,
                    round: M => Math.round(M[0]),
                    sin: M => Math.sin(M[0]),
                    sqrt: M => Math.sqrt(M[0]),
                    tan: M => Math.tan(M[0])
                };
                let xa = function() {
                        function M(J) {
                            this.args = J;
                            this.type = b.StringType
                        }
                        M.parse = function(J, K) {
                            return new M(J.slice(1).map(O => c(O, K)))
                        };
                        M.prototype.evaluate = function(J, K) {
                            return this.args.map(O => O.evaluate(J, K)).join("")
                        };
                        return M
                    }(),
                    wa = function() {
                        function M(J, K) {
                            this.arg = J;
                            this.calculate = K;
                            this.type =
                                b.StringType
                        }
                        M.parse = function(J, K) {
                            if (2 !== J.length) throw Error(`${J[0]} expects 1 argument`);
                            K = c(J[1], K);
                            return new M(K, M.ops[J[0]])
                        };
                        M.prototype.evaluate = function(J, K) {
                            return this.calculate(this.arg.evaluate(J, K))
                        };
                        return M
                    }();
                wa.ops = {
                    downcase: M => M.toLowerCase(),
                    upcase: M => M.toUpperCase()
                };
                let za = function() {
                        function M(K) {
                            this.args = K;
                            this.type = b.ColorType
                        }
                        M.parse = function(K, O) {
                            if (4 !== K.length) throw Error('"rgb" expects 3 arguments');
                            K = K.slice(1).map(S => c(S, O));
                            return new M(K)
                        };
                        var J = M.prototype;
                        J.evaluate =
                            function(K, O) {
                                const S = this._validate(this.args[0].evaluate(K, O)),
                                    Z = this._validate(this.args[1].evaluate(K, O));
                                K = this._validate(this.args[2].evaluate(K, O));
                                return new w({
                                    r: S,
                                    g: Z,
                                    b: K
                                })
                            };
                        J._validate = function(K) {
                            if ("number" !== typeof K || 0 > K || 255 < K) throw Error(`${K}: invalid color component`);
                            return Math.round(K)
                        };
                        return M
                    }(),
                    Aa = function() {
                        function M(K) {
                            this.args = K;
                            this.type = b.ColorType
                        }
                        M.parse = function(K, O) {
                            if (5 !== K.length) throw Error('"rgba" expects 4 arguments');
                            K = K.slice(1).map(S => c(S, O));
                            return new M(K)
                        };
                        var J = M.prototype;
                        J.evaluate = function(K, O) {
                            const S = this._validate(this.args[0].evaluate(K, O)),
                                Z = this._validate(this.args[1].evaluate(K, O)),
                                ha = this._validate(this.args[2].evaluate(K, O));
                            K = this._validateAlpha(this.args[3].evaluate(K, O));
                            return new w({
                                r: S,
                                g: Z,
                                b: ha,
                                a: K
                            })
                        };
                        J._validate = function(K) {
                            if ("number" !== typeof K || 0 > K || 255 < K) throw Error(`${K}: invalid color component`);
                            return Math.round(K)
                        };
                        J._validateAlpha = function(K) {
                            if ("number" !== typeof K || 0 > K || 1 < K) throw Error(`${K}: invalid alpha color component`);
                            return K
                        };
                        return M
                    }(),
                    ya = function() {
                        function M(J) {
                            this.color = J;
                            this.type = b.arrayType(b.NumberType, 4)
                        }
                        M.parse = function(J, K) {
                            if (2 !== J.length) throw Error('"to-rgba" expects 1 argument');
                            J = c(J[1], K);
                            return new M(J)
                        };
                        M.prototype.evaluate = function(J, K) {
                            return (new w(this.color.evaluate(J, K))).toRgba()
                        };
                        return M
                    }(),
                    L = function() {
                        function M(J, K) {
                            this.type = J;
                            this.args = K
                        }
                        M.parse = function(J, K) {
                            var O = J[0];
                            if (2 > J.length) throw Error(`${O} expects at least one argument`);
                            let S = 1,
                                Z;
                            if ("array" === O) {
                                if (2 < J.length) {
                                    switch (J[1]) {
                                        case "string":
                                            Z =
                                                b.StringType;
                                            break;
                                        case "number":
                                            Z = b.NumberType;
                                            break;
                                        case "boolean":
                                            Z = b.BooleanType;
                                            break;
                                        default:
                                            throw Error('"array" type argument must be string, number or boolean');
                                    }
                                    S++
                                } else Z = b.ValueType;
                                if (3 < J.length) {
                                    var ha = J[2];
                                    if (null !== ha && ("number" !== typeof ha || 0 > ha || ha !== Math.floor(ha))) throw Error('"array" length argument must be a positive integer literal');
                                    S++
                                }
                                Z = b.arrayType(Z, ha)
                            } else switch (O) {
                                case "string":
                                    Z = b.StringType;
                                    break;
                                case "number":
                                    Z = b.NumberType;
                                    break;
                                case "boolean":
                                    Z = b.BooleanType;
                                    break;
                                case "object":
                                    Z = b.ObjectType
                            }
                            for (O = []; S < J.length; S++) ha = c(J[S], K), O.push(ha);
                            return new M(Z, O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            let O;
                            for (const S of this.args) {
                                const Z = S.evaluate(J, K);
                                O = b.getType(Z);
                                if (b.matchType(O, this.type)) return Z
                            }
                            throw Error(`Expected ${b.typeToString(this.type)} but got ${b.typeToString(O)}`);
                        };
                        return M
                    }(),
                    R = function() {
                        function M(J, K) {
                            this.type = J;
                            this.args = K
                        }
                        M.parse = function(J, K) {
                            var O = J[0];
                            const S = M.types[O];
                            if (S === b.BooleanType || S === b.StringType) {
                                if (2 !== J.length) throw Error(`${O} expects one argument`);
                            } else if (2 > J.length) throw Error(`${O} expects at least one argument`);
                            O = [];
                            for (let Z = 1; Z < J.length; Z++) {
                                const ha = c(J[Z], K);
                                O.push(ha)
                            }
                            return new M(S, O)
                        };
                        M.prototype.evaluate = function(J, K) {
                            if (this.type === b.BooleanType) return !!this.args[0].evaluate(J, K);
                            if (this.type === b.StringType) return b.valueToString(this.args[0].evaluate(J, K));
                            if (this.type === b.NumberType) {
                                for (const S of this.args) {
                                    var O = Number(S.evaluate(J, K));
                                    if (!isNaN(O)) return O
                                }
                                return null
                            }
                            if (this.type === b.ColorType) {
                                for (O of this.args) try {
                                    const S =
                                        M.toColor(O.evaluate(J, K));
                                    if (S instanceof w) return S
                                } catch {}
                                return null
                            }
                        };
                        M.toBoolean = function(J) {
                            return !!J
                        };
                        M.toString = function(J) {
                            return b.valueToString(J)
                        };
                        M.toNumber = function(J) {
                            const K = Number(J);
                            if (isNaN(K)) throw Error(`"${J}" is not a number`);
                            return K
                        };
                        M.toColor = function(J) {
                            if (J instanceof w) return J;
                            if ("string" === typeof J) {
                                const K = w.fromString(J);
                                if (K) return K;
                                throw Error(`"${J}" is not a color`);
                            }
                            if (Array.isArray(J)) return w.fromArray(J);
                            throw Error(`"${J}" is not a color`);
                        };
                        return M
                    }();
                R.types = {
                    "to-boolean": b.BooleanType,
                    "to-color": b.ColorType,
                    "to-number": b.NumberType,
                    "to-string": b.StringType
                };
                let U = function() {
                        function M(J) {
                            this.val = J;
                            this.type = b.getType(J)
                        }
                        M.parse = function(J) {
                            if (2 !== J.length) throw Error('"literal" expects 1 argument');
                            return new M(J[1])
                        };
                        M.prototype.evaluate = function(J, K) {
                            return this.val
                        };
                        return M
                    }(),
                    da = function() {
                        function M(J) {
                            this.arg = J;
                            this.type = b.StringType
                        }
                        M.parse = function(J, K) {
                            if (2 !== J.length) throw Error('"typeof" expects 1 argument');
                            return new M(c(J[1],
                                K))
                        };
                        M.prototype.evaluate = function(J, K) {
                            return b.typeToString(b.getType(this.arg.evaluate(J, K)))
                        };
                        return M
                    }();
                const ka = {
                    array: L,
                    "boolean": L,
                    collator: null,
                    format: null,
                    image: null,
                    literal: U,
                    number: L,
                    "number-format": null,
                    object: L,
                    string: L,
                    "to-boolean": R,
                    "to-color": R,
                    "to-number": R,
                    "to-string": R,
                    "typeof": da,
                    accumulated: null,
                    "feature-state": null,
                    "geometry-type": d,
                    id: e,
                    "line-progress": null,
                    properties: h,
                    at: Q,
                    get: P,
                    has: Y,
                    "in": W,
                    "index-of": X,
                    length: ba,
                    slice: V,
                    "!": z,
                    "!\x3d": u,
                    "\x3c": y,
                    "\x3c\x3d": x,
                    "\x3d\x3d": n,
                    "\x3e": q,
                    "\x3e\x3d": B,
                    all: v,
                    any: A,
                    "case": E,
                    coalesce: C,
                    match: G,
                    within: null,
                    interpolate: F,
                    "interpolate-hcl": F,
                    "interpolate-lab": F,
                    step: D,
                    let: H,
                    "var": I,
                    concat: xa,
                    downcase: wa,
                    "is-supported-script": null,
                    "resolved-locale": null,
                    upcase: wa,
                    rgb: za,
                    rgba: Aa,
                    "to-rgba": ya,
                    "-": sa,
                    "*": ma,
                    "/": ra,
                    "%": ta,
                    "^": qa,
                    "+": la,
                    abs: na,
                    acos: na,
                    asin: na,
                    atan: na,
                    ceil: na,
                    cos: na,
                    e: na,
                    floor: na,
                    ln: na,
                    ln2: na,
                    log10: na,
                    log2: na,
                    max: na,
                    min: na,
                    pi: na,
                    round: na,
                    sin: na,
                    sqrt: na,
                    tan: na,
                    zoom: p,
                    "heatmap-density": null,
                    "has-id": ca,
                    none: m
                };
                a.ALL = v;
                a.ANY =
                    A;
                a.Add = la;
                a.Assert = L;
                a.At = Q;
                a.Calculate = na;
                a.Case = E;
                a.Coalesce = C;
                a.Coerce = R;
                a.Concat = xa;
                a.Div = ra;
                a.EQ = n;
                a.GE = B;
                a.GT = q;
                a.GeomType = d;
                a.Get = P;
                a.Has = Y;
                a.HasID = ca;
                a.ID = e;
                a.In = W;
                a.IndexOf = X;
                a.Interpolate = F;
                a.LE = x;
                a.LT = y;
                a.Length = ba;
                a.Let = H;
                a.Literal = U;
                a.Match = G;
                a.Mod = ta;
                a.Mul = ma;
                a.NE = u;
                a.NONE = m;
                a.NOT = z;
                a.Pow = qa;
                a.Properties = h;
                a.Rgb = za;
                a.Rgba = Aa;
                a.Slice = V;
                a.Step = D;
                a.String = wa;
                a.Sub = sa;
                a.ToRgba = ya;
                a.TypeOf = da;
                a.Var = I;
                a.Zoom = p;
                a.createExpression = c;
                a.ops = ka;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/colorUtils": function() {
            define(["exports"], function(a) {
                function k(e, d) {
                    const h = [];
                    let p, l;
                    if (e[0].length !== d.length) throw "dimensions do not match";
                    const n = e.length,
                        u = e[0].length;
                    let y = 0;
                    for (p = 0; p < n; p++) {
                        for (l = y = 0; l < u; l++) y += e[p][l] * d[l];
                        h.push(y)
                    }
                    return h
                }

                function w(e) {
                    e = [e.r / 255, e.g / 255, e.b / 255].map(d => .04045 >= d ? d / 12.92 : ((d + .055) / 1.055) ** 2.4);
                    e = k(c, e);
                    return {
                        x: 100 * e[0],
                        y: 100 * e[1],
                        z: 100 * e[2]
                    }
                }

                function t(e) {
                    e = k(g, [e.x / 100, e.y / 100, e.z / 100]).map(d => Math.min(1, Math.max(.0031308 >= d ? 12.92 * d : 1.055 *
                        d ** (1 / 2.4) - .055, 0)));
                    return {
                        r: Math.round(255 * e[0]),
                        g: Math.round(255 * e[1]),
                        b: Math.round(255 * e[2])
                    }
                }

                function r(e) {
                    e = [e.x / 95.047, e.y / 100, e.z / 108.883].map(d => d > (6 / 29) ** 3 ? d ** (1 / 3) : 1 / 3 * (29 / 6) ** 2 * d + 4 / 29);
                    return {
                        l: 116 * e[1] - 16,
                        a: 500 * (e[0] - e[1]),
                        b: 200 * (e[1] - e[2])
                    }
                }

                function f(e) {
                    const d = e.l;
                    e = [(d + 16) / 116 + e.a / 500, (d + 16) / 116, (d + 16) / 116 - e.b / 200].map(h => h > 6 / 29 ? h ** 3 : 3 * (6 / 29) ** 2 * (h - 4 / 29));
                    return {
                        x: 95.047 * e[0],
                        y: 100 * e[1],
                        z: 108.883 * e[2]
                    }
                }

                function b(e) {
                    if ("r" in e && "g" in e && "b" in e) return e;
                    if ("l" in e && "c" in e && "h" in
                        e) {
                        var d = e.c;
                        var h = e.h;
                        d = {
                            l: e.l,
                            a: d * Math.cos(h),
                            b: d * Math.sin(h)
                        };
                        return t(f(d))
                    }
                    if ("l" in e && "a" in e && "b" in e) return t(f(e));
                    if ("x" in e && "y" in e && "z" in e) return t(e);
                    if ("h" in e && "s" in e && "v" in e) {
                        {
                            h = (e.h + 360) % 360 / 60;
                            d = e.v / 100 * 255;
                            e = e.s / 100 * d;
                            const p = e * (1 - Math.abs(h % 2 - 1));
                            switch (Math.floor(h)) {
                                case 0:
                                    h = {
                                        r: e,
                                        g: p,
                                        b: 0
                                    };
                                    break;
                                case 1:
                                    h = {
                                        r: p,
                                        g: e,
                                        b: 0
                                    };
                                    break;
                                case 2:
                                    h = {
                                        r: 0,
                                        g: e,
                                        b: p
                                    };
                                    break;
                                case 3:
                                    h = {
                                        r: 0,
                                        g: p,
                                        b: e
                                    };
                                    break;
                                case 4:
                                    h = {
                                        r: p,
                                        g: 0,
                                        b: e
                                    };
                                    break;
                                case 5:
                                case 6:
                                    h = {
                                        r: e,
                                        g: 0,
                                        b: p
                                    };
                                    break;
                                default:
                                    h = {
                                        r: 0,
                                        g: 0,
                                        b: 0
                                    }
                            }
                            h.r =
                                Math.round(h.r + d - e);
                            h.g = Math.round(h.g + d - e);
                            h.b = Math.round(h.b + d - e);
                            d = h
                        }
                        return d
                    }
                    return e
                }
                const c = [
                        [.4124, .3576, .1805],
                        [.2126, .7152, .0722],
                        [.0193, .1192, .9505]
                    ],
                    g = [
                        [3.2406, -1.5372, -.4986],
                        [-.9689, 1.8758, .0415],
                        [.0557, -.204, 1.057]
                    ];
                a.darken = function(e, d) {
                    e = r(w(e));
                    e.l *= 1 - d;
                    return t(f(e))
                };
                a.toHSV = function(e) {
                    if ("h" in e && "s" in e && "v" in e) return e;
                    var d = b(e); {
                        e = d.r;
                        const h = d.g,
                            p = d.b;
                        d = Math.max(e, h, p);
                        const l = d - Math.min(e, h, p);
                        e = 0 === l ? 0 : d === e ? (h - p) / l % 6 : d === h ? (p - e) / l + 2 : (e - h) / l + 4;
                        0 > e && (e += 6);
                        e = {
                            h: 60 * e,
                            s: 100 *
                                (0 === l ? 0 : l / d),
                            v: 100 / 255 * d
                        }
                    }
                    return e
                };
                a.toLAB = function(e) {
                    return "l" in e && "a" in e && "b" in e ? e : r(w(b(e)))
                };
                a.toLCH = function(e) {
                    if (!("l" in e && "c" in e && "h" in e)) {
                        {
                            var d = r(w(b(e)));
                            e = d.l;
                            var h = d.a;
                            const p = d.b;
                            d = Math.sqrt(h * h + p * p);
                            h = Math.atan2(p, h);
                            h = 0 < h ? h : h + 2 * Math.PI;
                            e = {
                                l: e,
                                c: d,
                                h
                            }
                        }
                    }
                    return e
                };
                a.toRGB = b;
                a.toXYZ = function(e) {
                    return "x" in e && "y" in e && "z" in e ? e : w(b(e))
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/unitBezier": function() {
            define(["exports"], function(a) {
                function k(r, f, b, c) {
                    function g(u,
                        y) {
                        var x;
                        let q, B;
                        q = u;
                        for (x = 0; 8 > x; x++) {
                            B = ((h * q + d) * q + e) * q - u;
                            if (Math.abs(B) < y) return q;
                            var z = (3 * h * q + 2 * d) * q + e;
                            if (1E-6 > Math.abs(z)) break;
                            q -= B / z
                        }
                        z = 0;
                        x = 1;
                        q = u;
                        if (q < z) return z;
                        if (q > x) return x;
                        for (; z < x;) {
                            B = ((h * q + d) * q + e) * q;
                            if (Math.abs(B - u) < y) break;
                            u > B ? z = q : x = q;
                            q = .5 * (x - z) + z
                        }
                        return q
                    }
                    const e = 3 * r,
                        d = 3 * (b - r) - e,
                        h = 1 - e - d,
                        p = 3 * f,
                        l = 3 * (c - f) - p,
                        n = 1 - p - l;
                    return function(u, y = 1E-6) {
                        u = g(u, y);
                        return ((n * u + l) * u + p) * u
                    }
                }
                const w = /^cubic-bezier\((.*)\)/,
                    t = {};
                t.ease = k(.25, .1, .25, 1);
                t.linear = k(0, 0, 1, 1);
                t.easeIn = t["ease-in"] = k(.42, 0, 1, 1);
                t.easeOut = t["ease-out"] = k(0, 0, .58, 1);
                t.easeInOut = t["ease-in-out"] = k(.42, 0, .58, 1);
                a.easingFunctions = t;
                a.parse = function(r) {
                    let f = t[r] || null;
                    !f && (r = w.exec(r)) && (r = r[1].split(",").map(b => parseFloat(b.trim())), 4 !== r.length || r.some(b => isNaN(b)) || (f = k.apply(k, r)));
                    return f
                };
                a.unitBezier = k;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/GeometryUtils": function() {
            define(["exports"], function(a) {
                function k(c, g) {
                    c %= g;
                    return 0 <= c ? c : c + g
                }
                const w = Number.POSITIVE_INFINITY,
                    t = Math.PI,
                    r = 128 / t,
                    f = 256 / 360,
                    b = 1 / Math.LN2;
                a.C_256_TO_RAD = t / 128;
                a.C_2PI = 2 * t;
                a.C_DEG_TO_256 = f;
                a.C_DEG_TO_RAD = t / 180;
                a.C_INFINITY = w;
                a.C_PI = t;
                a.C_PI_BY_2 = t / 2;
                a.C_RAD_TO_256 = r;
                a.C_SQRT2 = 1.414213562;
                a.C_SQRT2_INV = 1 / 1.414213562;
                a.between = function(c, g, e) {
                    return c >= g && c <= e || c >= e && c <= g
                };
                a.degToByte = function(c) {
                    return k(c * f, 256)
                };
                a.interpolate = function(c, g, e) {
                    return c * (1 - e) + g * e
                };
                a.log2 = function(c) {
                    return Math.log(c) * b
                };
                a.positiveMod = k;
                a.radToByte = function(c) {
                    return k(c * r, 256)
                };
                a.sqr = function(c) {
                    return c * c
                };
                Object.defineProperty(a,
                    "__esModule", {
                        value: !0
                    })
            })
        },
        "esri/views/2d/engine/vectorTiles/style/StyleDefinition": function() {
            define(["exports"], function(a) {
                let k = function() {};
                k.backgroundLayoutDefinition = {
                    visibility: {
                        type: "enum",
                        values: ["visible", "none"],
                        default: 0
                    }
                };
                k.fillLayoutDefinition = {
                    visibility: {
                        type: "enum",
                        values: ["visible", "none"],
                        default: 0
                    }
                };
                k.lineLayoutDefinition = {
                    visibility: {
                        type: "enum",
                        values: ["visible", "none"],
                        default: 0
                    },
                    "line-cap": {
                        type: "enum",
                        values: ["butt", "round", "square"],
                        default: 0
                    },
                    "line-join": {
                        type: "enum",
                        values: ["bevel", "round", "miter"],
                        default: 2
                    },
                    "line-miter-limit": {
                        type: "number",
                        default: 2
                    },
                    "line-round-limit": {
                        type: "number",
                        default: 1.05
                    }
                };
                k.symbolLayoutDefinition = {
                    visibility: {
                        type: "enum",
                        values: ["visible", "none"],
                        default: 0
                    },
                    "symbol-avoid-edges": {
                        type: "boolean",
                        default: !1
                    },
                    "symbol-placement": {
                        type: "enum",
                        values: ["point", "line", "line-center"],
                        default: 0
                    },
                    "symbol-sort-key": {
                        type: "number",
                        default: -1
                    },
                    "symbol-spacing": {
                        type: "number",
                        minimum: 1,
                        default: 250
                    },
                    "icon-allow-overlap": {
                        type: "boolean",
                        default: !1
                    },
                    "icon-anchor": {
                        type: "enum",
                        values: "center left right top bottom top-left top-right bottom-left bottom-right".split(" "),
                        default: 0
                    },
                    "icon-ignore-placement": {
                        type: "boolean",
                        default: !1
                    },
                    "icon-image": {
                        type: "string"
                    },
                    "icon-keep-upright": {
                        type: "boolean",
                        default: !1
                    },
                    "icon-offset": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "icon-optional": {
                        type: "boolean",
                        default: !1
                    },
                    "icon-padding": {
                        type: "number",
                        minimum: 0,
                        default: 2
                    },
                    "icon-rotate": {
                        type: "number",
                        default: 0
                    },
                    "icon-rotation-alignment": {
                        type: "enum",
                        values: ["map", "viewport", "auto"],
                        default: 2
                    },
                    "icon-size": {
                        type: "number",
                        minimum: 0,
                        default: 1
                    },
                    "text-allow-overlap": {
                        type: "boolean",
                        default: !1
                    },
                    "text-anchor": {
                        type: "enum",
                        values: "center left right top bottom top-left top-right bottom-left bottom-right".split(" "),
                        default: 0
                    },
                    "text-field": {
                        type: "string"
                    },
                    "text-font": {
                        type: "array",
                        value: "string",
                        default: ["Open Sans Regular", "Arial Unicode MS Regular"]
                    },
                    "text-ignore-placement": {
                        type: "boolean",
                        default: !1
                    },
                    "text-justify": {
                        type: "enum",
                        values: ["auto", "left",
                            "center", "right"
                        ],
                        default: 2
                    },
                    "text-keep-upright": {
                        type: "boolean",
                        default: !0
                    },
                    "text-letter-spacing": {
                        type: "number",
                        default: 0
                    },
                    "text-line-height": {
                        type: "number",
                        default: 1.2
                    },
                    "text-max-angle": {
                        type: "number",
                        minimum: 0,
                        default: 45
                    },
                    "text-max-width": {
                        type: "number",
                        minimum: 0,
                        default: 10
                    },
                    "text-offset": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "text-optional": {
                        type: "boolean",
                        default: !1
                    },
                    "text-padding": {
                        type: "number",
                        minimum: 0,
                        default: 2
                    },
                    "text-rotate": {
                        type: "number",
                        default: 0
                    },
                    "text-rotation-alignment": {
                        type: "enum",
                        values: ["map", "viewport", "auto"],
                        default: 2
                    },
                    "text-size": {
                        type: "number",
                        minimum: 0,
                        default: 16
                    },
                    "text-transform": {
                        type: "enum",
                        values: ["none", "uppercase", "lowercase"],
                        default: 0
                    },
                    "text-writing-mode": {
                        type: "array",
                        value: "enum",
                        values: ["horizontal", "vertical"],
                        default: [0]
                    }
                };
                k.circleLayoutDefinition = {
                    visibility: {
                        type: "enum",
                        values: ["visible", "none"],
                        default: 0
                    }
                };
                k.backgroundPaintDefinition = {
                    "background-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "background-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "background-pattern": {
                        type: "string"
                    }
                };
                k.fillPaintDefinition = {
                    "fill-antialias": {
                        type: "boolean",
                        default: !0
                    },
                    "fill-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "fill-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "fill-outline-color": {
                        type: "color",
                        default: [0, 0, 0, 0]
                    },
                    "fill-pattern": {
                        type: "string"
                    },
                    "fill-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "fill-translate-anchor": {
                        type: "enum",
                        values: ["map", "viewport"],
                        default: 0
                    }
                };
                k.linePaintDefinition = {
                    "line-blur": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "line-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "line-dasharray": {
                        type: "array",
                        value: "number",
                        default: []
                    },
                    "line-gap-width": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "line-offset": {
                        type: "number",
                        default: 0
                    },
                    "line-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "line-pattern": {
                        type: "string"
                    },
                    "line-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "line-translate-anchor": {
                        type: "enum",
                        values: ["map", "viewport"],
                        default: 0
                    },
                    "line-width": {
                        type: "number",
                        minimum: 0,
                        default: 1
                    }
                };
                k.symbolPaintDefinition = {
                    "icon-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "icon-halo-blur": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "icon-halo-color": {
                        type: "color",
                        default: [0, 0, 0, 0]
                    },
                    "icon-halo-width": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "icon-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "icon-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "icon-translate-anchor": {
                        type: "enum",
                        values: ["map", "viewport"],
                        default: 0
                    },
                    "text-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "text-halo-blur": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "text-halo-color": {
                        type: "color",
                        default: [0, 0, 0, 0]
                    },
                    "text-halo-width": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "text-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "text-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "text-translate-anchor": {
                        type: "enum",
                        values: ["map", "viewport"],
                        default: 0
                    }
                };
                k.rasterPaintDefinition = {
                    "raster-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "raster-hue-rotate": {
                        type: "number",
                        default: 0
                    },
                    "raster-brightness-min": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 0
                    },
                    "raster-brightness-max": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "raster-saturation": {
                        type: "number",
                        minimum: -1,
                        maximum: 1,
                        default: 0
                    },
                    "raster-contrast": {
                        type: "number",
                        minimum: -1,
                        maximum: 1,
                        default: 0
                    },
                    "raster-fade-duration": {
                        type: "number",
                        minimum: 0,
                        default: 300
                    }
                };
                k.circlePaintDefinition = {
                    "circle-blur": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "circle-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "circle-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "circle-radius": {
                        type: "number",
                        minimum: 0,
                        default: 5
                    },
                    "circle-stroke-color": {
                        type: "color",
                        default: [0, 0, 0, 1]
                    },
                    "circle-stroke-opacity": {
                        type: "number",
                        minimum: 0,
                        maximum: 1,
                        default: 1
                    },
                    "circle-stroke-width": {
                        type: "number",
                        minimum: 0,
                        default: 0
                    },
                    "circle-translate": {
                        type: "array",
                        value: "number",
                        length: 2,
                        default: [0, 0]
                    },
                    "circle-translate-anchor": {
                        type: "enum",
                        values: ["map", "viewport"],
                        default: 0
                    }
                };
                a.StyleDefinition = k;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/style/StyleProperty": function() {
            define(["../../../../../Color",
                "../GeometryUtils", "../expression/types", "../expression/expression"
            ], function(a, k, w, t) {
                return function() {
                    function r(b, c) {
                        this.isDataDriven = !1;
                        this.interpolator = null;
                        switch (b.type) {
                            case "number":
                                var g = !0;
                                break;
                            case "color":
                                g = !0;
                                break;
                            case "array":
                                g = "number" === b.value;
                                break;
                            default:
                                g = !1
                        }
                        null == c && (c = b.default);
                        if (Array.isArray(c) && 0 < c.length && t.ops[c[0]]) {
                            g = {
                                number: w.NumberType,
                                color: w.ColorType,
                                string: w.StringType,
                                boolean: w.BooleanType,
                                enum: w.StringType
                            };
                            try {
                                var e = "array" === b.type ? w.arrayType(g[b.value] ||
                                    w.ValueType, b.length) : g[b.type];
                                const d = t.createExpression(c, null, e);
                                this.getValue = this._buildExpression(d, b);
                                this.isDataDriven = !0;
                                d instanceof t.Interpolate && d.input instanceof t.Zoom && (this.interpolator = d)
                            } catch (d) {
                                console.log(d.message), this.getValue = this._buildSimple(b.default)
                            }
                        } else {
                            g && "interval" === c.type && (g = !1);
                            if (e = c && c.stops && 0 < c.stops.length)
                                for (const d of c.stops) d[1] = this._validate(d[1], b);
                            if (this.isDataDriven = c ? !!c.property : !1)
                                if (void 0 !== c.default && (c.default = this._validate(c.default,
                                        b)), e) switch (c.type) {
                                    case "identity":
                                        this.getValue = this._buildIdentity(c, b);
                                        break;
                                    case "categorical":
                                        this.getValue = this._buildCategorical(c, b);
                                        break;
                                    default:
                                        this.getValue = g ? this._buildInterpolate(c, b) : this._buildInterval(c, b)
                                } else this.getValue = this._buildIdentity(c, b);
                                else e ? this.getValue = g ? this._buildZoomInterpolate(c) : this._buildZoomInterval(c) : (c = this._validate(c, b), this.getValue = this._buildSimple(c))
                        }
                    }
                    var f = r.prototype;
                    f._validate = function(b, c) {
                        if ("number" === c.type) {
                            if (b < c.minimum) return c.minimum;
                            if (b > c.maximum) return c.maximum
                        } else "color" === c.type ? b = r._parseColor(b) : "enum" === c.type ? "string" === typeof b && (b = c.values.indexOf(b)) : "array" === c.type && "enum" === c.value ? b = b.map(g => "string" === typeof b ? c.values.indexOf(g) : g) : "string" === c.type && (b = w.valueToString(b));
                        return b
                    };
                    f._buildSimple = function(b) {
                        return () => b
                    };
                    f._buildExpression = function(b, c) {
                        return (g, e) => {
                            try {
                                const d = b.evaluate(e, g);
                                return void 0 === d ? c.default : this._validate(d, c)
                            } catch (d) {
                                return console.log(d.message), c.default
                            }
                        }
                    };
                    f._buildIdentity =
                        function(b, c) {
                            return (g, e) => {
                                let d;
                                e && (d = e.values[b.property]);
                                return void 0 !== d ? this._validate(d, c) : void 0 !== b.default ? b.default : c.default
                            }
                        };
                    f._buildCategorical = function(b, c) {
                        return (g, e) => {
                            let d;
                            e && (d = e.values[b.property]);
                            d = this._categorical(d, b.stops);
                            return void 0 !== d ? d : void 0 !== b.default ? b.default : c.default
                        }
                    };
                    f._buildInterval = function(b, c) {
                        return (g, e) => {
                            let d;
                            e && (d = e.values[b.property]);
                            return "number" === typeof d ? this._interval(d, b.stops) : void 0 !== b.default ? b.default : c.default
                        }
                    };
                    f._buildInterpolate =
                        function(b, c) {
                            return (g, e) => {
                                let d;
                                e && (d = e.values[b.property]);
                                return "number" === typeof d ? this._interpolate(d, b.stops, b.base || 1) : void 0 !== b.default ? b.default : c.default
                            }
                        };
                    f._buildZoomInterpolate = function(b) {
                        return c => this._interpolate(c, b.stops, b.base || 1)
                    };
                    f._buildZoomInterval = function(b) {
                        return c => this._interval(c, b.stops)
                    };
                    f._categorical = function(b, c) {
                        const g = c.length;
                        for (let e = 0; e < g; e++)
                            if (c[e][0] === b) return c[e][1]
                    };
                    f._interval = function(b, c) {
                        const g = c.length;
                        let e = 0;
                        for (let d = 0; d < g; d++)
                            if (c[d][0] <=
                                b) e = d;
                            else break;
                        return c[e][1]
                    };
                    f._interpolate = function(b, c, g) {
                        const e = c.length;
                        for (let p = 0; p < e; p++) {
                            const l = c[p];
                            if (l[0] <= b) var d = l;
                            else {
                                var h = l;
                                break
                            }
                        }
                        if (d && h) {
                            c = h[0] - d[0];
                            b -= d[0];
                            g = 1 === g ? b / c : (g ** b - 1) / (g ** c - 1);
                            if (Array.isArray(d[1])) {
                                d = d[1];
                                h = h[1];
                                b = [];
                                for (c = 0; c < d.length; c++) b.push(k.interpolate(d[c], h[c], g));
                                return b
                            }
                            return k.interpolate(d[1], h[1], g)
                        }
                        if (d) return d[1];
                        if (h) return h[1]
                    };
                    r._isEmpty = function(b) {
                        for (const c in b)
                            if (b.hasOwnProperty(c)) return !1;
                        return !0
                    };
                    r._parseColor = function(b) {
                        if (Array.isArray(b)) return b;
                        "string" === typeof b && (b = new a(b));
                        if (b instanceof a) {
                            if (!this._isEmpty(b)) return a.toUnitRGBA(b)
                        } else return b
                    };
                    return r
                }()
            })
        },
        "esri/views/2d/engine/webgl/definitions": function() {
            define(["exports"], function(a) {
                a.ANGLE_FACTOR_256 = 256 / 360;
                a.ATTRIBUTE_DATA_ANIMATION = 1;
                a.ATTRIBUTE_DATA_DD0 = 3;
                a.ATTRIBUTE_DATA_DD1 = 3;
                a.ATTRIBUTE_DATA_FILTER_FLAGS = 0;
                a.ATTRIBUTE_DATA_VV = 2;
                a.ATTRIBUTE_STORE_TEXTURE_SIZE = 1024;
                a.AVERAGE_GLYPH_MOSAIC_ITEM = {
                    metrics: {
                        width: 15,
                        height: 17,
                        left: 0,
                        top: -7,
                        advance: 14
                    }
                };
                a.BUFFER_DATA_MINIMUM_SIZE =
                    128;
                a.BUFFER_DATA_POOL_SIZE = 4;
                a.COLLISION_BOX_PADDING = 16;
                a.COLLISION_BUCKET_SIZE = 128;
                a.COLLISION_EARLY_REJECT_BUCKET_SIZE = 16;
                a.COLLISION_MAX_ZOOM_DELTA = 1;
                a.COLLISION_PLACEMENT_PADDING = 8;
                a.COLLISION_TILE_BOX_SIZE = 4;
                a.DEBUG_LABELS = !1;
                a.DISPLAY_RECORD_INT_PER_ELEMENT = 7;
                a.DOT_DENSITY_MAX_FIELDS = 8;
                a.EFFECT_FLAG_0 = 4;
                a.ENABLE_EARLY_LABEL_DISCARD = !1;
                a.EXTRUDE_SCALE = 64;
                a.FILTER_FLAG_0 = 2;
                a.GLYPH_SIZE = 24;
                a.HEURISTIC_GLYPHS_PER_FEATURE = 10;
                a.HEURISTIC_GLYPHS_PER_LINE = 50;
                a.HIGHLIGHT_FLAG = 1;
                a.HITTEST_SEARCH_SIZE =
                    6;
                a.MAGIC_LABEL_LINE_HEIGHT = 29;
                a.MAX_FILTERS = 2;
                a.MAX_GPU_UPLOADS_PER_FRAME = 2;
                a.NAN_MAGIC_NUMBER = 1E-30;
                a.PATCH_PIXEL_BUFFER_ALLOC_SIZE = 500;
                a.PICTURE_FILL_COLOR = 4294967295;
                a.RASTER_TILE_SIZE = 256;
                a.SPRITE_PADDING = 2;
                a.TEXTURE_BINDING_ATTRIBUTE_DATA_0 = 1;
                a.TEXTURE_BINDING_ATTRIBUTE_DATA_1 = 2;
                a.TEXTURE_BINDING_ATTRIBUTE_DATA_2 = 3;
                a.TEXTURE_BINDING_ATTRIBUTE_DATA_3 = 4;
                a.TEXTURE_BINDING_BITMAP = 0;
                a.TEXTURE_BINDING_GLYPH_ATLAS = 0;
                a.TEXTURE_BINDING_HIGHLIGHT_0 = 5;
                a.TEXTURE_BINDING_HIGHLIGHT_1 = 6;
                a.TEXTURE_BINDING_RENDERER_0 =
                    5;
                a.TEXTURE_BINDING_RENDERER_1 = 6;
                a.TEXTURE_BINDING_SPRITE_ATLAS = 0;
                a.TEXT_PLACEMENT_PADDING = 8;
                a.THIN_LINE_THRESHOLD = 2.5;
                a.TILE_SIZE = 512;
                a.VTL_HIGH_RES_CUTOFF = 1.15;
                a.VTL_TEXTURE_BINDING_UNIT_GLYPHS = 6;
                a.VTL_TEXTURE_BINDING_UNIT_SPRITES = 5;
                a.WEBGL_MAX_INNER_STOPS = 6;
                a.WEBGL_MAX_STOPS = 8;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/WorkerTile": function() {
            define(["../../../../core/maybe", "../../../../core/promiseUtils", "../../tiling/enums", "./Placement", "./TileParser"],
                function(a, k, w, t, r) {
                    return function() {
                        function f(c, g, e, d) {
                            this.status = w.TileStatus.INITIALIZED;
                            this.placementEngine = new t.PlacementEngine;
                            this.tileKey = c;
                            this.refKeys = g;
                            this._workerTileHandler = e;
                            this._styleRepository = d
                        }
                        var b = f.prototype;
                        b.release = function() {
                            this.tileKey = "";
                            this.refKeys = null;
                            this.status = w.TileStatus.INITIALIZED;
                            this._workerTileHandler = null
                        };
                        b.parse = async function(c, g, e) {
                            const d = e && e.signal;
                            if (a.isSome(d)) {
                                const p = () => {
                                    d.removeEventListener("abort", p);
                                    this.status = w.TileStatus.INVALID
                                };
                                d.addEventListener("abort", p)
                            }
                            try {
                                var h = await this._parse(c, e)
                            } catch (p) {
                                if (k.isAbortError(p)) throw p;
                                return {
                                    result: [],
                                    transferList: []
                                }
                            }
                            this.status = w.TileStatus.READY;
                            c = [];
                            for (const p of h) h = p.serialize(), c.push(h);
                            return {
                                result: c,
                                transferList: c.length <= g && c
                            }
                        };
                        b.setObsolete = function() {
                            this.status = w.TileStatus.INVALID
                        };
                        b.getLayers = function() {
                            return this._workerTileHandler.getLayers()
                        };
                        b.getWorkerTileHandler = function() {
                            return this._workerTileHandler
                        };
                        b._parse = async function(c, g) {
                            const e = c.sourceName2DataAndRefKey;
                            if (0 === Object.keys(e).length) return [];
                            this.status = w.TileStatus.MODIFIED;
                            return (new r(e, this, g.client, this._styleRepository, c.styleLayerUIDs)).parse(g)
                        };
                        return f
                    }()
                })
        },
        "esri/views/2d/tiling/enums": function() {
            define(["exports"], function(a) {
                var k = a.TileStatus || (a.TileStatus = {});
                k[k.INITIALIZED = 0] = "INITIALIZED";
                k[k.NO_DATA = 1] = "NO_DATA";
                k[k.READY = 2] = "READY";
                k[k.MODIFIED = 3] = "MODIFIED";
                k[k.INVALID = 4] = "INVALID";
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/Placement": function() {
            define(["exports",
                "./GeometryUtils", "./decluttering/config", "../webgl/Geometry", "./TextShaping"
            ], function(a, k, w, t, r) {
                let f = function(e, d, h, p, l, n = .5, u = k.C_INFINITY) {
                        this.anchor = e;
                        this.labelAngle = d;
                        this.glyphAngle = h;
                        this.page = p;
                        this.alternateVerticalGlyph = l;
                        this.minzoom = n;
                        this.maxzoom = u
                    },
                    b = function(e, d, h, p, l, n, u, y, x, q, B, z) {
                        this.tl = e;
                        this.tr = d;
                        this.bl = h;
                        this.br = p;
                        this.mosaicRect = l;
                        this.labelAngle = n;
                        this.minAngle = u;
                        this.maxAngle = y;
                        this.anchor = x;
                        this.minzoom = q;
                        this.maxzoom = B;
                        this.page = z
                    },
                    c = function(e) {
                        this.shapes = e
                    },
                    g = function() {
                        function e() {}
                        var d = e.prototype;
                        d.getIconPlacement = function(h, p, l) {
                            const n = new t.Point(h.x, h.y),
                                u = 0 === l.rotationAlignment,
                                y = l.keepUpright;
                            let x = l.rotate * k.C_DEG_TO_RAD;
                            u && (x += h.angle);
                            h = new c([]);
                            l.allowOverlap && l.ignorePlacement || !w.DECLUTTER_TILES || (h.iconColliders = []);
                            this._addIconPlacement(h, n, p, l, x);
                            u && y && this._addIconPlacement(h, n, p, l, x + k.C_PI);
                            return h
                        };
                        d._addIconPlacement = function(h, p, l, n, u) {
                            var y = l.pixelRatio;
                            const x = l.width / y,
                                q = l.height / y;
                            var B = n.offset;
                            let z = B[0];
                            B = B[1];
                            switch (n.anchor) {
                                case 0:
                                    z -= x /
                                        2;
                                    B -= q / 2;
                                    break;
                                case 1:
                                    B -= q / 2;
                                    break;
                                case 2:
                                    z -= x;
                                    B -= q / 2;
                                    break;
                                case 3:
                                    z -= x / 2;
                                    break;
                                case 4:
                                    z -= x / 2;
                                    B -= q;
                                    break;
                                case 7:
                                    B -= q;
                                    break;
                                case 6:
                                    z -= x;
                                    break;
                                case 8:
                                    z -= x, B -= q
                            }
                            l = l.rect;
                            var v = 2 / y,
                                A = z - v,
                                m = B - v,
                                E = A + l.width / y,
                                C = m + l.height / y;
                            y = new t.Point(A, m);
                            v = new t.Point(E, C);
                            A = new t.Point(A, C);
                            m = new t.Point(E, m);
                            0 !== u && (E = Math.cos(u), C = Math.sin(u), y.rotate(E, C), v.rotate(E, C), A.rotate(E, C), m.rotate(E, C));
                            l = new b(y, m, A, v, l, u, 0, 256, p, .5, k.C_INFINITY, 0);
                            h.shapes.push(l);
                            n.allowOverlap && n.ignorePlacement || !w.DECLUTTER_TILES ||
                                (l = n.size, y = n.padding, h.iconColliders.push({
                                    xTile: p.x,
                                    yTile: p.y,
                                    dxPixels: z * l - y,
                                    dyPixels: B * l - y,
                                    hard: !n.optional,
                                    partIndex: 0,
                                    width: x * l + 2 * y,
                                    height: q * l + 2 * y,
                                    angle: u,
                                    minLod: .5,
                                    maxLod: k.C_INFINITY
                                }))
                        };
                        d.getTextPlacement = function(h, p, l, n) {
                            var u = new t.Point(h.x, h.y);
                            const y = n.rotate * k.C_DEG_TO_RAD;
                            var x = 0 === n.rotationAlignment;
                            const q = n.keepUpright,
                                B = n.padding;
                            let z = .5;
                            const v = x ? h.angle : 0,
                                A = 0 <= h.segment && x,
                                m = n.allowOverlap && n.ignorePlacement ? null : [],
                                E = [],
                                C = !A;
                            var G = Number.POSITIVE_INFINITY;
                            let F = Number.NEGATIVE_INFINITY,
                                D = G,
                                H = F;
                            const I = A ? q : x && q,
                                Q = n.size / r.SDF_GLYPH_SIZE;
                            let P = !1;
                            for (var Y of p)
                                if (Y.vertical) {
                                    P = !0;
                                    break
                                }
                            let W = 0;
                            Y = 0;
                            if (!A && P) {
                                var X = r.TextShaping.getTextBox(p, n.lineHeight * r.SDF_GLYPH_SIZE);
                                switch (n.anchor) {
                                    case 1:
                                        W = X.height / 2;
                                        Y = -X.width / 2;
                                        break;
                                    case 2:
                                        W = -X.height / 2;
                                        Y = X.width / 2;
                                        break;
                                    case 3:
                                        W = X.height / 2;
                                        Y = X.width / 2;
                                        break;
                                    case 4:
                                        W = -X.height / 2;
                                        Y = -X.width / 2;
                                        break;
                                    case 5:
                                        W = X.height;
                                        break;
                                    case 7:
                                        Y = -X.width;
                                        break;
                                    case 6:
                                        Y = X.width;
                                        break;
                                    case 8:
                                        W = -X.height
                                }
                            }
                            W += n.offset[0] * r.SDF_GLYPH_SIZE;
                            Y += n.offset[1] * r.SDF_GLYPH_SIZE;
                            for (const qa of p) {
                                var ba = qa.glyphMosaicItem;
                                if (!ba || ba.rect.isEmpty) continue;
                                p = ba.rect;
                                X = ba.metrics;
                                var V = ba.page;
                                if (m && C) {
                                    if (void 0 !== sa && sa !== qa.y) {
                                        var ca = void 0,
                                            ea = void 0;
                                        if (P) {
                                            var sa = -H + W;
                                            ca = G + Y;
                                            ea = H - D;
                                            G = F - G
                                        } else sa = G + W, ca = D + Y, ea = F - G, G = H - D;
                                        m.push({
                                            xTile: h.x,
                                            yTile: h.y,
                                            dxPixels: sa * Q - B,
                                            dyPixels: ca * Q - B,
                                            hard: !n.optional,
                                            partIndex: 1,
                                            width: ea * Q + 2 * B,
                                            height: G * Q + 2 * B,
                                            angle: y,
                                            minLod: .5,
                                            maxLod: k.C_INFINITY
                                        });
                                        G = Number.POSITIVE_INFINITY;
                                        F = Number.NEGATIVE_INFINITY;
                                        D = G;
                                        H = F
                                    }
                                    sa = qa.y
                                }
                                var ma = [];
                                if (A) {
                                    if (ba = (qa.x +
                                            X.left - 4 + .5 * ba.metrics.width) * Q * 8, z = this._placeGlyph(h, z, ba, l, h.segment, 1, qa.vertical, V, ma), q && (z = this._placeGlyph(h, z, ba, l, h.segment, -1, qa.vertical, V, ma)), 2 <= z) break
                                } else ma.push(new f(u, v, v, V, !1)), x && q && ma.push(new f(u, v + k.C_PI, v + k.C_PI, V, !1));
                                V = qa.x + X.left;
                                ba = qa.y - r.SDF_GLYPH_BASELINE - X.top;
                                ca = V + X.width;
                                ea = ba + X.height;
                                let la, na, xa, wa;
                                !A && P ? qa.vertical ? (la = new t.Point(-((ba + ea) / 2 + X.width / 2) - 4 + W, (V + ca) / 2 - X.height / 2 - 4 + Y), na = new t.Point(la.x + p.width, la.y + p.height), xa = new t.Point(la.x, na.y), wa = new t.Point(na.x,
                                    la.y)) : (la = new t.Point(-ba + 4 + W, V - 4 + Y), na = new t.Point(la.x - p.height, la.y + p.width), xa = new t.Point(na.x, la.y), wa = new t.Point(la.x, na.y)) : (la = new t.Point(V - 4 + W, ba - 4 + Y), na = new t.Point(la.x + p.width, la.y + p.height), xa = new t.Point(la.x, na.y), wa = new t.Point(na.x, la.y));
                                let za, Aa, ya, L;
                                for (const R of ma) {
                                    let U, da, ka;
                                    R.alternateVerticalGlyph ? (za || (za = new t.Point((V + ca) / 2 + W - X.height / 2 - 4, (ba + ea) / 2 + Y + X.width / 2 + 4), Aa = new t.Point(za.x + p.height, za.y - p.width), ya = new t.Point(Aa.x, za.y), L = new t.Point(za.x, Aa.y)), ma = za,
                                        U = ya, da = L, ka = Aa) : (ma = la, U = xa, da = wa, ka = na);
                                    const M = ba,
                                        J = ea,
                                        K = R.glyphAngle + y;
                                    if (0 !== K) {
                                        var ra = Math.cos(K),
                                            ta = Math.sin(K);
                                        ma = ma.clone();
                                        U = U.clone();
                                        da = da.clone();
                                        ka = ka.clone();
                                        ma.rotate(ra, ta);
                                        ka.rotate(ra, ta);
                                        U.rotate(ra, ta);
                                        da.rotate(ra, ta)
                                    }
                                    ra = 0;
                                    ta = 256;
                                    A && P ? qa.vertical ? R.alternateVerticalGlyph ? (ra = 32, ta = 96) : (ra = 224, ta = 32) : (ra = 224, ta = 96) : (ra = 192, ta = 64);
                                    E.push(new b(ma, da, U, ka, p, R.labelAngle, ra, ta, R.anchor, R.minzoom, R.maxzoom, R.page));
                                    !m || I && !this._legible(R.labelAngle) || (C ? (V < G && (G = V), M < D && (D = M), ca >
                                        F && (F = ca), J > H && (H = J)) : 2 > R.minzoom && m.push({
                                        xTile: h.x,
                                        yTile: h.y,
                                        dxPixels: (V + W) * Q - B,
                                        dyPixels: (M + W) * Q - B,
                                        hard: !n.optional,
                                        partIndex: 1,
                                        width: (ca - V) * Q + 2 * B,
                                        height: (J - M) * Q + 2 * B,
                                        angle: K,
                                        minLod: R.minzoom,
                                        maxLod: R.maxzoom
                                    }))
                                }
                            }
                            if (2 <= z) return null;
                            m && C && (P ? (l = -H + W, u = G + Y, x = H - D, G = F - G) : (l = G + W, u = D + Y, x = F - G, G = H - D), m.push({
                                xTile: h.x,
                                yTile: h.y,
                                dxPixels: l * Q - B,
                                dyPixels: u * Q - B,
                                hard: !n.optional,
                                partIndex: 1,
                                width: x * Q + 2 * B,
                                height: G * Q + 2 * B,
                                angle: y,
                                minLod: .5,
                                maxLod: k.C_INFINITY
                            }));
                            h = new c(E);
                            m && 0 < m.length && (h.textColliders = m);
                            return h
                        };
                        d._legible = function(h) {
                            h = k.radToByte(h);
                            return 65 > h || 193 <= h
                        };
                        d._placeGlyph = function(h, p, l, n, u, y, x, q, B) {
                            const z = 0 > y ? k.positiveMod(h.angle + k.C_PI, k.C_2PI) : h.angle;
                            let v = 0;
                            0 > l && (y *= -1, l *= -1, v = k.C_PI);
                            0 < y && ++u;
                            h = new t.Point(h.x, h.y);
                            let A = n[u];
                            var m = k.C_INFINITY;
                            if (n.length <= u) return m;
                            for (;;) {
                                var E = A.x - h.x,
                                    C = A.y - h.y;
                                const G = Math.sqrt(E * E + C * C),
                                    F = Math.max(l / G, p);
                                E = k.positiveMod(Math.atan2(C / G, E / G) + v, k.C_2PI);
                                B.push(new f(h, z, E, q, !1, F, m));
                                x && B.push(new f(h, z, E, q, !0, F, m));
                                if (F <= p) return F;
                                h = A.clone();
                                do {
                                    u +=
                                        y;
                                    if (n.length <= u || 0 > u) return F;
                                    A = n[u]
                                } while (h.isEqual(A));
                                m = A.x - h.x;
                                E = A.y - h.y;
                                C = Math.sqrt(m * m + E * E);
                                m *= G / C;
                                E *= G / C;
                                h.x -= m;
                                h.y -= E;
                                m = F
                            }
                        };
                        return e
                    }();
                a.Anchor = function(e, d, h = 0, p = -1, l = .5) {
                    this.x = e;
                    this.y = d;
                    this.angle = h;
                    this.segment = p;
                    this.minzoom = l
                };
                a.PlacedSymbol = b;
                a.Placement = c;
                a.PlacementEngine = g;
                a.TILE_COORD_SIZE = 4096;
                a.TILE_PIXEL_RATIO = 8;
                a.TILE_PIXEL_SIZE = 512;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/decluttering/config": function() {
            define(["exports"], function(a) {
                a.COLLISION_GRID_CELL_SIZE =
                    32;
                a.DECLUTTER_BUDGET = 1.5;
                a.DECLUTTER_TILES = !0;
                a.FADE_DURATION = 200;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/webgl/Geometry": function() {
            define(["exports"], function(a) {
                let k = function() {
                    function w(r, f) {
                        this.x = r;
                        this.y = f
                    }
                    var t = w.prototype;
                    t.clone = function() {
                        return new w(this.x, this.y)
                    };
                    t.equals = function(r, f) {
                        return r === this.x && f === this.y
                    };
                    t.isEqual = function(r) {
                        return r.x === this.x && r.y === this.y
                    };
                    t.setCoords = function(r, f) {
                        this.x = r;
                        this.y = f
                    };
                    t.normalize = function() {
                        var r =
                            this.x;
                        const f = this.y;
                        r = Math.sqrt(r * r + f * f);
                        this.x /= r;
                        this.y /= r
                    };
                    t.rightPerpendicular = function() {
                        const r = this.x;
                        this.x = this.y;
                        this.y = -r
                    };
                    t.move = function(r, f) {
                        this.x += r;
                        this.y += f
                    };
                    t.assign = function(r) {
                        this.x = r.x;
                        this.y = r.y
                    };
                    t.assignAdd = function(r, f) {
                        this.x = r.x + f.x;
                        this.y = r.y + f.y
                    };
                    t.assignSub = function(r, f) {
                        this.x = r.x - f.x;
                        this.y = r.y - f.y
                    };
                    t.rotate = function(r, f) {
                        const b = this.x,
                            c = this.y;
                        this.x = b * r - c * f;
                        this.y = b * f + c * r
                    };
                    t.scale = function(r) {
                        this.x *= r;
                        this.y *= r
                    };
                    t.length = function() {
                        const r = this.x,
                            f = this.y;
                        return Math.sqrt(r *
                            r + f * f)
                    };
                    w.distance = function(r, f) {
                        const b = f.x - r.x;
                        r = f.y - r.y;
                        return Math.sqrt(b * b + r * r)
                    };
                    w.add = function(r, f) {
                        return new w(r.x + f.x, r.y + f.y)
                    };
                    w.sub = function(r, f) {
                        return new w(r.x - f.x, r.y - f.y)
                    };
                    return w
                }();
                a.Point = k;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/TextShaping": function() {
            define(["exports", "../webgl/Rect", "./ScriptUtils"], function(a, k, w) {
                let t = function() {
                    function r(b, c, g, e, d, h, p) {
                        this._glyphItems = b;
                        this._maxWidth = c;
                        this._lineHeight = g;
                        this._letterSpacing =
                            e;
                        this._hAnchor = d;
                        this._vAnchor = h;
                        this._justify = p
                    }
                    var f = r.prototype;
                    f.getShaping = function(b, c, g) {
                        var e = this._letterSpacing;
                        const d = this._lineHeight;
                        var h = this._justify,
                            p = this._maxWidth;
                        const l = [];
                        var n = 0,
                            u = 0,
                            y = b.length;
                        for (var x = 0; x < y; x++) {
                            var q = b.charCodeAt(x),
                                B = g && w.hasVerticalOrientation(q);
                            let z;
                            for (const v of this._glyphItems)
                                if (z = v[q]) break;
                            l.push({
                                codePoint: q,
                                x: n,
                                y: u,
                                vertical: B,
                                glyphMosaicItem: z
                            });
                            z && (n += z.metrics.advance + e)
                        }
                        g = n;
                        0 < p && (g = n / Math.max(1, Math.ceil(n / p)));
                        b = 0 <= b.indexOf("\u200b");
                        p = [];
                        for (e = 0; e < y - 1; e++)
                            if (q = l[e].codePoint, B = w.allowsIdeographicBreak(q), w.isLineBreak(q) || B) {
                                x = 0;
                                if (10 === q) x -= 1E4;
                                else if (B && b) x += 150;
                                else {
                                    if (40 === q || 65288 === q) x += 50;
                                    q = l[e + 1].codePoint;
                                    if (41 === q || 65289 === q) x += 50
                                }
                                p.push(this._buildBreak(e + 1, l[e].x, g, p, x, !1))
                            }
                        y = this._optimalBreaks(this._buildBreak(y, n, g, p, 0, !0));
                        n = 0;
                        b = c ? -d : d;
                        e = 0;
                        for (p = 0; p < y.length; p++) {
                            for (g = y[p]; e < g && w.isWhiteSpace(l[e].codePoint);) l[e].glyphMosaicItem = null, ++e;
                            for (x = g - 1; x > e && w.isWhiteSpace(l[x].codePoint);) l[x].glyphMosaicItem = null,
                                --x;
                            if (e <= x) {
                                q = l[e].x;
                                for (B = e; B <= x; B++) l[B].x -= q, l[B].y = u;
                                q = l[x].x;
                                l[x].glyphMosaicItem && (q += l[x].glyphMosaicItem.metrics.advance);
                                n = Math.max(q, n);
                                h && this._applyJustification(l, e, x)
                            }
                            e = g;
                            u += b
                        }
                        if (0 < l.length) {
                            u = y.length - 1;
                            h = (h - this._hAnchor) * n;
                            n = (-this._vAnchor * (u + 1) + .5) * d;
                            c && u && (n += u * d);
                            for (const z of l) z.x += h, z.y += n
                        }
                        return l.filter(z => z.glyphMosaicItem)
                    };
                    r.getTextBox = function(b, c) {
                        if (!b.length) return null;
                        let g = Infinity,
                            e = Infinity,
                            d = 0,
                            h = 0;
                        for (const p of b) {
                            b = p.x;
                            const l = p.y - 17,
                                n = b + p.glyphMosaicItem.metrics.advance,
                                u = l + c;
                            g = Math.min(g, b);
                            d = Math.max(d, n);
                            e = Math.min(e, l);
                            h = Math.max(h, u)
                        }
                        return {
                            x: g,
                            y: e,
                            width: d - g,
                            height: h - e
                        }
                    };
                    r.getBox = function(b) {
                        if (!b.length) return null;
                        let c = Infinity,
                            g = Infinity,
                            e = 0,
                            d = 0;
                        for (const h of b) {
                            const {
                                height: p,
                                left: l,
                                top: n,
                                width: u
                            } = h.glyphMosaicItem.metrics;
                            b = h.x;
                            const y = h.y - (p - Math.abs(n)),
                                x = b + u + l,
                                q = y + p;
                            c = Math.min(c, b);
                            e = Math.max(e, x);
                            g = Math.min(g, y);
                            d = Math.max(d, q)
                        }
                        return {
                            x: c,
                            y: g,
                            width: e - c,
                            height: d - g
                        }
                    };
                    r.addDecoration = function(b, c) {
                        var g = b.length;
                        if (0 !== g) {
                            var e = b[0].x + b[0].glyphMosaicItem.metrics.left,
                                d = b[0].y;
                            for (let h = 1; h < g; h++) {
                                const p = b[h];
                                if (p.y !== d) {
                                    const l = b[h - 1].x + b[h - 1].glyphMosaicItem.metrics.left + b[h - 1].glyphMosaicItem.metrics.width;
                                    b.push({
                                        codePoint: 0,
                                        x: e,
                                        y: d + c - 3,
                                        vertical: !1,
                                        glyphMosaicItem: {
                                            sdf: !0,
                                            rect: new k(4, 0, 4, 8),
                                            metrics: {
                                                width: l - e,
                                                height: 8,
                                                left: 0,
                                                top: 0,
                                                advance: 0
                                            },
                                            page: 0,
                                            code: 0
                                        }
                                    });
                                    d = p.y;
                                    e = p.x + p.glyphMosaicItem.metrics.left
                                }
                            }
                            g = b[g - 1].x + b[g - 1].glyphMosaicItem.metrics.left + b[g - 1].glyphMosaicItem.metrics.width;
                            b.push({
                                codePoint: 0,
                                x: e,
                                y: d + c - 3,
                                vertical: !1,
                                glyphMosaicItem: {
                                    sdf: !0,
                                    rect: new k(4,
                                        0, 4, 8),
                                    metrics: {
                                        width: g - e,
                                        height: 8,
                                        left: 0,
                                        top: 0,
                                        advance: 0
                                    },
                                    page: 0,
                                    code: 0
                                }
                            })
                        }
                    };
                    f._breakScore = function(b, c, g, e) {
                        const d = (b - c) * (b - c);
                        return e ? b < c ? d / 2 : 2 * d : d + Math.abs(g) * g
                    };
                    f._buildBreak = function(b, c, g, e, d, h) {
                        let p = null,
                            l = this._breakScore(c, g, d, h);
                        for (const n of e) e = this._breakScore(c - n.x, g, d, h) + n.score, e <= l && (p = n, l = e);
                        return {
                            index: b,
                            x: c,
                            score: l,
                            previousBreak: p
                        }
                    };
                    f._optimalBreaks = function(b) {
                        return b ? this._optimalBreaks(b.previousBreak).concat(b.index) : []
                    };
                    f._applyJustification = function(b, c, g) {
                        var e = b[g];
                        for (e = (e.x + (e.vertical ? 24 : e.glyphMosaicItem ? e.glyphMosaicItem.metrics.advance : 0)) * this._justify; c <= g; c++) b[c].x -= e
                    };
                    return r
                }();
                a.SDF_GLYPH_BASELINE = 17;
                a.SDF_GLYPH_SIZE = 24;
                a.TextShaping = t;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/webgl/Rect": function() {
            define(["../../../../chunks/_rollupPluginBabelHelpers"], function(a) {
                return function() {
                    function k(w = 0, t = 0, r = 0, f = 0) {
                        this.x = w;
                        this.y = t;
                        this.width = r;
                        this.height = f
                    }
                    k.prototype.union = function(w) {
                        this.x = Math.min(this.x, w.x);
                        this.y = Math.min(this.y, w.y);
                        this.width = Math.max(this.width, w.width);
                        this.height = Math.max(this.height, w.height)
                    };
                    a._createClass(k, [{
                        key: "isEmpty",
                        get: function() {
                            return 0 >= this.width || 0 >= this.height
                        }
                    }]);
                    return k
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/ScriptUtils": function() {
            define(["exports"], function(a) {
                a.allowsIdeographicBreak = function(k) {
                    return 11904 > k ? !1 : 12704 <= k && 12735 >= k || 12544 <= k && 12591 >= k || 65072 <= k && 65103 >= k || 63744 <= k && 64255 >= k || 13056 <= k && 13311 >= k || 11904 <= k && 12031 >= k || 12736 <= k && 12783 >= k || 12288 <=
                        k && 12351 >= k || 13312 <= k && 19903 >= k || 19968 <= k && 40959 >= k || 12800 <= k && 13055 >= k || 65280 <= k && 65519 >= k || 12352 <= k && 12447 >= k || 12272 <= k && 12287 >= k || 12032 <= k && 12255 >= k || 12784 <= k && 12799 >= k || 12448 <= k && 12543 >= k || 65040 <= k && 65055 >= k || 42128 <= k && 42191 >= k || 40960 <= k && 42127 >= k ? !0 : !1
                };
                a.hasVerticalOrientation = function(k) {
                    return 746 === k || 747 === k ? !0 : 4352 > k ? !1 : 12704 <= k && 12735 >= k || 12544 <= k && 12591 >= k || 65072 <= k && 65103 >= k && !(65097 <= k && 65103 >= k) || 63744 <= k && 64255 >= k || 13056 <= k && 13311 >= k || 11904 <= k && 12031 >= k || 12736 <= k && 12783 >= k || 12288 <=
                        k && 12351 >= k && !(12296 <= k && 12305 >= k || 12308 <= k && 12319 >= k) && 12336 !== k || 13312 <= k && 19903 >= k || 19968 <= k && 40959 >= k || 12800 <= k && 13055 >= k || 12592 <= k && 12687 >= k || 43360 <= k && 43391 >= k || 55216 <= k && 55295 >= k || 4352 <= k && 4607 >= k || 44032 <= k && 55215 >= k || 12352 <= k && 12447 >= k || 12272 <= k && 12287 >= k || 12688 <= k && 12703 >= k || 12032 <= k && 12255 >= k || 12784 <= k && 12799 >= k || 12448 <= k && 12543 >= k && 12540 !== k || 65280 <= k && 65519 >= k && !(65288 === k || 65289 === k || 65293 === k || 65306 <= k && 65310 >= k || 65339 === k || 65341 === k || 65343 === k || 65371 <= k && 65503 >= k || 65507 === k || 65512 <=
                            k && 65519 >= k) || 65104 <= k && 65135 >= k && !(65112 <= k && 65118 >= k || 65123 <= k && 65126 >= k) || 5120 <= k && 5759 >= k || 6320 <= k && 6399 >= k || 65040 <= k && 65055 >= k || 19904 <= k && 19967 >= k || 40960 <= k && 42127 >= k || 42128 <= k && 42191 >= k ? !0 : !1
                };
                a.isLineBreak = function(k) {
                    switch (k) {
                        case 10:
                        case 32:
                        case 38:
                        case 40:
                        case 41:
                        case 43:
                        case 45:
                        case 47:
                        case 173:
                        case 183:
                        case 8203:
                        case 8208:
                        case 8211:
                        case 8231:
                            return !0
                    }
                    return !1
                };
                a.isWhiteSpace = function(k) {
                    switch (k) {
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 32:
                            return !0
                    }
                    return !1
                };
                Object.defineProperty(a,
                    "__esModule", {
                        value: !0
                    })
            })
        },
        "esri/views/2d/engine/vectorTiles/TileParser": function() {
            define("../../../../core/promiseUtils ../../../../core/pbf ../webgl/TileClipper ../../tiling/enums ./Feature ./IndexMemoryBuffer ./SourceLayerData ./VertexMemoryBuffer ./buckets/CircleBucket ./buckets/FillBucket ./buckets/LineBucket ./buckets/SymbolBucket".split(" "), function(a, k, w, t, r, f, b, c, g, e, d, h) {
                return function() {
                    function p(n, u, y, x, q) {
                        this._pbfTiles = {};
                        this._tileClippers = {};
                        this._client = y;
                        this._tile = u;
                        if (q) {
                            this._styleLayerUIDs =
                                new Set;
                            for (const A of q) this._styleLayerUIDs.add(A)
                        }
                        this._styleRepository = x;
                        this._layers = this._styleRepository.layers;
                        const [B, z, v] = u.tileKey.split("/").map(parseFloat);
                        this._level = B;
                        u = Math.max(8, Math.round(1 * this._level) - 8);
                        for (const A of Object.keys(n)) y = n[A], this._pbfTiles[A] = new k(new Uint8Array(y.protobuff), new DataView(y.protobuff)), y.refKey && ([y] = y.refKey.split("/").map(parseFloat), y = B - y, 0 < y && (x = (1 << y) - 1, this._tileClippers[A] = new w.TileClipper(y, z & x, v & x, 8, u))), this._tileClippers[A] || (this._tileClippers[A] =
                            new w.SimpleBuilder)
                    }
                    var l = p.prototype;
                    l._canParseStyleLayer = function(n) {
                        return !this._styleLayerUIDs || this._styleLayerUIDs.has(n)
                    };
                    l.parse = async function(n) {
                        const u = this._initialize(n),
                            {
                                returnedBuckets: y
                            } = u;
                        this._processLayers(u);
                        this._linkReferences(u);
                        this._filterFeatures(u);
                        const x = new Set,
                            q = {};
                        for (const B of y) 3 === B.type && B.getResources(B.tileClipper, x, q);
                        if (this._tile.status === t.TileStatus.INVALID) return Promise.resolve([]);
                        n = this._fetchResources(x, q, n);
                        return Promise.all(n).then(() => this._processFeatures(u.returnedBuckets))
                    };
                    l._initialize = function(n) {
                        n = n && n.signal;
                        const u = this._parseTileData(this._pbfTiles),
                            y = this._layers,
                            x = this._level,
                            q = this._tileClippers,
                            B = new Map;
                        return {
                            signal: n,
                            sourceNameToTileData: u,
                            layers: y,
                            zoom: x,
                            sourceNameToTileClipper: q,
                            sourceNameToUniqueSourceLayerBuckets: {},
                            sourceNameToUniqueSourceLayers: {},
                            returnedBuckets: [],
                            layerIdToBucket: {},
                            referencerUIDToReferencedId: B
                        }
                    };
                    l._processLayers = function(n) {
                        const {
                            sourceNameToTileData: u,
                            layers: y,
                            zoom: x,
                            sourceNameToTileClipper: q,
                            sourceNameToUniqueSourceLayerBuckets: B,
                            sourceNameToUniqueSourceLayers: z,
                            returnedBuckets: v,
                            layerIdToBucket: A,
                            referencerUIDToReferencedId: m
                        } = n;
                        for (n = y.length - 1; 0 <= n; n--) {
                            const F = y[n];
                            if (!this._canParseStyleLayer(F.uid) || F.minzoom && x < Math.floor(F.minzoom) || F.maxzoom && x >= F.maxzoom || 0 === F.type) continue;
                            if (!u[F.source] || !q[F.source]) continue;
                            var E = q[F.source];
                            const D = F.sourceLayer;
                            var C = u[F.source][D];
                            if (C) {
                                var G = z[F.source];
                                G || (G = z[F.source] = new Set);
                                G.add(F.sourceLayer);
                                if (F.refLayerId) m.set(F.uid, F.refLayerId);
                                else if (G = this._createBucket(F)) G.layerUIDs = [F.uid], G.layerExtent = C.extent, G.tileClipper = E, (E = B[F.source]) || (E = B[F.source] = {}), (C = E[D]) || (C = E[D] = []), C.push(G), v.push(G), A[F.id.toLowerCase()] = G
                            }
                        }
                    };
                    l._linkReferences = function(n) {
                        const {
                            layerIdToBucket: u,
                            referencerUIDToReferencedId: y
                        } = n;
                        y.forEach((x, q) => {
                            x = x.toLowerCase();
                            u[x] && u[x].layerUIDs.push(q)
                        })
                    };
                    l._filterFeatures = function(n) {
                        const {
                            signal: u,
                            sourceNameToTileData: y,
                            sourceNameToUniqueSourceLayerBuckets: x,
                            sourceNameToUniqueSourceLayers: q
                        } = n;
                        n = 10 * this._level;
                        const B = 10 * (this._level + 1),
                            z = [],
                            v = [];
                        for (const C of Object.keys(q)) q[C].forEach(G => {
                            z.push(G);
                            v.push(C)
                        });
                        for (let C = 0; C < z.length; C++) {
                            var A = v[C],
                                m = z[C];
                            if (!y[A] || !x[A]) continue;
                            const G = y[A][m];
                            if ((A = x[A][m]) && 0 !== A.length) {
                                if (a.isAborted(u)) break;
                                for (m = G.getData(); m.nextTag(2);) {
                                    var E = m.getMessage();
                                    const F = new r(E, G);
                                    E.release();
                                    if (E = F.values) {
                                        const D = E._minzoom;
                                        if (D && D >= B) continue;
                                        if ((E = E._maxzoom) && E <= n) continue
                                    }
                                    for (const D of A) D.pushFeature(F)
                                }
                            }
                        }
                    };
                    l._fetchResources = function(n, u, y) {
                        const x = [],
                            q = this._tile.getWorkerTileHandler();
                        0 < n.size && (n = q.fetchSprites(n, this._client, y), x.push(n));
                        for (const B in u) n = u[B], 0 < n.size && (n = q.fetchGlyphs(this._tile.tileKey, B, n, this._client, y), x.push(n));
                        return x
                    };
                    l._processFeatures = function(n) {
                        n = n.filter(u => u.hasFeatures() || this._canParseStyleLayer(u.layer.uid));
                        for (const u of n) u.processFeatures(u.tileClipper);
                        return n
                    };
                    l._parseTileData = function(n) {
                        const u = {};
                        for (const y of Object.keys(n)) {
                            const x = n[y],
                                q = {};
                            for (; x.next();) switch (x.tag()) {
                                case 3:
                                    {
                                        const B = x.getMessage(),
                                            z = new b(B);B.release();
                                        q[z.name] = z;
                                        break
                                    }
                                default:
                                    x.skip()
                            }
                            u[y] = q
                        }
                        return u
                    };
                    l._createBucket = function(n) {
                        switch (n.type) {
                            case 0:
                                return null;
                            case 1:
                                return this._createFillBucket(n);
                            case 2:
                                return this._createLineBucket(n);
                            case 4:
                                return this._createCircleBucket(n);
                            case 3:
                                return this._createSymbolBucket(n)
                        }
                    };
                    l._createFillBucket = function(n) {
                        return new e(n, this._level, new c.FillVertexBuffer(n.fillMaterial.getStride()), new f.TriangleIndexBuffer, new c.OutlineVertexBuffer(n.outlineMaterial.getStride()), new f.TriangleIndexBuffer)
                    };
                    l._createLineBucket = function(n) {
                        return new d(n, this._level, new c.LineVertexBuffer(n.lineMaterial.getStride()), new f.TriangleIndexBuffer)
                    };
                    l._createCircleBucket = function(n) {
                        return new g(n, this._level, new c.CircleVertexBuffer(n.circleMaterial.getStride()), new f.TriangleIndexBuffer)
                    };
                    l._createSymbolBucket = function(n) {
                        const u = this._tile;
                        return new h(n, this._level, new c.SymbolVertexBuffer(n.iconMaterial.getStride()), new f.TriangleIndexBuffer, new c.SymbolVertexBuffer(n.textMaterial.getStride()), new f.TriangleIndexBuffer,
                            u.placementEngine, u.getWorkerTileHandler())
                    };
                    return p
                }()
            })
        },
        "esri/core/pbf": function() {
            define(["./has", "./ObjectPool"], function(a, k) {
                const w = a("esri-text-decoder") ? new TextDecoder("utf-8") : null,
                    t = a("safari") || a("ios") ? 6 : a("ff") ? 12 : 32;
                a = function() {
                    function r(b, c, g = 0, e = b ? b.byteLength : 0) {
                        this._tag = 0;
                        this._dataType = 99;
                        this.init(b, c, g, e)
                    }
                    var f = r.prototype;
                    f.init = function(b, c, g, e) {
                        this._data = b;
                        this._dataView = c;
                        this._pos = g;
                        this._end = e
                    };
                    f.clone = function() {
                        return new r(this._data, this._dataView, this._pos,
                            this._end)
                    };
                    f.pos = function() {
                        return this._pos
                    };
                    f.move = function(b) {
                        this._pos = b
                    };
                    f.nextTag = function(b) {
                        for (;;) {
                            if (this._pos === this._end) return !1;
                            const c = this._decodeVarint();
                            this._tag = c >> 3;
                            this._dataType = c & 7;
                            if (!b || b === this._tag) break;
                            this.skip()
                        }
                        return !0
                    };
                    f.next = function() {
                        if (this._pos === this._end) return !1;
                        const b = this._decodeVarint();
                        this._tag = b >> 3;
                        this._dataType = b & 7;
                        return !0
                    };
                    f.empty = function() {
                        return this._pos >= this._end
                    };
                    f.tag = function() {
                        return this._tag
                    };
                    f.getInt32 = function() {
                        return this._decodeVarint()
                    };
                    f.getInt64 = function() {
                        return this._decodeVarint()
                    };
                    f.getUInt32 = function() {
                        let b = 4294967295;
                        b = (this._data[this._pos] & 127) >>> 0;
                        if (128 > this._data[this._pos++]) return b;
                        b = (b | (this._data[this._pos] & 127) << 7) >>> 0;
                        if (128 > this._data[this._pos++]) return b;
                        b = (b | (this._data[this._pos] & 127) << 14) >>> 0;
                        if (128 > this._data[this._pos++]) return b;
                        b = (b | (this._data[this._pos] & 127) << 21) >>> 0;
                        if (128 > this._data[this._pos++]) return b;
                        b = (b | (this._data[this._pos] & 15) << 28) >>> 0;
                        if (128 > this._data[this._pos++]) return b
                    };
                    f.getUInt64 =
                        function() {
                            return this._decodeVarint()
                        };
                    f.getSInt32 = function() {
                        const b = this.getUInt32();
                        return b >>> 1 ^ -(b & 1) | 0
                    };
                    f.getSInt64 = function() {
                        return this._decodeSVarint()
                    };
                    f.getBool = function() {
                        const b = 0 !== this._data[this._pos];
                        this._skip(1);
                        return b
                    };
                    f.getEnum = function() {
                        return this._decodeVarint()
                    };
                    f.getFixed64 = function() {
                        var b = this._dataView;
                        const c = this._pos;
                        b = b.getUint32(c, !0) + 4294967296 * b.getUint32(c + 4, !0);
                        this._skip(8);
                        return b
                    };
                    f.getSFixed64 = function() {
                        var b = this._dataView;
                        const c = this._pos;
                        b = b.getUint32(c, !0) + 4294967296 * b.getInt32(c + 4, !0);
                        this._skip(8);
                        return b
                    };
                    f.getDouble = function() {
                        const b = this._dataView.getFloat64(this._pos, !0);
                        this._skip(8);
                        return b
                    };
                    f.getFixed32 = function() {
                        const b = this._dataView.getUint32(this._pos, !0);
                        this._skip(4);
                        return b
                    };
                    f.getSFixed32 = function() {
                        const b = this._dataView.getInt32(this._pos, !0);
                        this._skip(4);
                        return b
                    };
                    f.getFloat = function() {
                        const b = this._dataView.getFloat32(this._pos, !0);
                        this._skip(4);
                        return b
                    };
                    f.getString = function() {
                        const b = this._getLength();
                        var c = this._pos;
                        c = this._toString(this._data, c, c + b);
                        this._skip(b);
                        return c
                    };
                    f.getBytes = function() {
                        const b = this._getLength();
                        var c = this._pos;
                        c = this._toBytes(this._data, c, c + b);
                        this._skip(b);
                        return c
                    };
                    f.getLength = function() {
                        return this._getLengthUnsafe()
                    };
                    f.processMessageWithArgs = function(b, c, g, e) {
                        const d = this.getMessage();
                        b = b(d, c, g, e);
                        d.release();
                        return b
                    };
                    f.processMessage = function(b) {
                        const c = this.getMessage();
                        b = b(c);
                        c.release();
                        return b
                    };
                    f.getMessage = function() {
                        const b = this._getLength(),
                            c = r.pool.acquire();
                        c.init(this._data,
                            this._dataView, this._pos, this._pos + b);
                        this._skip(b);
                        return c
                    };
                    f.release = function() {
                        r.pool.release(this)
                    };
                    f.dataType = function() {
                        return this._dataType
                    };
                    f.skip = function() {
                        switch (this._dataType) {
                            case 0:
                                this._decodeVarint();
                                break;
                            case 1:
                                this._skip(8);
                                break;
                            case 2:
                                this._skip(this._getLength());
                                break;
                            case 5:
                                this._skip(4);
                                break;
                            default:
                                throw Error("Invalid data type!");
                        }
                    };
                    f.skipLen = function(b) {
                        this._skip(b)
                    };
                    f._skip = function(b) {
                        if (this._pos + b > this._end) throw Error("Attempt to skip past the end of buffer!");
                        this._pos += b
                    };
                    f._decodeVarint = function() {
                        const b = this._data;
                        let c = this._pos,
                            g = 0,
                            e;
                        if (10 <= this._end - c) {
                            if (e = b[c++], g |= e & 127, 0 !== (e & 128) && (e = b[c++], g |= (e & 127) << 7, 0 !== (e & 128) && (e = b[c++], g |= (e & 127) << 14, 0 !== (e & 128) && (e = b[c++], g |= (e & 127) << 21, 0 !== (e & 128) && (e = b[c++], g += 268435456 * (e & 127), 0 !== (e & 128) && (e = b[c++], g += 34359738368 * (e & 127), 0 !== (e & 128) && (e = b[c++], g += 4398046511104 * (e & 127), 0 !== (e & 128) && (e = b[c++], g += 562949953421312 * (e & 127), 0 !== (e & 128) && (e = b[c++], g += 72057594037927936 * (e & 127), 0 !== (e & 128) && (e = b[c++], g +=
                                    0x7fffffffffffffff * (e & 127), 0 !== (e & 128))))))))))) throw Error("Varint too long!");
                        } else {
                            let d = 1;
                            for (; c !== this._end;) {
                                e = b[c];
                                if (0 === (e & 128)) break;
                                ++c;
                                g += (e & 127) * d;
                                d *= 128
                            }
                            if (c === this._end) throw Error("Varint overrun!");
                            ++c;
                            g += e * d
                        }
                        this._pos = c;
                        return g
                    };
                    f._decodeSVarint = function() {
                        const b = this._decodeVarint();
                        return b % 2 ? -(b + 1) / 2 : b / 2
                    };
                    f._getLength = function() {
                        if (2 !== this._dataType) throw Error("Not a delimited data type!");
                        return this._decodeVarint()
                    };
                    f._getLengthUnsafe = function() {
                        return this.getUInt32()
                    };
                    f._toString = function(b, c, g) {
                        g = Math.min(this._end, g);
                        if (g - c > t && w) return b = b.subarray(c, g), w.decode(b);
                        let e = "",
                            d = "";
                        for (; c < g; ++c) {
                            const h = b[c];
                            h & 128 ? d += "%" + h.toString(16) : (e += decodeURIComponent(d) + String.fromCharCode(h), d = "")
                        }
                        d.length && (e += decodeURIComponent(d));
                        return e
                    };
                    f._toBytes = function(b, c, g) {
                        g = Math.min(this._end, g);
                        return new Uint8Array(b.buffer, c, g - c)
                    };
                    return r
                }();
                a.pool = new k(a, null, r => {
                    r._data = null;
                    r._dataView = null
                });
                return a
            })
        },
        "esri/views/2d/engine/webgl/TileClipper": function() {
            define(["exports",
                "../../../../chunks/_rollupPluginBabelHelpers", "./definitions", "./GeometryUtils", "./Geometry"
            ], function(a, k, w, t, r) {
                let f = function(e, d, h) {
                        this.ratio = e;
                        this.x = d;
                        this.y = h
                    },
                    b = function() {
                        function e(h, p, l, n = 8, u = 8) {
                            this.lines = [];
                            this.starts = [];
                            this.validateTessellation = !0;
                            this.pixelRatio = n;
                            this.pixelMargin = u;
                            this.tileSize = w.TILE_SIZE * n;
                            this.dz = h;
                            this.yPos = p;
                            this.xPos = l
                        }
                        var d = e.prototype;
                        d.setPixelMargin = function(h) {
                            h !== this.pixelMargin && (this.pixelMargin = h, this.setExtent(this._extent))
                        };
                        d.setExtent = function(h) {
                            this._extent =
                                h;
                            this.finalRatio = this.tileSize / h * (1 << this.dz);
                            let p = this.pixelRatio * this.pixelMargin;
                            p /= this.finalRatio;
                            h >>= this.dz;
                            p > h && (p = h);
                            this.margin = p;
                            this.xmin = h * this.xPos - p;
                            this.ymin = h * this.yPos - p;
                            this.xmax = this.xmin + h + 2 * p;
                            this.ymax = this.ymin + h + 2 * p
                        };
                        d.reset = function(h) {
                            this.type = h;
                            this.lines = [];
                            this.starts = [];
                            this.line = null;
                            this.start = 0
                        };
                        d.moveTo = function(h, p) {
                            this._pushLine();
                            this._prevIsIn = this._isIn(h, p);
                            this._moveTo(h, p, this._prevIsIn);
                            this._prevPt = new r.Point(h, p);
                            this._firstPt = new r.Point(h, p);
                            this._dist =
                                0
                        };
                        d.lineTo = function(h, p) {
                            const l = this._isIn(h, p),
                                n = new r.Point(h, p),
                                u = r.Point.distance(this._prevPt, n);
                            if (l)
                                if (this._prevIsIn) this._lineTo(h, p, !0);
                                else {
                                    var y = this._prevPt;
                                    var x = n;
                                    h = this._intersect(x, y);
                                    this.start = this._dist + u * (1 - this._r);
                                    this._lineTo(h.x, h.y, !0);
                                    this._lineTo(x.x, x.y, !0)
                                }
                            else if (this._prevIsIn) x = this._prevPt, y = n, h = this._intersect(x, y), this._lineTo(h.x, h.y, !0), this._lineTo(y.x, y.y, !1);
                            else {
                                const B = this._prevPt;
                                if (!(B.x <= this.xmin && n.x <= this.xmin || B.x >= this.xmax && n.x >= this.xmax || B.y <=
                                        this.ymin && n.y <= this.ymin || B.y >= this.ymax && n.y >= this.ymax)) {
                                    h = [];
                                    if (B.x < this.xmin && n.x > this.xmin || B.x > this.xmin && n.x < this.xmin) {
                                        p = (this.xmin - B.x) / (n.x - B.x);
                                        var q = B.y + p * (n.y - B.y);
                                        q <= this.ymin ? x = !1 : q >= this.ymax ? x = !0 : h.push(new f(p, this.xmin, q))
                                    }
                                    if (B.x < this.xmax && n.x > this.xmax || B.x > this.xmax && n.x < this.xmax) p = (this.xmax - B.x) / (n.x - B.x), q = B.y + p * (n.y - B.y), q <= this.ymin ? x = !1 : q >= this.ymax ? x = !0 : h.push(new f(p, this.xmax, q));
                                    if (B.y < this.ymin && n.y > this.ymin || B.y > this.ymin && n.y < this.ymin) p = (this.ymin - B.y) / (n.y -
                                        B.y), q = B.x + p * (n.x - B.x), q <= this.xmin ? y = !1 : q >= this.xmax ? y = !0 : h.push(new f(p, q, this.ymin));
                                    if (B.y < this.ymax && n.y > this.ymax || B.y > this.ymax && n.y < this.ymax) p = (this.ymax - B.y) / (n.y - B.y), q = B.x + p * (n.x - B.x), q <= this.xmin ? y = !1 : q >= this.xmax ? y = !0 : h.push(new f(p, q, this.ymax));
                                    if (0 === h.length) y ? x ? this._lineTo(this.xmax, this.ymax, !0) : this._lineTo(this.xmax, this.ymin, !0) : x ? this._lineTo(this.xmin, this.ymax, !0) : this._lineTo(this.xmin, this.ymin, !0);
                                    else if (1 < h.length && h[0].ratio > h[1].ratio) this.start = this._dist + u * h[1].ratio,
                                        this._lineTo(h[1].x, h[1].y, !0), this._lineTo(h[0].x, h[0].y, !0);
                                    else
                                        for (this.start = this._dist + u * h[0].ratio, y = 0; y < h.length; y++) this._lineTo(h[y].x, h[y].y, !0)
                                }
                                this._lineTo(n.x, n.y, !1)
                            }
                            this._dist += u;
                            this._prevIsIn = l;
                            this._prevPt = n
                        };
                        d.close = function() {
                            if (2 < this.line.length) {
                                var h = this._firstPt,
                                    p = this._prevPt;
                                h.x === p.x && h.y === p.y || this.lineTo(h.x, h.y);
                                h = this.line;
                                for (p = h.length; 4 <= p;)
                                    if (h[0].x === h[1].x && h[0].x === h[p - 2].x || h[0].y === h[1].y && h[0].y === h[p - 2].y) h.pop(), h[0].x = h[p - 2].x, h[0].y = h[p - 2].y, --p;
                                    else break
                            }
                        };
                        d.result = function(h = !0) {
                            this._pushLine();
                            if (0 === this.lines.length) return null;
                            3 === this.type && h && g.simplify(this.tileSize, this.margin * this.finalRatio, this.lines);
                            return this.lines
                        };
                        d.resultWithStarts = function() {
                            if (2 !== this.type) throw Error("Only valid for lines");
                            this._pushLine();
                            const h = this.lines,
                                p = h.length;
                            if (0 === p) return null;
                            const l = [];
                            for (let n = 0; n < p; n++) l.push({
                                line: h[n],
                                start: this.starts[n] || 0
                            });
                            return l
                        };
                        d._isIn = function(h, p) {
                            return h >= this.xmin && h <= this.xmax && p >= this.ymin && p <= this.ymax
                        };
                        d._intersect = function(h, p) {
                            let l, n, u;
                            if (p.x >= this.xmin && p.x <= this.xmax) n = p.y <= this.ymin ? this.ymin : this.ymax, u = (n - h.y) / (p.y - h.y), l = h.x + u * (p.x - h.x);
                            else if (p.y >= this.ymin && p.y <= this.ymax) l = p.x <= this.xmin ? this.xmin : this.xmax, u = (l - h.x) / (p.x - h.x), n = h.y + u * (p.y - h.y);
                            else {
                                n = p.y <= this.ymin ? this.ymin : this.ymax;
                                l = p.x <= this.xmin ? this.xmin : this.xmax;
                                const y = (l - h.x) / (p.x - h.x),
                                    x = (n - h.y) / (p.y - h.y);
                                y < x ? (u = y, n = h.y + y * (p.y - h.y)) : (u = x, l = h.x + x * (p.x - h.x))
                            }
                            this._r = u;
                            return new r.Point(l, n)
                        };
                        d._pushLine = function() {
                            this.line &&
                                (1 === this.type ? 0 < this.line.length && (this.lines.push(this.line), this.starts.push(this.start)) : 2 === this.type ? 1 < this.line.length && (this.lines.push(this.line), this.starts.push(this.start)) : 3 === this.type && 3 < this.line.length && (this.lines.push(this.line), this.starts.push(this.start)));
                            this.line = [];
                            this.start = 0
                        };
                        d._moveTo = function(h, p, l) {
                            3 !== this.type ? l && (h = Math.round((h - (this.xmin + this.margin)) * this.finalRatio), p = Math.round((p - (this.ymin + this.margin)) * this.finalRatio), this.line.push(new r.Point(h, p))) : (l ||
                                (h < this.xmin && (h = this.xmin), h > this.xmax && (h = this.xmax), p < this.ymin && (p = this.ymin), p > this.ymax && (p = this.ymax)), h = Math.round((h - (this.xmin + this.margin)) * this.finalRatio), p = Math.round((p - (this.ymin + this.margin)) * this.finalRatio), this.line.push(new r.Point(h, p)), this._is_v = this._is_h = !1)
                        };
                        d._lineTo = function(h, p, l) {
                            if (3 !== this.type)
                                if (l) {
                                    h = Math.round((h - (this.xmin + this.margin)) * this.finalRatio);
                                    p = Math.round((p - (this.ymin + this.margin)) * this.finalRatio);
                                    if (0 < this.line.length && (l = this.line[this.line.length -
                                            1], l.equals(h, p))) return;
                                    this.line.push(new r.Point(h, p))
                                } else this.line && 0 < this.line.length && this._pushLine();
                            else if (l || (h < this.xmin && (h = this.xmin), h > this.xmax && (h = this.xmax), p < this.ymin && (p = this.ymin), p > this.ymax && (p = this.ymax)), h = Math.round((h - (this.xmin + this.margin)) * this.finalRatio), p = Math.round((p - (this.ymin + this.margin)) * this.finalRatio), this.line && 0 < this.line.length) {
                                l = this.line[this.line.length - 1];
                                const n = l.x === h,
                                    u = l.y === p;
                                n && u || (this._is_h && n ? (l.x = h, l.y = p, l = this.line[this.line.length - 2],
                                    l.x === h && l.y === p ? (this.line.pop(), 1 >= this.line.length ? this._is_v = this._is_h = !1 : (l = this.line[this.line.length - 2], this._is_h = l.x === h, this._is_v = l.y === p)) : (this._is_h = l.x === h, this._is_v = l.y === p)) : this._is_v && u ? (l.x = h, l.y = p, l = this.line[this.line.length - 2], l.x === h && l.y === p ? (this.line.pop(), 1 >= this.line.length ? this._is_v = this._is_h = !1 : (l = this.line[this.line.length - 2], this._is_h = l.x === h, this._is_v = l.y === p)) : (this._is_h = l.x === h, this._is_v = l.y === p)) : (this.line.push(new r.Point(h, p)), this._is_h = n, this._is_v =
                                    u))
                            } else this.line.push(new r.Point(h, p))
                        };
                        return e
                    }(),
                    c = function() {
                        function e() {}
                        var d = e.prototype;
                        d.setExtent = function(h) {
                            this._ratio = 4096 === h ? 1 : 4096 / h
                        };
                        d.reset = function(h) {
                            this.lines = [];
                            this.line = null
                        };
                        d.moveTo = function(h, p) {
                            this.line && this.lines.push(this.line);
                            this.line = [];
                            const l = this._ratio;
                            this.line.push(new r.Point(h * l, p * l))
                        };
                        d.lineTo = function(h, p) {
                            const l = this._ratio;
                            this.line.push(new r.Point(h * l, p * l))
                        };
                        d.close = function() {
                            const h = this.line;
                            h && !h[0].isEqual(h[h.length - 1]) && h.push(h[0])
                        };
                        d.result = function() {
                            this.line && this.lines.push(this.line);
                            return 0 === this.lines.length ? null : this.lines
                        };
                        k._createClass(e, [{
                            key: "validateTessellation",
                            get: function() {
                                return 1 > this._ratio
                            }
                        }]);
                        return e
                    }(),
                    g = function() {
                        function e() {}
                        e.simplify = function(d, h, p) {
                            if (p) {
                                var l = -h,
                                    n = d + h,
                                    u = -h,
                                    y = d + h;
                                d = [];
                                h = [];
                                var x = p.length;
                                for (let q = 0; q < x; ++q) {
                                    const B = p[q];
                                    if (!B || 2 > B.length) continue;
                                    let z = B[0],
                                        v;
                                    const A = B.length;
                                    for (let m = 1; m < A; ++m) v = B[m], z.x === v.x && (z.x <= l && (z.y > v.y ? (d.push(q), d.push(m), d.push(0), d.push(-1)) :
                                        (h.push(q), h.push(m), h.push(0), h.push(-1))), z.x >= n && (z.y < v.y ? (d.push(q), d.push(m), d.push(1), d.push(-1)) : (h.push(q), h.push(m), h.push(1), h.push(-1)))), z.y === v.y && (z.y <= u && (z.x < v.x ? (d.push(q), d.push(m), d.push(2), d.push(-1)) : (h.push(q), h.push(m), h.push(2), h.push(-1))), z.y >= y && (z.x > v.x ? (d.push(q), d.push(m), d.push(3), d.push(-1)) : (h.push(q), h.push(m), h.push(3), h.push(-1)))), z = v
                                }
                                0 !== d.length && 0 !== h.length && (e.fillParent(p, h, d), e.fillParent(p, d, h), l = [], e.calcDeltas(l, h, d), e.calcDeltas(l, d, h), e.addDeltas(l,
                                    p))
                            }
                        };
                        e.fillParent = function(d, h, p) {
                            const l = p.length,
                                n = h.length;
                            for (let B = 0; B < n; B += 4) {
                                var u = h[B],
                                    y = h[B + 1];
                                const z = h[B + 2],
                                    v = d[u][y - 1];
                                u = d[u][y];
                                y = 8092;
                                let A = -1;
                                for (let m = 0; m < l; m += 4) {
                                    if (p[m + 2] !== z) continue;
                                    var x = p[m];
                                    const E = p[m + 1];
                                    var q = d[x][E - 1];
                                    x = d[x][E];
                                    switch (z) {
                                        case 0:
                                        case 1:
                                            t.between(v.y, q.y, x.y) && t.between(u.y, q.y, x.y) && (q = Math.abs(x.y - q.y), q < y && (y = q, A = m));
                                            break;
                                        case 2:
                                        case 3:
                                            t.between(v.x, q.x, x.x) && t.between(u.x, q.x, x.x) && (q = Math.abs(x.x - q.x), q < y && (y = q, A = m))
                                    }
                                }
                                h[B + 3] = A
                            }
                        };
                        e.calcDeltas = function(d,
                            h, p) {
                            const l = h.length;
                            for (let n = 0; n < l; n += 4) {
                                const u = e.calcDelta(n, h, p, []);
                                d.push(h[n]);
                                d.push(h[n + 1]);
                                d.push(h[n + 2]);
                                d.push(u)
                            }
                        };
                        e.calcDelta = function(d, h, p, l) {
                            d = h[d + 3];
                            if (-1 === d) return 0;
                            const n = l.length;
                            if (1 < n && l[n - 2] === d) return 0;
                            l.push(d);
                            return e.calcDelta(d, p, h, l) + 1
                        };
                        e.addDeltas = function(d, h) {
                            const p = d.length;
                            let l = 0;
                            for (var n = 0; n < p; n += 4) {
                                var u = d[n + 3];
                                u > l && (l = u)
                            }
                            for (n = 0; n < p; n += 4) {
                                u = h[d[n]];
                                const y = d[n + 1],
                                    x = l - d[n + 3];
                                switch (d[n + 2]) {
                                    case 0:
                                        u[y - 1].x -= x;
                                        u[y].x -= x;
                                        1 === y && (u[u.length - 1].x -= x);
                                        y === u.length -
                                            1 && (u[0].x -= x);
                                        break;
                                    case 1:
                                        u[y - 1].x += x;
                                        u[y].x += x;
                                        1 === y && (u[u.length - 1].x += x);
                                        y === u.length - 1 && (u[0].x += x);
                                        break;
                                    case 2:
                                        u[y - 1].y -= x;
                                        u[y].y -= x;
                                        1 === y && (u[u.length - 1].y -= x);
                                        y === u.length - 1 && (u[0].y -= x);
                                        break;
                                    case 3:
                                        u[y - 1].y += x, u[y].y += x, 1 === y && (u[u.length - 1].y += x), y === u.length - 1 && (u[0].y += x)
                                }
                            }
                        };
                        return e
                    }();
                a.SimpleBuilder = c;
                a.TileClipper = b;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/webgl/GeometryUtils": function() {
            define(["exports"], function(a) {
                function k(c, g) {
                    c %= g;
                    return 0 <=
                        c ? c : c + g
                }
                const w = Number.POSITIVE_INFINITY,
                    t = Math.PI,
                    r = 128 / t,
                    f = 256 / 360,
                    b = 1 / Math.LN2;
                a.C_256_TO_RAD = t / 128;
                a.C_2PI = 2 * t;
                a.C_DEG_TO_256 = f;
                a.C_DEG_TO_RAD = t / 180;
                a.C_INFINITY = w;
                a.C_PI = t;
                a.C_PI_BY_2 = t / 2;
                a.C_RAD_TO_256 = r;
                a.C_SQRT2 = 1.414213562;
                a.C_SQRT2_INV = 1 / 1.414213562;
                a.between = function(c, g, e) {
                    return c >= g && c <= e || c >= e && c <= g
                };
                a.degToByte = function(c) {
                    return k(c * f, 256)
                };
                a.interpolate = function(c, g, e) {
                    return c * (1 - e) + g * e
                };
                a.log2 = function(c) {
                    return Math.log(c) * b
                };
                a.positiveMod = k;
                a.radToByte = function(c) {
                    return k(c *
                        r, 256)
                };
                a.sqr = function(c) {
                    return c * c
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/Feature": function() {
            define(["../webgl/Geometry"], function(a) {
                return function() {
                    function k(w, t) {
                        this.values = {};
                        const r = t.keys;
                        for (t = t.values; w.next();) switch (w.tag()) {
                            case 1:
                                this.id = w.getUInt64();
                                break;
                            case 2:
                                {
                                    const f = w.getMessage(),
                                        b = this.values;
                                    for (; !f.empty();) {
                                        const c = f.getUInt32(),
                                            g = f.getUInt32();
                                        b[r[c]] = t[g]
                                    }
                                    f.release();
                                    break
                                }
                            case 3:
                                this.type = w.getUInt32();
                                break;
                            case 4:
                                this._pbfGeometry =
                                    w.getMessage();
                                break;
                            default:
                                w.skip()
                        }
                    }
                    k.prototype.getGeometry = function(w) {
                        if (void 0 !== this._geometry) return this._geometry;
                        if (!this._pbfGeometry) return null;
                        const t = this._pbfGeometry;
                        this._pbfGeometry = null;
                        let r, f;
                        w ? w.reset(this.type) : r = [];
                        let b = 1;
                        var c = 0;
                        let g = 0,
                            e = 0;
                        for (; !t.empty();) switch (0 === c && (c = t.getUInt32(), b = c & 7, c >>= 3), c--, b) {
                            case 1:
                                g += t.getSInt32();
                                e += t.getSInt32();
                                w ? w.moveTo(g, e) : (f && r.push(f), f = [], f.push(new a.Point(g, e)));
                                break;
                            case 2:
                                g += t.getSInt32();
                                e += t.getSInt32();
                                w ? w.lineTo(g, e) :
                                    f.push(new a.Point(g, e));
                                break;
                            case 7:
                                w ? w.close() : f && !f[0].equals(g, e) && f.push(f[0].clone());
                                break;
                            default:
                                throw t.release(), Error("Invalid path operation");
                        }
                        w ? w = w.result() : (f && r.push(f), w = r);
                        t.release();
                        return this._geometry = w
                    };
                    return k
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/IndexMemoryBuffer": function() {
            define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "./MemoryBuffer"], function(a, k, w) {
                let t = function(r) {
                    function f() {
                        return r.call(this, 12) || this
                    }
                    k._inheritsLoose(f, r);
                    f.prototype.add =
                        function(b, c, g) {
                            const e = this.array;
                            e.push(b);
                            e.push(c);
                            e.push(g)
                        };
                    return f
                }(w);
                w = function(r) {
                    function f() {
                        return r.call(this, 4) || this
                    }
                    k._inheritsLoose(f, r);
                    f.prototype.add = function(b) {
                        this.array.push(b)
                    };
                    return f
                }(w);
                a.PointElementMemoryBuffer = w;
                a.TriangleIndexBuffer = t;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/SourceLayerData": function() {
            define(function() {
                return function() {
                    function a(k) {
                        this.extent = 4096;
                        this.keys = [];
                        this.values = [];
                        for (this._pbfLayer = k.clone(); k.next();) switch (k.tag()) {
                            case 1:
                                this.name =
                                    k.getString();
                                break;
                            case 3:
                                this.keys.push(k.getString());
                                break;
                            case 4:
                                this.values.push(k.processMessage(a._parseValue));
                                break;
                            case 5:
                                this.extent = k.getUInt32();
                                break;
                            default:
                                k.skip()
                        }
                    }
                    a.prototype.getData = function() {
                        return this._pbfLayer
                    };
                    a._parseValue = function(k) {
                        for (; k.next();) switch (k.tag()) {
                            case 1:
                                return k.getString();
                            case 2:
                                return k.getFloat();
                            case 3:
                                return k.getDouble();
                            case 4:
                                return k.getInt64();
                            case 5:
                                return k.getUInt64();
                            case 6:
                                return k.getSInt64();
                            case 7:
                                return k.getBool();
                            default:
                                k.skip()
                        }
                        return null
                    };
                    return a
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/VertexMemoryBuffer": function() {
            define(["exports", "../../../../chunks/_rollupPluginBabelHelpers", "./MemoryBuffer", "./GeometryUtils"], function(a, k, w, t) {
                let r = function(e) {
                        function d(h) {
                            return e.call(this, h) || this
                        }
                        k._inheritsLoose(d, e);
                        d.prototype.add = function(h, p, l, n, u, y, x, q) {
                            const B = this.array;
                            h = w.i1616to32(h, p);
                            B.push(h);
                            h = w.i8888to32(Math.round(31 * l), Math.round(31 * n), Math.round(31 * u), Math.round(31 * y));
                            B.push(h);
                            h = w.i1616to32(x, 0);
                            B.push(h);
                            q && B.push(...q)
                        };
                        return d
                    }(w),
                    f = function(e) {
                        function d(h) {
                            return e.call(this, h) || this
                        }
                        k._inheritsLoose(d, e);
                        d.prototype.add = function(h, p, l) {
                            const n = this.array;
                            n.push(w.i1616to32(h, p));
                            l && n.push(...l)
                        };
                        return d
                    }(w),
                    b = function(e) {
                        function d(h) {
                            return e.call(this, h) || this
                        }
                        k._inheritsLoose(d, e);
                        d.prototype.add = function(h, p, l, n, u, y, x) {
                            const q = this.array,
                                B = this.index;
                            h = w.i1616to32(h, p);
                            q.push(h);
                            h = w.i8888to32(Math.round(15 * l), Math.round(15 * n), u, y);
                            q.push(h);
                            x && q.push(...x);
                            return B
                        };
                        return d
                    }(w),
                    c = function(e) {
                        function d(h) {
                            return e.call(this,
                                h) || this
                        }
                        k._inheritsLoose(d, e);
                        d.prototype.add = function(h, p, l, n, u, y, x, q, B, z, v, A) {
                            const m = this.array;
                            h = w.i1616to32(h, p);
                            m.push(h);
                            h = w.i1616to32(Math.round(8 * l), Math.round(8 * n));
                            m.push(h);
                            h = w.i8888to32(u / 4, y / 4, q, B);
                            m.push(h);
                            h = w.i8888to32(0, t.radToByte(x), 10 * z, Math.min(10 * v, 255));
                            m.push(h);
                            A && m.push(...A)
                        };
                        return d
                    }(w),
                    g = function(e) {
                        function d(h) {
                            return e.call(this, h) || this
                        }
                        k._inheritsLoose(d, e);
                        d.prototype.add = function(h, p, l, n, u) {
                            const y = this.array;
                            h = w.i1616to32(2 * h + l, 2 * p + n);
                            y.push(h);
                            u && y.push(...u)
                        };
                        return d
                    }(w);
                a.CircleVertexBuffer = g;
                a.FillVertexBuffer = f;
                a.LineVertexBuffer = r;
                a.OutlineVertexBuffer = b;
                a.SymbolVertexBuffer = c;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/buckets/CircleBucket": function() {
            define(["../../../../../chunks/_rollupPluginBabelHelpers", "./BaseBucket"], function(a, k) {
                return function(w) {
                    function t(f, b, c, g) {
                        f = w.call(this, f, b) || this;
                        f.type = 4;
                        f._circleVertexBuffer = c;
                        f._circleIndexBuffer = g;
                        return f
                    }
                    a._inheritsLoose(t, w);
                    var r = t.prototype;
                    r.processFeatures = function(f) {
                        const b = this._circleVertexBuffer,
                            c = this._circleIndexBuffer;
                        this._circleIndexStart = 3 * c.index;
                        this._circleIndexCount = 0;
                        const g = this.layer,
                            e = this.zoom;
                        f && f.setExtent(this.layerExtent);
                        for (const h of this._features) {
                            var d = h.getGeometry(f);
                            if (!d) continue;
                            const p = g.circleMaterial.encodeAttributes(h, e, g);
                            for (const l of d)
                                if (l)
                                    for (const n of l) d = b.index, b.add(n.x, n.y, 0, 0, p), b.add(n.x, n.y, 0, 1, p), b.add(n.x, n.y, 1, 0, p), b.add(n.x, n.y, 1, 1, p), c.add(d + 0, d + 1, d + 2), c.add(d + 1, d + 2, d + 3), this._circleIndexCount +=
                                        6
                        }
                    };
                    r.serialize = function() {
                        var f = 6 + this.layerUIDs.length;
                        f += this._circleVertexBuffer.array.length;
                        f += this._circleIndexBuffer.array.length;
                        f = new Uint32Array(f);
                        var b = new Int32Array(f.buffer);
                        let c = 0;
                        f[c++] = this.type;
                        f[c++] = this.layerUIDs.length;
                        for (var g = 0; g < this.layerUIDs.length; g++) f[c++] = this.layerUIDs[g];
                        f[c++] = this._circleIndexStart;
                        f[c++] = this._circleIndexCount;
                        f[c++] = this._circleVertexBuffer.array.length;
                        for (g = 0; g < this._circleVertexBuffer.array.length; g++) b[c++] = this._circleVertexBuffer.array[g];
                        f[c++] = this._circleIndexBuffer.array.length;
                        for (b = 0; b < this._circleIndexBuffer.array.length; b++) f[c++] = this._circleIndexBuffer.array[b];
                        return f.buffer
                    };
                    a._createClass(t, [{
                        key: "circleIndexStart",
                        get: function() {
                            return this._circleIndexStart
                        }
                    }, {
                        key: "circleIndexCount",
                        get: function() {
                            return this._circleIndexCount
                        }
                    }]);
                    return t
                }(k)
            })
        },
        "esri/views/2d/engine/vectorTiles/buckets/BaseBucket": function() {
            define(function() {
                return function() {
                    function a(w, t) {
                        this.layerExtent = 4096;
                        this._features = [];
                        this.layer = w;
                        this.zoom =
                            t;
                        this._filter = w.getFeatureFilter()
                    }
                    var k = a.prototype;
                    k.pushFeature = function(w) {
                        this._filter && !this._filter.filter(w, this.zoom) || this._features.push(w)
                    };
                    k.hasFeatures = function() {
                        return 0 < this._features.length
                    };
                    return a
                }()
            })
        },
        "esri/views/2d/engine/vectorTiles/buckets/FillBucket": function() {
            define("../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/ArrayPool ../../../../../core/libs/earcut/earcut ../../webgl/Geometry ../../webgl/mesh/Tesselator ./BaseBucket".split(" "), function(a, k,
                w, t, r, f) {
                const b = new r;
                return function(c) {
                    function g(d, h, p, l, n, u) {
                        d = c.call(this, d, h) || this;
                        d.type = 1;
                        d._fillVertexBuffer = p;
                        d._fillIndexBuffer = l;
                        d._outlineVertexBuffer = n;
                        d._outlineIndexBuffer = u;
                        return d
                    }
                    a._inheritsLoose(g, c);
                    var e = g.prototype;
                    e.processFeatures = function(d) {
                        this._fillIndexStart = 3 * this._fillIndexBuffer.index;
                        this._fillIndexCount = 0;
                        this._outlineIndexStart = 3 * this._outlineIndexBuffer.index;
                        this._outlineIndexCount = 0;
                        const h = this.layer,
                            p = this.zoom;
                        d && d.setExtent(this.layerExtent);
                        let l = void 0 ===
                            h.getPaintValue("fill-pattern", p) && h.getPaintValue("fill-antialias", p);
                        if (h.outlineUsesFillColor) {
                            if (l && !h.hasDataDrivenOpacity) {
                                var n = h.getPaintValue("fill-opacity", p),
                                    u = h.getPaintValue("fill-opacity", p + 1);
                                1 > n && 1 > u && (l = !1)
                            }
                            l && !h.hasDataDrivenColor && (n = h.getPaintValue("fill-color", p), u = h.getPaintValue("fill-color", p + 1), 1 > n[3] && 1 > u[3] && (l = !1))
                        }
                        const {
                            fillMaterial: y,
                            outlineMaterial: x,
                            hasDataDrivenFill: q,
                            hasDataDrivenOutline: B
                        } = h;
                        for (const z of this._features) {
                            n = q ? y.encodeAttributes(z, p, h) : null;
                            u = l &&
                                B ? x.encodeAttributes(z, p, h) : null;
                            const v = z.getGeometry(d);
                            this._processFeature(v, l, h.outlineUsesFillColor, n, u, null == d ? void 0 : d.validateTessellation)
                        }
                    };
                    e.serialize = function() {
                        var d = 10 + this.layerUIDs.length;
                        d += this._fillVertexBuffer.array.length;
                        d += this._fillIndexBuffer.array.length;
                        d += this._outlineVertexBuffer.array.length;
                        d += this._outlineIndexBuffer.array.length;
                        d = new Uint32Array(d);
                        var h = new Int32Array(d.buffer);
                        let p = 0;
                        d[p++] = this.type;
                        d[p++] = this.layerUIDs.length;
                        for (var l = 0; l < this.layerUIDs.length; l++) d[p++] =
                            this.layerUIDs[l];
                        d[p++] = this._fillIndexStart;
                        d[p++] = this._fillIndexCount;
                        d[p++] = this._outlineIndexStart;
                        d[p++] = this._outlineIndexCount;
                        d[p++] = this._fillVertexBuffer.array.length;
                        for (l = 0; l < this._fillVertexBuffer.array.length; l++) h[p++] = this._fillVertexBuffer.array[l];
                        d[p++] = this._fillIndexBuffer.array.length;
                        for (l = 0; l < this._fillIndexBuffer.array.length; l++) d[p++] = this._fillIndexBuffer.array[l];
                        d[p++] = this._outlineVertexBuffer.array.length;
                        for (l = 0; l < this._outlineVertexBuffer.array.length; l++) h[p++] =
                            this._outlineVertexBuffer.array[l];
                        d[p++] = this._outlineIndexBuffer.array.length;
                        for (h = 0; h < this._outlineIndexBuffer.array.length; h++) d[p++] = this._outlineIndexBuffer.array[h];
                        return d.buffer
                    };
                    e._processFeature = function(d, h, p, l, n, u) {
                        if (d) {
                            var y = d.length,
                                x = !n || 0 === n.length;
                            if (h && (!p || x))
                                for (h = 0; h < y; h++) this._processOutline(d[h], n);
                            for (n = 0; n < y; n++)
                                if (h = g._area(d[n]), 128 < h) {
                                    void 0 !== q && this._processFill(d, q, l, u);
                                    var q = [n]
                                } else -128 > h && void 0 !== q && q.push(n);
                            void 0 !== q && this._processFill(d, q, l, u)
                        }
                    };
                    e._processOutline =
                        function(d, h) {
                            const p = this._outlineVertexBuffer,
                                l = this._outlineIndexBuffer,
                                n = l.index;
                            var u;
                            let y, x;
                            const q = new t.Point(0, 0),
                                B = new t.Point(0, 0),
                                z = new t.Point(0, 0);
                            let v = -1,
                                A = -1;
                            var m = -1;
                            let E = -1,
                                C = -1,
                                G = !1,
                                F = d.length;
                            if (!(2 > F)) {
                                var D = d[0];
                                for (u = d[F - 1]; F && u.isEqual(D);) --F, u = d[F - 1];
                                if (!(2 > F - 0)) {
                                    for (D = 0; D < F; ++D) {
                                        0 === D ? (u = d[F - 1], y = d[0], x = d[1], q.assignSub(y, u), q.normalize(), q.rightPerpendicular()) : (u = y, y = x, x = D !== F - 1 ? d[D + 1] : d[0], q.assign(B));
                                        u = this._isClipEdge(u, y); - 1 === E && (G = u);
                                        B.assignSub(x, y);
                                        B.normalize();
                                        B.rightPerpendicular();
                                        m = q.x * B.y - q.y * B.x;
                                        z.assignAdd(q, B);
                                        z.normalize();
                                        var H = -z.x * -q.x + -z.y * -q.y;
                                        H = Math.abs(0 !== H ? 1 / H : 1);
                                        8 < H && (H = 8);
                                        0 <= m ? (m = p.add(y.x, y.y, q.x, q.y, 0, 1, h), -1 === E && (E = m), 0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m), A = p.add(y.x, y.y, H * -z.x, H * -z.y, 0, -1, h), -1 === C && (C = A), 0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m), v = A, A = m, m = p.add(y.x, y.y, z.x, z.y, 0, 1, h), 0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m), A = p.add(y.x, y.y, B.x, B.y, 0, 1, h)) : (m = p.add(y.x, y.y, H * z.x, H * z.y, 0, 1, h), -1 === E && (E = m), 0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m), A = p.add(y.x,
                                            y.y, -q.x, -q.y, 0, -1, h), -1 === C && (C = A), 0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m), v = A, A = m, m = p.add(y.x, y.y, -z.x, -z.y, 0, -1, h), 0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m), v = p.add(y.x, y.y, -B.x, -B.y, 0, -1, h));
                                        0 <= v && 0 <= A && 0 <= m && !u && l.add(v, A, m)
                                    }
                                    0 <= v && 0 <= A && 0 <= E && !G && l.add(v, A, E);
                                    0 <= v && 0 <= E && 0 <= C && !G && l.add(v, C, E);
                                    this._outlineIndexCount += 3 * (l.index - n)
                                }
                            }
                        };
                    e._processFill = function(d, h, p, l) {
                        var n;
                        1 < h.length && (n = []);
                        var u = 0;
                        for (var y of h) 0 !== u && n.push(u), u += d[y].length;
                        y = 2 * u;
                        u = k.acquire();
                        for (var x of h) {
                            var q = d[x];
                            const z = q.length;
                            for (let v = 0; v < z; ++v) u.push(q[v].x, q[v].y)
                        }
                        x = w.earcut(u, n, 2);
                        if (l && 0 < w.deviation(u, n, 2, x)) {
                            l = [];
                            y = [];
                            b.beginPolygon(l, y);
                            for (var B of h)
                                if (h = d[B], !(3 > h.length)) {
                                    b.beginContour();
                                    for (n = 0; n < h.length; ++n) x = h[n].x, q = h[n].y, x = [x, q, 0], b.addVertex(x, x);
                                    b.endContour()
                                }
                            b.endPolygon();
                            if (0 < y.length) {
                                d = this._fillVertexBuffer.index;
                                for (B = 0; B < l.length;) this._fillVertexBuffer.add(l[B++], l[B++], p);
                                for (p = 0; p < y.length;) this._fillIndexBuffer.add(d + y[p + 0], d + y[p + 1], d + y[p + 2]), p += 3;
                                this._fillIndexCount += y.length
                            }
                        } else if (d =
                            x.length, 0 < d) {
                            B = this._fillVertexBuffer.index;
                            for (h = 0; h < y;) this._fillVertexBuffer.add(u[h++], u[h++], p);
                            for (p = 0; p < d;) this._fillIndexBuffer.add(B + x[p++], B + x[p++], B + x[p++]);
                            this._fillIndexCount += d
                        }
                        k.release(u)
                    };
                    e._isClipEdge = function(d, h) {
                        return d.x === h.x ? -64 >= d.x || 4160 <= d.x : d.y === h.y ? -64 >= d.y || 4160 <= d.y : !1
                    };
                    g._area = function(d) {
                        let h = 0;
                        const p = d.length - 1;
                        for (let l = 0; l < p; l++) h += (d[l].x - d[l + 1].x) * (d[l].y + d[l + 1].y);
                        h += (d[p].x - d[0].x) * (d[p].y + d[0].y);
                        return .5 * h
                    };
                    a._createClass(g, [{
                            key: "fillIndexStart",
                            get: function() {
                                return this._fillIndexStart
                            }
                        },
                        {
                            key: "fillIndexCount",
                            get: function() {
                                return this._fillIndexCount
                            }
                        }, {
                            key: "outlineIndexStart",
                            get: function() {
                                return this._outlineIndexStart
                            }
                        }, {
                            key: "outlineIndexCount",
                            get: function() {
                                return this._outlineIndexCount
                            }
                        }
                    ]);
                    return g
                }(f)
            })
        },
        "esri/core/libs/earcut/earcut": function() {
            define(["exports"], function(a) {
                function k(z, v, A, m, E) {
                    let C;
                    if (E === 0 < p(z, v, A, m))
                        for (; v < A; v += m) C = f(v, z[v], z[v + 1], C);
                    else
                        for (A -= m; A >= v; A -= m) C = f(A, z[A], z[A + 1], C);
                    C && y(C, C.next) && (b(C), C = C.next);
                    return C
                }

                function w(z, v = z) {
                    if (!z) return z;
                    let A;
                    do
                        if (A = !1, z.steiner || !y(z, z.next) && 0 !== d(z.prev, z, z.next)) z = z.next;
                        else {
                            b(z);
                            z = v = z.prev;
                            if (z === z.next) break;
                            A = !0
                        }
                    while (A || z !== v);
                    return v
                }

                function t(z, v, A, m, E, C, G = 0) {
                    if (z) {
                        !G && C && (z = e(z, m, E, C));
                        for (var F = z; z.prev !== z.next;) {
                            var D = z.prev,
                                H = z.next;
                            if (C) var I = r(z, m, E, C);
                            else a: {
                                I = z;
                                var Q = I.prev,
                                    P = I;
                                const Y = I.next;
                                if (0 <= d(Q, P, Y)) {
                                    I = !1;
                                    break a
                                }
                                let W = I.next.next;
                                const X = W;
                                let ba = 0;
                                for (; W !== I.prev && (0 === ba || W !== X);) {
                                    ba++;
                                    if (l(Q.x, Q.y, P.x, P.y, Y.x, Y.y, W.x, W.y) && 0 <= d(W.prev, W, W.next)) {
                                        I = !1;
                                        break a
                                    }
                                    W =
                                        W.next
                                }
                                I = !0
                            }
                            if (I) v.push(D.index / A), v.push(z.index / A), v.push(H.index / A), b(z), F = z = H.next;
                            else if (z = H, z === F) {
                                if (!G) t(w(z), v, A, m, E, C, 1);
                                else if (1 === G) {
                                    G = v;
                                    F = A;
                                    D = z;
                                    do H = D.prev, I = D.next.next, !y(H, I) && h(H, D, D.next, I) && n(H, I) && n(I, H) && (G.push(H.index / F), G.push(D.index / F), G.push(I.index / F), b(D), b(D.next), D = z = I), D = D.next; while (D !== z);
                                    z = D;
                                    t(z, v, A, m, E, C, 2)
                                } else if (2 === G) a: {
                                    G = z;do {
                                        for (F = G.next.next; F !== G.prev;) {
                                            if (D = G.index !== F.index) {
                                                I = I = I = void 0;
                                                D = G;
                                                H = F;
                                                if (I = D.next.index !== H.index && D.prev.index !== H.index) {
                                                    b: {
                                                        I =
                                                        D;do {
                                                            if (I.index !== D.index && I.next.index !== D.index && I.index !== H.index && I.next.index !== H.index && h(I, I.next, D, H)) {
                                                                I = !0;
                                                                break b
                                                            }
                                                            I = I.next
                                                        } while (I !== D);I = !1
                                                    }
                                                    I = !I
                                                }
                                                if (I = I && n(D, H) && n(H, D)) {
                                                    I = D;
                                                    Q = !1;
                                                    P = (D.x + H.x) / 2;
                                                    H = (D.y + H.y) / 2;
                                                    do I.y > H !== I.next.y > H && I.next.y !== I.y && P < (I.next.x - I.x) * (H - I.y) / (I.next.y - I.y) + I.x && (Q = !Q), I = I.next; while (I !== D);
                                                    I = Q
                                                }
                                                D = I
                                            }
                                            if (D) {
                                                z = q(G, F);
                                                G = w(G, G.next);
                                                z = w(z, z.next);
                                                t(G, v, A, m, E, C);
                                                t(z, v, A, m, E, C);
                                                break a
                                            }
                                            F = F.next
                                        }
                                        G = G.next
                                    } while (G !== z)
                                }
                                break
                            }
                        }
                    }
                }

                function r(z, v, A, m) {
                    const E = z.prev,
                        C = z.next;
                    if (0 <= d(E, z, C)) return !1;
                    const G = E.x > z.x ? E.x > C.x ? E.x : C.x : z.x > C.x ? z.x : C.x,
                        F = E.y > z.y ? E.y > C.y ? E.y : C.y : z.y > C.y ? z.y : C.y,
                        D = u(E.x < z.x ? E.x < C.x ? E.x : C.x : z.x < C.x ? z.x : C.x, E.y < z.y ? E.y < C.y ? E.y : C.y : z.y < C.y ? z.y : C.y, v, A, m);
                    v = u(G, F, v, A, m);
                    A = z.prevZ;
                    for (m = z.nextZ; A && A.z >= D && m && m.z <= v;) {
                        if (A !== z.prev && A !== z.next && l(E.x, E.y, z.x, z.y, C.x, C.y, A.x, A.y) && 0 <= d(A.prev, A, A.next)) return !1;
                        A = A.prevZ;
                        if (m !== z.prev && m !== z.next && l(E.x, E.y, z.x, z.y, C.x, C.y, m.x, m.y) && 0 <= d(m.prev, m, m.next)) return !1;
                        m = m.nextZ
                    }
                    for (; A && A.z >= D;) {
                        if (A !== z.prev &&
                            A !== z.next && l(E.x, E.y, z.x, z.y, C.x, C.y, A.x, A.y) && 0 <= d(A.prev, A, A.next)) return !1;
                        A = A.prevZ
                    }
                    for (; m && m.z <= v;) {
                        if (m !== z.prev && m !== z.next && l(E.x, E.y, z.x, z.y, C.x, C.y, m.x, m.y) && 0 <= d(m.prev, m, m.next)) return !1;
                        m = m.nextZ
                    }
                    return !0
                }

                function f(z, v, A, m) {
                    z = new B(z, v, A);
                    m ? (z.next = m.next, z.prev = m, m.next.prev = z, m.next = z) : (z.prev = z, z.next = z);
                    return z
                }

                function b(z) {
                    z.next.prev = z.prev;
                    z.prev.next = z.next;
                    z.prevZ && (z.prevZ.nextZ = z.nextZ);
                    z.nextZ && (z.nextZ.prevZ = z.prevZ)
                }

                function c(z) {
                    let v = z,
                        A = z;
                    do {
                        if (v.x < A.x || v.x === A.x &&
                            v.y < A.y) A = v;
                        v = v.next
                    } while (v !== z);
                    return A
                }

                function g(z, v) {
                    let A = v;
                    const m = z.x,
                        E = z.y;
                    let C = -Infinity,
                        G;
                    do {
                        if (E <= A.y && E >= A.next.y && A.next.y !== A.y) {
                            var F = A.x + (E - A.y) * (A.next.x - A.x) / (A.next.y - A.y);
                            if (F <= m && F > C) {
                                C = F;
                                if (F === m) {
                                    if (E === A.y) return A;
                                    if (E === A.next.y) return A.next
                                }
                                G = A.x < A.next.x ? A : A.next
                            }
                        }
                        A = A.next
                    } while (A !== v);
                    if (!G) return null;
                    if (m === C) return G.prev;
                    v = G;
                    F = G.x;
                    const D = G.y;
                    let H = Infinity,
                        I;
                    for (A = G.next; A !== v;) m >= A.x && A.x >= F && m !== A.x && l(E < D ? m : C, E, F, D, E < D ? C : m, E, A.x, A.y) && (I = Math.abs(E - A.y) / (m -
                        A.x), (I < H || I === H && A.x > G.x) && n(A, z) && (G = A, H = I)), A = A.next;
                    return G
                }

                function e(z, v, A, m) {
                    for (var E; E !== z; E = E.next) {
                        E = E || z;
                        null === E.z && (E.z = u(E.x, E.y, v, A, m));
                        if (E.prev.next !== E || E.next.prev !== E) return E.prev.next = E, E.next.prev = E, e(z, v, A, m);
                        E.prevZ = E.prev;
                        E.nextZ = E.next
                    }
                    z.prevZ.nextZ = null;
                    z.prevZ = null;
                    a: for (A = 1;;) {
                        m = z;
                        v = z = null;
                        let C = 0;
                        for (; m;) {
                            C++;
                            E = m;
                            let G = 0;
                            for (; G < A && E; G++) E = E.nextZ;
                            let F = A;
                            for (; 0 < G || 0 < F && E;) {
                                let D;
                                0 === G ? (D = E, E = E.nextZ, F--) : 0 !== F && E ? m.z <= E.z ? (D = m, m = m.nextZ, G--) : (D = E, E = E.nextZ, F--) : (D =
                                    m, m = m.nextZ, G--);
                                v ? v.nextZ = D : z = D;
                                D.prevZ = v;
                                v = D
                            }
                            m = E
                        }
                        v.nextZ = null;
                        A *= 2;
                        if (2 > C) break a
                    }
                    return z
                }

                function d(z, v, A) {
                    return (v.y - z.y) * (A.x - v.x) - (v.x - z.x) * (A.y - v.y)
                }

                function h(z, v, A, m) {
                    return y(z, v) && y(A, m) || y(z, m) && y(A, v) ? !0 : 0 < d(z, v, A) !== 0 < d(z, v, m) && 0 < d(A, m, z) !== 0 < d(A, m, v)
                }

                function p(z, v, A, m) {
                    let E = 0;
                    for (let C = v, G = A - m; C < A; C += m) E += (z[G] - z[C]) * (z[C + 1] + z[G + 1]), G = C;
                    return E
                }

                function l(z, v, A, m, E, C, G, F) {
                    return 0 <= (E - G) * (v - F) - (z - G) * (C - F) && 0 <= (z - G) * (m - F) - (A - G) * (v - F) && 0 <= (A - G) * (C - F) - (E - G) * (m - F)
                }

                function n(z, v) {
                    return 0 >
                        d(z.prev, z, z.next) ? 0 <= d(z, v, z.next) && 0 <= d(z, z.prev, v) : 0 > d(z, v, z.prev) || 0 > d(z, z.next, v)
                }

                function u(z, v, A, m, E) {
                    z = 32767 * (z - A) * E;
                    v = 32767 * (v - m) * E;
                    z = (z | z << 8) & 16711935;
                    z = (z | z << 4) & 252645135;
                    z = (z | z << 2) & 858993459;
                    v = (v | v << 8) & 16711935;
                    v = (v | v << 4) & 252645135;
                    v = (v | v << 2) & 858993459;
                    return (z | z << 1) & 1431655765 | ((v | v << 1) & 1431655765) << 1
                }

                function y(z, v) {
                    return z.x === v.x && z.y === v.y
                }

                function x(z, v) {
                    return z.x - v.x
                }

                function q(z, v) {
                    const A = new B(z.index, z.x, z.y),
                        m = new B(v.index, v.x, v.y),
                        E = z.next,
                        C = v.prev;
                    z.next = v;
                    v.prev = z;
                    A.next =
                        E;
                    E.prev = A;
                    m.next = A;
                    A.prev = m;
                    C.next = m;
                    m.prev = C;
                    return m
                }
                let B = function(z, v, A) {
                    this.index = z;
                    this.x = v;
                    this.y = A;
                    this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
                    this.steiner = !1
                };
                a.deviation = function(z, v, A, m) {
                    var E = v && v.length;
                    let C = Math.abs(p(z, 0, E ? v[0] * A : z.length, A));
                    if (E)
                        for (let G = 0, F = v.length; G < F; G++) C -= Math.abs(p(z, v[G] * A, G < F - 1 ? v[G + 1] * A : z.length, A));
                    v = 0;
                    for (E = 0; E < m.length; E += 3) {
                        const G = m[E] * A,
                            F = m[E + 1] * A,
                            D = m[E + 2] * A;
                        v += Math.abs((z[G] - z[D]) * (z[F + 1] - z[G + 1]) - (z[G] - z[F]) * (z[D + 1] - z[G + 1]))
                    }
                    return 0 ===
                        C && 0 === v ? 0 : Math.abs((v - C) / C)
                };
                a.earcut = function(z, v, A) {
                    var m = v && v.length;
                    const E = m ? v[0] * A : z.length;
                    var C = k(z, 0, E, A, !0);
                    const G = [];
                    if (!C || C.next === C.prev) return G;
                    let F, D;
                    var H, I;
                    if (m) {
                        m = [];
                        for (let P = 0, Y = v.length; P < Y; P++) {
                            var Q = k(z, v[P] * A, P < Y - 1 ? v[P + 1] * A : z.length, A, !1);
                            Q === Q.next && (Q.steiner = !0);
                            m.push(c(Q))
                        }
                        m.sort(x);
                        for (I of m) {
                            v = I;
                            m = C;
                            if (m = g(v, m)) v = q(m, v), w(v, v.next);
                            C = w(C, C.next)
                        }
                    }
                    if (z.length > 80 * A) {
                        F = H = z[0];
                        D = I = z[1];
                        for (v = A; v < E; v += A) m = z[v], Q = z[v + 1], F = Math.min(F, m), D = Math.min(D, Q), H = Math.max(H, m),
                            I = Math.max(I, Q);
                        H = Math.max(H - F, I - D);
                        H = 0 !== H ? 1 / H : 0
                    }
                    t(C, G, A, F, D, H);
                    return G
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/webgl/mesh/Tesselator": function() {
            define(["../../../../../core/Logger", "../../../../../chunks/_commonjsHelpers"], function(a, k) {
                var w = k.createCommonjsModule(function(r) {
                    (function(f) {
                        f = f();
                        void 0 !== f && (r.exports = f)
                    })(function() {
                        var f = {
                            DEBUG: !1,
                            assert: function(b, c) {
                                if (f.DEBUG && !b) throw Error("Assertion failed" + (c ? ": " + c : ""));
                            },
                            GLU_TESS_MAX_COORD: 1E150,
                            TRUE_PROJECT: !1,
                            GLU_TESS_DEFAULT_TOLERANCE: 0,
                            windingRule: {
                                GLU_TESS_WINDING_ODD: 100130,
                                GLU_TESS_WINDING_NONZERO: 100131,
                                GLU_TESS_WINDING_POSITIVE: 100132,
                                GLU_TESS_WINDING_NEGATIVE: 100133,
                                GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
                            },
                            primitiveType: {
                                GL_LINE_LOOP: 2,
                                GL_TRIANGLES: 4,
                                GL_TRIANGLE_STRIP: 5,
                                GL_TRIANGLE_FAN: 6
                            },
                            errorType: {
                                GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
                                GLU_TESS_MISSING_END_POLYGON: 100153,
                                GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
                                GLU_TESS_MISSING_END_CONTOUR: 100154,
                                GLU_TESS_COORD_TOO_LARGE: 100155,
                                GLU_TESS_NEED_COMBINE_CALLBACK: 100156
                            },
                            gluEnum: {
                                GLU_TESS_BEGIN: 100100,
                                GLU_TESS_VERTEX: 100101,
                                GLU_TESS_END: 100102,
                                GLU_TESS_ERROR: 100103,
                                GLU_TESS_EDGE_FLAG: 100104,
                                GLU_TESS_COMBINE: 100105,
                                GLU_TESS_BEGIN_DATA: 100106,
                                GLU_TESS_VERTEX_DATA: 100107,
                                GLU_TESS_END_DATA: 100108,
                                GLU_TESS_ERROR_DATA: 100109,
                                GLU_TESS_EDGE_FLAG_DATA: 100110,
                                GLU_TESS_COMBINE_DATA: 100111,
                                GLU_TESS_MESH: 100112,
                                GLU_TESS_TOLERANCE: 100142,
                                GLU_TESS_WINDING_RULE: 100140,
                                GLU_TESS_BOUNDARY_ONLY: 100141,
                                GLU_INVALID_ENUM: 100900,
                                GLU_INVALID_VALUE: 100901
                            },
                            geom: {}
                        };
                        f.geom.vertEq = function(b,
                            c) {
                            return b.s === c.s && b.t === c.t
                        };
                        f.geom.vertLeq = function(b, c) {
                            return b.s < c.s || b.s === c.s && b.t <= c.t
                        };
                        f.geom.edgeEval = function(b, c, g) {
                            f.assert(f.geom.vertLeq(b, c) && f.geom.vertLeq(c, g));
                            var e = c.s - b.s,
                                d = g.s - c.s;
                            return 0 < e + d ? e < d ? c.t - b.t + e / (e + d) * (b.t - g.t) : c.t - g.t + d / (e + d) * (g.t - b.t) : 0
                        };
                        f.geom.edgeSign = function(b, c, g) {
                            f.assert(f.geom.vertLeq(b, c) && f.geom.vertLeq(c, g));
                            var e = c.s - b.s,
                                d = g.s - c.s;
                            return 0 < e + d ? (c.t - g.t) * e + (c.t - b.t) * d : 0
                        };
                        f.geom.transLeq = function(b, c) {
                            return b.t < c.t || b.t === c.t && b.s <= c.s
                        };
                        f.geom.transEval =
                            function(b, c, g) {
                                f.assert(f.geom.transLeq(b, c) && f.geom.transLeq(c, g));
                                var e = c.t - b.t,
                                    d = g.t - c.t;
                                return 0 < e + d ? e < d ? c.s - b.s + e / (e + d) * (b.s - g.s) : c.s - g.s + d / (e + d) * (g.s - b.s) : 0
                            };
                        f.geom.transSign = function(b, c, g) {
                            f.assert(f.geom.transLeq(b, c) && f.geom.transLeq(c, g));
                            var e = c.t - b.t,
                                d = g.t - c.t;
                            return 0 < e + d ? (c.s - g.s) * e + (c.s - b.s) * d : 0
                        };
                        f.geom.edgeGoesLeft = function(b) {
                            return f.geom.vertLeq(b.dst(), b.org)
                        };
                        f.geom.edgeGoesRight = function(b) {
                            return f.geom.vertLeq(b.org, b.dst())
                        };
                        f.geom.vertL1dist = function(b, c) {
                            return Math.abs(b.s -
                                c.s) + Math.abs(b.t - c.t)
                        };
                        f.geom.vertCCW = function(b, c, g) {
                            return 0 <= b.s * (c.t - g.t) + c.s * (g.t - b.t) + g.s * (b.t - c.t)
                        };
                        f.geom.interpolate_ = function(b, c, g, e) {
                            b = 0 > b ? 0 : b;
                            g = 0 > g ? 0 : g;
                            return b <= g ? 0 === g ? (c + e) / 2 : c + b / (b + g) * (e - c) : e + g / (b + g) * (c - e)
                        };
                        f.geom.edgeIntersect = function(b, c, g, e, d) {
                            if (!f.geom.vertLeq(b, c)) {
                                var h = b;
                                b = c;
                                c = h
                            }
                            f.geom.vertLeq(g, e) || (h = g, g = e, e = h);
                            f.geom.vertLeq(b, g) || (h = b, b = g, g = h, h = c, c = e, e = h);
                            if (f.geom.vertLeq(g, c))
                                if (f.geom.vertLeq(c, e)) {
                                    h = f.geom.edgeEval(b, g, c);
                                    var p = f.geom.edgeEval(g, c, e);
                                    0 > h + p && (h = -h,
                                        p = -p);
                                    d.s = f.geom.interpolate_(h, g.s, p, c.s)
                                } else h = f.geom.edgeSign(b, g, c), p = -f.geom.edgeSign(b, e, c), 0 > h + p && (h = -h, p = -p), d.s = f.geom.interpolate_(h, g.s, p, e.s);
                            else d.s = (g.s + c.s) / 2;
                            f.geom.transLeq(b, c) || (h = b, b = c, c = h);
                            f.geom.transLeq(g, e) || (h = g, g = e, e = h);
                            f.geom.transLeq(b, g) || (h = b, b = g, g = h, h = c, c = e, e = h);
                            f.geom.transLeq(g, c) ? f.geom.transLeq(c, e) ? (h = f.geom.transEval(b, g, c), p = f.geom.transEval(g, c, e), 0 > h + p && (h = -h, p = -p), d.t = f.geom.interpolate_(h, g.t, p, c.t)) : (h = f.geom.transSign(b, g, c), p = -f.geom.transSign(b, e, c),
                                0 > h + p && (h = -h, p = -p), d.t = f.geom.interpolate_(h, g.t, p, e.t)) : d.t = (g.t + c.t) / 2
                        };
                        f.mesh = {};
                        f.mesh.makeEdge = function(b) {
                            var c = f.mesh.makeEdgePair_(b.eHead);
                            f.mesh.makeVertex_(c, b.vHead);
                            f.mesh.makeVertex_(c.sym, b.vHead);
                            f.mesh.makeFace_(c, b.fHead);
                            return c
                        };
                        f.mesh.meshSplice = function(b, c) {
                            var g = !1,
                                e = !1;
                            b !== c && (c.org !== b.org && (e = !0, f.mesh.killVertex_(c.org, b.org)), c.lFace !== b.lFace && (g = !0, f.mesh.killFace_(c.lFace, b.lFace)), f.mesh.splice_(c, b), e || (f.mesh.makeVertex_(c, b.org), b.org.anEdge = b), g || (f.mesh.makeFace_(c,
                                b.lFace), b.lFace.anEdge = b))
                        };
                        f.mesh.deleteEdge = function(b) {
                            var c = b.sym,
                                g = !1;
                            b.lFace !== b.rFace() && (g = !0, f.mesh.killFace_(b.lFace, b.rFace()));
                            b.oNext === b ? f.mesh.killVertex_(b.org, null) : (b.rFace().anEdge = b.oPrev(), b.org.anEdge = b.oNext, f.mesh.splice_(b, b.oPrev()), g || f.mesh.makeFace_(b, b.lFace));
                            c.oNext === c ? (f.mesh.killVertex_(c.org, null), f.mesh.killFace_(c.lFace, null)) : (b.lFace.anEdge = c.oPrev(), c.org.anEdge = c.oNext, f.mesh.splice_(c, c.oPrev()));
                            f.mesh.killEdge_(b)
                        };
                        f.mesh.addEdgeVertex = function(b) {
                            var c =
                                f.mesh.makeEdgePair_(b),
                                g = c.sym;
                            f.mesh.splice_(c, b.lNext);
                            c.org = b.dst();
                            f.mesh.makeVertex_(g, c.org);
                            c.lFace = g.lFace = b.lFace;
                            return c
                        };
                        f.mesh.splitEdge = function(b) {
                            var c = f.mesh.addEdgeVertex(b).sym;
                            f.mesh.splice_(b.sym, b.sym.oPrev());
                            f.mesh.splice_(b.sym, c);
                            b.sym.org = c.org;
                            c.dst().anEdge = c.sym;
                            c.sym.lFace = b.rFace();
                            c.winding = b.winding;
                            c.sym.winding = b.sym.winding;
                            return c
                        };
                        f.mesh.connect = function(b, c) {
                            var g = !1,
                                e = f.mesh.makeEdgePair_(b),
                                d = e.sym;
                            c.lFace !== b.lFace && (g = !0, f.mesh.killFace_(c.lFace, b.lFace));
                            f.mesh.splice_(e, b.lNext);
                            f.mesh.splice_(d, c);
                            e.org = b.dst();
                            d.org = c.org;
                            e.lFace = d.lFace = b.lFace;
                            b.lFace.anEdge = d;
                            g || f.mesh.makeFace_(e, b.lFace);
                            return e
                        };
                        f.mesh.zapFace = function(b) {
                            var c = b.anEdge,
                                g = c.lNext;
                            do {
                                var e = g;
                                g = e.lNext;
                                e.lFace = null;
                                if (null === e.rFace()) {
                                    e.oNext === e ? f.mesh.killVertex_(e.org, null) : (e.org.anEdge = e.oNext, f.mesh.splice_(e, e.oPrev()));
                                    var d = e.sym;
                                    d.oNext === d ? f.mesh.killVertex_(d.org, null) : (d.org.anEdge = d.oNext, f.mesh.splice_(d, d.oPrev()));
                                    f.mesh.killEdge_(e)
                                }
                            } while (e !== c);
                            c = b.prev;
                            b = b.next;
                            b.prev = c;
                            c.next = b
                        };
                        f.mesh.meshUnion = function(b, c) {
                            var g = b.fHead,
                                e = b.vHead,
                                d = b.eHead,
                                h = c.fHead,
                                p = c.vHead;
                            c = c.eHead;
                            h.next !== h && (g.prev.next = h.next, h.next.prev = g.prev, h.prev.next = g, g.prev = h.prev);
                            p.next !== p && (e.prev.next = p.next, p.next.prev = e.prev, p.prev.next = e, e.prev = p.prev);
                            c.next !== c && (d.sym.next.sym.next = c.next, c.next.sym.next = d.sym.next, c.sym.next.sym.next = d, d.sym.next = c.sym.next);
                            return b
                        };
                        f.mesh.deleteMesh = function(b) {};
                        f.mesh.makeEdgePair_ = function(b) {
                            var c = new f.GluHalfEdge,
                                g = new f.GluHalfEdge,
                                e = b.sym.next;
                            g.next = e;
                            e.sym.next = c;
                            c.next = b;
                            b.sym.next = g;
                            c.sym = g;
                            c.oNext = c;
                            c.lNext = g;
                            g.sym = c;
                            g.oNext = g;
                            return g.lNext = c
                        };
                        f.mesh.splice_ = function(b, c) {
                            var g = b.oNext,
                                e = c.oNext;
                            g.sym.lNext = c;
                            e.sym.lNext = b;
                            b.oNext = e;
                            c.oNext = g
                        };
                        f.mesh.makeVertex_ = function(b, c) {
                            var g = c.prev,
                                e = new f.GluVertex(c, g);
                            g.next = e;
                            c.prev = e;
                            c = e.anEdge = b;
                            do c.org = e, c = c.oNext; while (c !== b)
                        };
                        f.mesh.makeFace_ = function(b, c) {
                            var g = c.prev,
                                e = new f.GluFace(c, g);
                            g.next = e;
                            c.prev = e;
                            e.anEdge = b;
                            e.inside = c.inside;
                            c = b;
                            do c.lFace = e, c = c.lNext; while (c !==
                                b)
                        };
                        f.mesh.killEdge_ = function(b) {
                            var c = b.next;
                            b = b.sym.next;
                            c.sym.next = b;
                            b.sym.next = c
                        };
                        f.mesh.killVertex_ = function(b, c) {
                            var g = b.anEdge,
                                e = g;
                            do e.org = c, e = e.oNext; while (e !== g);
                            c = b.prev;
                            b = b.next;
                            b.prev = c;
                            c.next = b
                        };
                        f.mesh.killFace_ = function(b, c) {
                            var g = b.anEdge,
                                e = g;
                            do e.lFace = c, e = e.lNext; while (e !== g);
                            c = b.prev;
                            b = b.next;
                            b.prev = c;
                            c.next = b
                        };
                        f.normal = {};
                        f.normal.S_UNIT_X_ = 1;
                        f.normal.S_UNIT_Y_ = 0;
                        f.normal.projectPolygon = function(b, c, g, e) {
                            var d = !1,
                                h = [c, g, e];
                            0 === c && 0 === g && 0 === e && (f.normal.computeNormal_(b, h), d = !0);
                            g = f.normal.longAxis_(h);
                            c = b.mesh.vHead;
                            if (f.TRUE_PROJECT) {
                                f.normal.normalize_(h);
                                e = [0, 0, 0];
                                var p = [0, 0, 0];
                                e[g] = 0;
                                e[(g + 1) % 3] = f.normal.S_UNIT_X_;
                                e[(g + 2) % 3] = f.normal.S_UNIT_Y_;
                                g = f.normal.dot_(e, h);
                                e[0] -= g * h[0];
                                e[1] -= g * h[1];
                                e[2] -= g * h[2];
                                f.normal.normalize_(e);
                                p[0] = h[1] * e[2] - h[2] * e[1];
                                p[1] = h[2] * e[0] - h[0] * e[2];
                                p[2] = h[0] * e[1] - h[1] * e[0];
                                f.normal.normalize_(p);
                                for (h = c.next; h !== c; h = h.next) h.s = f.normal.dot_(h.coords, e), h.t = f.normal.dot_(h.coords, p)
                            } else
                                for (e = (g + 1) % 3, p = (g + 2) % 3, g = 0 < h[g] ? 1 : -1, h = c.next; h !== c; h =
                                    h.next) h.s = h.coords[e], h.t = g * h.coords[p];
                            d && f.normal.checkOrientation_(b)
                        };
                        f.normal.dot_ = function(b, c) {
                            return b[0] * c[0] + b[1] * c[1] + b[2] * c[2]
                        };
                        f.normal.normalize_ = function(b) {
                            var c = b[0] * b[0] + b[1] * b[1] + b[2] * b[2];
                            f.assert(0 < c);
                            c = Math.sqrt(c);
                            b[0] /= c;
                            b[1] /= c;
                            b[2] /= c
                        };
                        f.normal.longAxis_ = function(b) {
                            var c = 0;
                            Math.abs(b[1]) > Math.abs(b[0]) && (c = 1);
                            Math.abs(b[2]) > Math.abs(b[c]) && (c = 2);
                            return c
                        };
                        f.normal.computeNormal_ = function(b, c) {
                            var g = [-2 * f.GLU_TESS_MAX_COORD, -2 * f.GLU_TESS_MAX_COORD, -2 * f.GLU_TESS_MAX_COORD],
                                e = [2 * f.GLU_TESS_MAX_COORD, 2 * f.GLU_TESS_MAX_COORD, 2 * f.GLU_TESS_MAX_COORD],
                                d = [],
                                h = [],
                                p;
                            b = b.mesh.vHead;
                            for (p = b.next; p !== b; p = p.next)
                                for (var l = 0; 3 > l; ++l) {
                                    var n = p.coords[l];
                                    n < e[l] && (e[l] = n, h[l] = p);
                                    n > g[l] && (g[l] = n, d[l] = p)
                                }
                            p = 0;
                            g[1] - e[1] > g[0] - e[0] && (p = 1);
                            g[2] - e[2] > g[p] - e[p] && (p = 2);
                            if (e[p] >= g[p]) c[0] = 0, c[1] = 0, c[2] = 1;
                            else {
                                g = 0;
                                e = h[p];
                                d = d[p];
                                h = [0, 0, 0];
                                e = [e.coords[0] - d.coords[0], e.coords[1] - d.coords[1], e.coords[2] - d.coords[2]];
                                l = [0, 0, 0];
                                for (p = b.next; p !== b; p = p.next) l[0] = p.coords[0] - d.coords[0], l[1] = p.coords[1] -
                                    d.coords[1], l[2] = p.coords[2] - d.coords[2], h[0] = e[1] * l[2] - e[2] * l[1], h[1] = e[2] * l[0] - e[0] * l[2], h[2] = e[0] * l[1] - e[1] * l[0], n = h[0] * h[0] + h[1] * h[1] + h[2] * h[2], n > g && (g = n, c[0] = h[0], c[1] = h[1], c[2] = h[2]);
                                0 >= g && (c[0] = c[1] = c[2] = 0, c[f.normal.longAxis_(e)] = 1)
                            }
                        };
                        f.normal.checkOrientation_ = function(b) {
                            for (var c = 0, g = b.mesh.fHead, e = g.next; e !== g; e = e.next) {
                                var d = e.anEdge;
                                if (!(0 >= d.winding)) {
                                    do c += (d.org.s - d.dst().s) * (d.org.t + d.dst().t), d = d.lNext; while (d !== e.anEdge)
                                }
                            }
                            if (0 > c)
                                for (b = b.mesh.vHead, c = b.next; c !== b; c = c.next) c.t = -c.t
                        };
                        f.render = {};
                        f.render.renderMesh = function(b, c, g) {
                            for (var e = !1, d = -1, h = c.fHead.prev; h !== c.fHead; h = h.prev)
                                if (h.inside) {
                                    e || (b.callBeginCallback(f.primitiveType.GL_TRIANGLES), e = !0);
                                    var p = h.anEdge;
                                    f.assert(p.lNext.lNext.lNext === p, "renderMesh called with non-triangulated mesh");
                                    do {
                                        if (g) {
                                            var l = p.rFace().inside ? 0 : 1;
                                            d !== l && (d = l, b.callEdgeFlagCallback(!!d))
                                        }
                                        b.callVertexCallback(p.org.data);
                                        p = p.lNext
                                    } while (p !== h.anEdge)
                                }
                            e && b.callEndCallback()
                        };
                        f.render.renderBoundary = function(b, c) {
                            for (var g = c.fHead.next; g !== c.fHead; g =
                                g.next)
                                if (g.inside) {
                                    b.callBeginCallback(f.primitiveType.GL_LINE_LOOP);
                                    var e = g.anEdge;
                                    do b.callVertexCallback(e.org.data), e = e.lNext; while (e !== g.anEdge);
                                    b.callEndCallback()
                                }
                        };
                        f.sweep = {};
                        f.sweep.SENTINEL_COORD_ = 4 * f.GLU_TESS_MAX_COORD;
                        f.sweep.TOLERANCE_NONZERO_ = !1;
                        f.sweep.computeInterior = function(b) {
                            b.fatalError = !1;
                            f.sweep.removeDegenerateEdges_(b);
                            f.sweep.initPriorityQ_(b);
                            f.sweep.initEdgeDict_(b);
                            for (var c; null !== (c = b.pq.extractMin());) {
                                for (;;) {
                                    var g = b.pq.minimum();
                                    if (null === g || !f.geom.vertEq(g, c)) break;
                                    g = b.pq.extractMin();
                                    f.sweep.spliceMergeVertices_(b, c.anEdge, g.anEdge)
                                }
                                f.sweep.sweepEvent_(b, c)
                            }
                            c = b.dict.getMin().getKey();
                            b.event = c.eUp.org;
                            f.sweep.doneEdgeDict_(b);
                            f.sweep.donePriorityQ_(b);
                            f.sweep.removeDegenerateFaces_(b.mesh);
                            b.mesh.checkMesh()
                        };
                        f.sweep.addWinding_ = function(b, c) {
                            b.winding += c.winding;
                            b.sym.winding += c.sym.winding
                        };
                        f.sweep.edgeLeq_ = function(b, c, g) {
                            b = b.event;
                            c = c.eUp;
                            g = g.eUp;
                            if (c.dst() === b) return g.dst() === b ? f.geom.vertLeq(c.org, g.org) ? 0 >= f.geom.edgeSign(g.dst(), c.org, g.org) : 0 <= f.geom.edgeSign(c.dst(),
                                g.org, c.org) : 0 >= f.geom.edgeSign(g.dst(), b, g.org);
                            if (g.dst() === b) return 0 <= f.geom.edgeSign(c.dst(), b, c.org);
                            c = f.geom.edgeEval(c.dst(), b, c.org);
                            b = f.geom.edgeEval(g.dst(), b, g.org);
                            return c >= b
                        };
                        f.sweep.deleteRegion_ = function(b, c) {
                            c.fixUpperEdge && f.assert(0 === c.eUp.winding);
                            c.eUp.activeRegion = null;
                            b.dict.deleteNode(c.nodeUp);
                            c.nodeUp = null
                        };
                        f.sweep.fixUpperEdge_ = function(b, c) {
                            f.assert(b.fixUpperEdge);
                            f.mesh.deleteEdge(b.eUp);
                            b.fixUpperEdge = !1;
                            b.eUp = c;
                            c.activeRegion = b
                        };
                        f.sweep.topLeftRegion_ = function(b) {
                            var c =
                                b.eUp.org;
                            do b = b.regionAbove(); while (b.eUp.org === c);
                            b.fixUpperEdge && (c = f.mesh.connect(b.regionBelow().eUp.sym, b.eUp.lNext), f.sweep.fixUpperEdge_(b, c), b = b.regionAbove());
                            return b
                        };
                        f.sweep.topRightRegion_ = function(b) {
                            var c = b.eUp.dst();
                            do b = b.regionAbove(); while (b.eUp.dst() === c);
                            return b
                        };
                        f.sweep.addRegionBelow_ = function(b, c, g) {
                            var e = new f.ActiveRegion;
                            e.eUp = g;
                            e.nodeUp = b.dict.insertBefore(c.nodeUp, e);
                            return g.activeRegion = e
                        };
                        f.sweep.isWindingInside_ = function(b, c) {
                            switch (b.windingRule) {
                                case f.windingRule.GLU_TESS_WINDING_ODD:
                                    return 0 !==
                                        (c & 1);
                                case f.windingRule.GLU_TESS_WINDING_NONZERO:
                                    return 0 !== c;
                                case f.windingRule.GLU_TESS_WINDING_POSITIVE:
                                    return 0 < c;
                                case f.windingRule.GLU_TESS_WINDING_NEGATIVE:
                                    return 0 > c;
                                case f.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
                                    return 2 <= c || -2 >= c
                            }
                            f.assert(!1);
                            return !1
                        };
                        f.sweep.computeWinding_ = function(b, c) {
                            c.windingNumber = c.regionAbove().windingNumber + c.eUp.winding;
                            c.inside = f.sweep.isWindingInside_(b, c.windingNumber)
                        };
                        f.sweep.finishRegion_ = function(b, c) {
                            var g = c.eUp,
                                e = g.lFace;
                            e.inside = c.inside;
                            e.anEdge =
                                g;
                            f.sweep.deleteRegion_(b, c)
                        };
                        f.sweep.finishLeftRegions_ = function(b, c, g) {
                            var e = c;
                            for (c = c.eUp; e !== g;) {
                                e.fixUpperEdge = !1;
                                var d = e.regionBelow(),
                                    h = d.eUp;
                                if (h.org !== c.org) {
                                    if (!d.fixUpperEdge) {
                                        f.sweep.finishRegion_(b, e);
                                        break
                                    }
                                    h = f.mesh.connect(c.lPrev(), h.sym);
                                    f.sweep.fixUpperEdge_(d, h)
                                }
                                c.oNext !== h && (f.mesh.meshSplice(h.oPrev(), h), f.mesh.meshSplice(c, h));
                                f.sweep.finishRegion_(b, e);
                                c = d.eUp;
                                e = d
                            }
                            return c
                        };
                        f.sweep.addRightEdges_ = function(b, c, g, e, d, h) {
                            var p = !0;
                            do f.assert(f.geom.vertLeq(g.org, g.dst())), f.sweep.addRegionBelow_(b,
                                c, g.sym), g = g.oNext; while (g !== e);
                            for (null === d && (d = c.regionBelow().eUp.rPrev());;) {
                                e = c.regionBelow();
                                g = e.eUp.sym;
                                if (g.org !== d.org) break;
                                g.oNext !== d && (f.mesh.meshSplice(g.oPrev(), g), f.mesh.meshSplice(d.oPrev(), g));
                                e.windingNumber = c.windingNumber - g.winding;
                                e.inside = f.sweep.isWindingInside_(b, e.windingNumber);
                                c.dirty = !0;
                                !p && f.sweep.checkForRightSplice_(b, c) && (f.sweep.addWinding_(g, d), f.sweep.deleteRegion_(b, c), f.mesh.deleteEdge(d));
                                p = !1;
                                c = e;
                                d = g
                            }
                            c.dirty = !0;
                            f.assert(c.windingNumber - g.winding === e.windingNumber);
                            h && f.sweep.walkDirtyRegions_(b, c)
                        };
                        f.sweep.callCombine_ = function(b, c, g, e, d) {
                            var h = [c.coords[0], c.coords[1], c.coords[2]];
                            c.data = null;
                            c.data = b.callCombineCallback(h, g, e);
                            null === c.data && (d ? b.fatalError || (b.callErrorCallback(f.errorType.GLU_TESS_NEED_COMBINE_CALLBACK), b.fatalError = !0) : c.data = g[0])
                        };
                        f.sweep.spliceMergeVertices_ = function(b, c, g) {
                            var e = [null, null, null, null];
                            e[0] = c.org.data;
                            e[1] = g.org.data;
                            f.sweep.callCombine_(b, c.org, e, [.5, .5, 0, 0], !1);
                            f.mesh.meshSplice(c, g)
                        };
                        f.sweep.vertexWeights_ = function(b,
                            c, g, e, d) {
                            var h = f.geom.vertL1dist(c, b),
                                p = f.geom.vertL1dist(g, b),
                                l = d + 1;
                            e[d] = .5 * p / (h + p);
                            e[l] = .5 * h / (h + p);
                            b.coords[0] += e[d] * c.coords[0] + e[l] * g.coords[0];
                            b.coords[1] += e[d] * c.coords[1] + e[l] * g.coords[1];
                            b.coords[2] += e[d] * c.coords[2] + e[l] * g.coords[2]
                        };
                        f.sweep.getIntersectData_ = function(b, c, g, e, d, h) {
                            var p = [0, 0, 0, 0],
                                l = [g.data, e.data, d.data, h.data];
                            c.coords[0] = c.coords[1] = c.coords[2] = 0;
                            f.sweep.vertexWeights_(c, g, e, p, 0);
                            f.sweep.vertexWeights_(c, d, h, p, 2);
                            f.sweep.callCombine_(b, c, l, p, !0)
                        };
                        f.sweep.checkForRightSplice_ =
                            function(b, c) {
                                var g = c.regionBelow(),
                                    e = c.eUp,
                                    d = g.eUp;
                                if (f.geom.vertLeq(e.org, d.org)) {
                                    if (0 < f.geom.edgeSign(d.dst(), e.org, d.org)) return !1;
                                    f.geom.vertEq(e.org, d.org) ? e.org !== d.org && (b.pq.remove(e.org.pqHandle), f.sweep.spliceMergeVertices_(b, d.oPrev(), e)) : (f.mesh.splitEdge(d.sym), f.mesh.meshSplice(e, d.oPrev()), c.dirty = g.dirty = !0)
                                } else {
                                    if (0 > f.geom.edgeSign(e.dst(), d.org, e.org)) return !1;
                                    c.regionAbove().dirty = c.dirty = !0;
                                    f.mesh.splitEdge(e.sym);
                                    f.mesh.meshSplice(d.oPrev(), e)
                                }
                                return !0
                            };
                        f.sweep.checkForLeftSplice_ =
                            function(b, c) {
                                var g = c.regionBelow();
                                b = c.eUp;
                                var e = g.eUp;
                                f.assert(!f.geom.vertEq(b.dst(), e.dst()));
                                if (f.geom.vertLeq(b.dst(), e.dst())) {
                                    if (0 > f.geom.edgeSign(b.dst(), e.dst(), b.org)) return !1;
                                    c.regionAbove().dirty = c.dirty = !0;
                                    g = f.mesh.splitEdge(b);
                                    f.mesh.meshSplice(e.sym, g);
                                    g.lFace.inside = c.inside
                                } else {
                                    if (0 < f.geom.edgeSign(e.dst(), b.dst(), e.org)) return !1;
                                    c.dirty = g.dirty = !0;
                                    g = f.mesh.splitEdge(e);
                                    f.mesh.meshSplice(b.lNext, e.sym);
                                    g.rFace().inside = c.inside
                                }
                                return !0
                            };
                        f.sweep.checkForIntersect_ = function(b, c) {
                            var g =
                                c.regionBelow(),
                                e = c.eUp,
                                d = g.eUp,
                                h = e.org,
                                p = d.org,
                                l = e.dst(),
                                n = d.dst(),
                                u = new f.GluVertex;
                            f.assert(!f.geom.vertEq(n, l));
                            f.assert(0 >= f.geom.edgeSign(l, b.event, h));
                            f.assert(0 <= f.geom.edgeSign(n, b.event, p));
                            f.assert(h !== b.event && p !== b.event);
                            f.assert(!c.fixUpperEdge && !g.fixUpperEdge);
                            if (h === p || Math.min(h.t, l.t) > Math.max(p.t, n.t)) return !1;
                            if (f.geom.vertLeq(h, p)) {
                                if (0 < f.geom.edgeSign(n, h, p)) return !1
                            } else if (0 > f.geom.edgeSign(l, p, h)) return !1;
                            f.geom.edgeIntersect(l, h, n, p, u);
                            f.assert(Math.min(h.t, l.t) <= u.t);
                            f.assert(u.t <= Math.max(p.t, n.t));
                            f.assert(Math.min(n.s, l.s) <= u.s);
                            f.assert(u.s <= Math.max(p.s, h.s));
                            f.geom.vertLeq(u, b.event) && (u.s = b.event.s, u.t = b.event.t);
                            var y = f.geom.vertLeq(h, p) ? h : p;
                            f.geom.vertLeq(y, u) && (u.s = y.s, u.t = y.t);
                            if (f.geom.vertEq(u, h) || f.geom.vertEq(u, p)) return f.sweep.checkForRightSplice_(b, c), !1;
                            if (!f.geom.vertEq(l, b.event) && 0 <= f.geom.edgeSign(l, b.event, u) || !f.geom.vertEq(n, b.event) && 0 >= f.geom.edgeSign(n, b.event, u)) {
                                if (n === b.event) return f.mesh.splitEdge(e.sym), f.mesh.meshSplice(d.sym,
                                    e), c = f.sweep.topLeftRegion_(c), e = c.regionBelow().eUp, f.sweep.finishLeftRegions_(b, c.regionBelow(), g), f.sweep.addRightEdges_(b, c, e.oPrev(), e, e, !0), !0;
                                if (l === b.event) return f.mesh.splitEdge(d.sym), f.mesh.meshSplice(e.lNext, d.oPrev()), g = c, c = f.sweep.topRightRegion_(c), h = c.regionBelow().eUp.rPrev(), g.eUp = d.oPrev(), d = f.sweep.finishLeftRegions_(b, g, null), f.sweep.addRightEdges_(b, c, d.oNext, e.rPrev(), h, !0), !0;
                                0 <= f.geom.edgeSign(l, b.event, u) && (c.regionAbove().dirty = c.dirty = !0, f.mesh.splitEdge(e.sym), e.org.s =
                                    b.event.s, e.org.t = b.event.t);
                                0 >= f.geom.edgeSign(n, b.event, u) && (c.dirty = g.dirty = !0, f.mesh.splitEdge(d.sym), d.org.s = b.event.s, d.org.t = b.event.t);
                                return !1
                            }
                            f.mesh.splitEdge(e.sym);
                            f.mesh.splitEdge(d.sym);
                            f.mesh.meshSplice(d.oPrev(), e);
                            e.org.s = u.s;
                            e.org.t = u.t;
                            e.org.pqHandle = b.pq.insert(e.org);
                            f.sweep.getIntersectData_(b, e.org, h, l, p, n);
                            c.regionAbove().dirty = c.dirty = g.dirty = !0;
                            return !1
                        };
                        f.sweep.walkDirtyRegions_ = function(b, c) {
                            for (var g = c.regionBelow();;) {
                                for (; g.dirty;) c = g, g = g.regionBelow();
                                if (!c.dirty &&
                                    (g = c, c = c.regionAbove(), null === c || !c.dirty)) break;
                                c.dirty = !1;
                                var e = c.eUp,
                                    d = g.eUp;
                                e.dst() !== d.dst() && f.sweep.checkForLeftSplice_(b, c) && (g.fixUpperEdge ? (f.sweep.deleteRegion_(b, g), f.mesh.deleteEdge(d), g = c.regionBelow(), d = g.eUp) : c.fixUpperEdge && (f.sweep.deleteRegion_(b, c), f.mesh.deleteEdge(e), c = g.regionAbove(), e = c.eUp));
                                if (e.org !== d.org)
                                    if (e.dst() === d.dst() || c.fixUpperEdge || g.fixUpperEdge || e.dst() !== b.event && d.dst() !== b.event) f.sweep.checkForRightSplice_(b, c);
                                    else if (f.sweep.checkForIntersect_(b, c)) break;
                                e.org === d.org && e.dst() === d.dst() && (f.sweep.addWinding_(d, e), f.sweep.deleteRegion_(b, c), f.mesh.deleteEdge(e), c = g.regionAbove())
                            }
                        };
                        f.sweep.connectRightVertex_ = function(b, c, g) {
                            var e = g.oNext,
                                d = c.regionBelow(),
                                h = c.eUp,
                                p = d.eUp,
                                l = !1;
                            h.dst() !== p.dst() && f.sweep.checkForIntersect_(b, c);
                            f.geom.vertEq(h.org, b.event) && (f.mesh.meshSplice(e.oPrev(), h), c = f.sweep.topLeftRegion_(c), e = c.regionBelow().eUp, f.sweep.finishLeftRegions_(b, c.regionBelow(), d), l = !0);
                            f.geom.vertEq(p.org, b.event) && (f.mesh.meshSplice(g, p.oPrev()),
                                g = f.sweep.finishLeftRegions_(b, d, null), l = !0);
                            l ? f.sweep.addRightEdges_(b, c, g.oNext, e, e, !0) : (e = f.geom.vertLeq(p.org, h.org) ? p.oPrev() : h, e = f.mesh.connect(g.lPrev(), e), f.sweep.addRightEdges_(b, c, e, e.oNext, e.oNext, !1), e.sym.activeRegion.fixUpperEdge = !0, f.sweep.walkDirtyRegions_(b, c))
                        };
                        f.sweep.connectLeftDegenerate_ = function(b, c, g) {
                            var e = c.eUp;
                            if (f.geom.vertEq(e.org, g)) f.assert(f.sweep.TOLERANCE_NONZERO_), f.sweep.TOLERANCE_NONZERO_ && f.sweep.spliceMergeVertices_(b, e, g.anEdge);
                            else if (f.geom.vertEq(e.dst(),
                                    g)) {
                                if (f.assert(f.sweep.TOLERANCE_NONZERO_), f.sweep.TOLERANCE_NONZERO_) {
                                    c = f.sweep.topRightRegion_(c);
                                    e = c.regionBelow();
                                    var d = e.eUp.sym,
                                        h = d.oNext,
                                        p = h;
                                    e.fixUpperEdge && (f.assert(h !== d), f.sweep.deleteRegion_(b, e), f.mesh.deleteEdge(d), d = h.oPrev());
                                    f.mesh.meshSplice(g.anEdge, d);
                                    f.geom.edgeGoesLeft(h) || (h = null);
                                    f.sweep.addRightEdges_(b, c, d.oNext, p, h, !0)
                                }
                            } else f.mesh.splitEdge(e.sym), c.fixUpperEdge && (f.mesh.deleteEdge(e.oNext), c.fixUpperEdge = !1), f.mesh.meshSplice(g.anEdge, e), f.sweep.sweepEvent_(b, g)
                        };
                        f.sweep.connectLeftVertex_ =
                            function(b, c) {
                                var g = new f.ActiveRegion;
                                g.eUp = c.anEdge.sym;
                                g = b.dict.search(g).getKey();
                                var e = g.regionBelow(),
                                    d = g.eUp,
                                    h = e.eUp;
                                0 === f.geom.edgeSign(d.dst(), c, d.org) ? f.sweep.connectLeftDegenerate_(b, g, c) : (e = f.geom.vertLeq(h.dst(), d.dst()) ? g : e, g.inside || e.fixUpperEdge ? (d = e === g ? f.mesh.connect(c.anEdge.sym, d.lNext) : f.mesh.connect(h.dNext(), c.anEdge).sym, e.fixUpperEdge ? f.sweep.fixUpperEdge_(e, d) : f.sweep.computeWinding_(b, f.sweep.addRegionBelow_(b, g, d)), f.sweep.sweepEvent_(b, c)) : f.sweep.addRightEdges_(b, g,
                                    c.anEdge, c.anEdge, null, !0))
                            };
                        f.sweep.sweepEvent_ = function(b, c) {
                            b.event = c;
                            for (var g = c.anEdge; null === g.activeRegion;)
                                if (g = g.oNext, g === c.anEdge) {
                                    f.sweep.connectLeftVertex_(b, c);
                                    return
                                }
                            c = f.sweep.topLeftRegion_(g.activeRegion);
                            var e = c.regionBelow();
                            g = e.eUp;
                            e = f.sweep.finishLeftRegions_(b, e, null);
                            e.oNext === g ? f.sweep.connectRightVertex_(b, c, e) : f.sweep.addRightEdges_(b, c, e.oNext, g, g, !0)
                        };
                        f.sweep.addSentinel_ = function(b, c) {
                            var g = new f.ActiveRegion,
                                e = f.mesh.makeEdge(b.mesh);
                            e.org.s = f.sweep.SENTINEL_COORD_;
                            e.org.t =
                                c;
                            e.dst().s = -f.sweep.SENTINEL_COORD_;
                            e.dst().t = c;
                            b.event = e.dst();
                            g.eUp = e;
                            g.windingNumber = 0;
                            g.inside = !1;
                            g.fixUpperEdge = !1;
                            g.sentinel = !0;
                            g.dirty = !1;
                            g.nodeUp = b.dict.insert(g)
                        };
                        f.sweep.initEdgeDict_ = function(b) {
                            b.dict = new f.Dict(b, f.sweep.edgeLeq_);
                            f.sweep.addSentinel_(b, -f.sweep.SENTINEL_COORD_);
                            f.sweep.addSentinel_(b, f.sweep.SENTINEL_COORD_)
                        };
                        f.sweep.doneEdgeDict_ = function(b) {
                            for (var c = 0, g; null !== (g = b.dict.getMin().getKey());) g.sentinel || (f.assert(g.fixUpperEdge), f.assert(1 === ++c)), f.assert(0 === g.windingNumber),
                                f.sweep.deleteRegion_(b, g);
                            b.dict = null
                        };
                        f.sweep.removeDegenerateEdges_ = function(b) {
                            for (var c = b.mesh.eHead, g, e = c.next; e !== c; e = g) {
                                g = e.next;
                                var d = e.lNext;
                                f.geom.vertEq(e.org, e.dst()) && e.lNext.lNext !== e && (f.sweep.spliceMergeVertices_(b, d, e), f.mesh.deleteEdge(e), e = d, d = e.lNext);
                                if (d.lNext === e) {
                                    if (d !== e) {
                                        if (d === g || d === g.sym) g = g.next;
                                        f.mesh.deleteEdge(d)
                                    }
                                    if (e === g || e === g.sym) g = g.next;
                                    f.mesh.deleteEdge(e)
                                }
                            }
                        };
                        f.sweep.initPriorityQ_ = function(b) {
                            var c = new f.PriorityQ;
                            b.pq = c;
                            b = b.mesh.vHead;
                            var g;
                            for (g = b.next; g !==
                                b; g = g.next) g.pqHandle = c.insert(g);
                            c.init()
                        };
                        f.sweep.donePriorityQ_ = function(b) {
                            b.pq.deleteQ();
                            b.pq = null
                        };
                        f.sweep.removeDegenerateFaces_ = function(b) {
                            for (var c, g = b.fHead.next; g !== b.fHead; g = c) c = g.next, g = g.anEdge, f.assert(g.lNext !== g), g.lNext.lNext === g && (f.sweep.addWinding_(g.oNext, g), f.mesh.deleteEdge(g))
                        };
                        f.tessmono = {};
                        f.tessmono.tessellateMonoRegion_ = function(b) {
                            b = b.anEdge;
                            for (f.assert(b.lNext !== b && b.lNext.lNext !== b); f.geom.vertLeq(b.dst(), b.org); b = b.lPrev());
                            for (; f.geom.vertLeq(b.org, b.dst()); b = b.lNext);
                            for (var c = b.lPrev(), g; b.lNext !== c;)
                                if (f.geom.vertLeq(b.dst(), c.org)) {
                                    for (; c.lNext !== b && (f.geom.edgeGoesLeft(c.lNext) || 0 >= f.geom.edgeSign(c.org, c.dst(), c.lNext.dst()));) g = f.mesh.connect(c.lNext, c), c = g.sym;
                                    c = c.lPrev()
                                } else {
                                    for (; c.lNext !== b && (f.geom.edgeGoesRight(b.lPrev()) || 0 <= f.geom.edgeSign(b.dst(), b.org, b.lPrev().org));) g = f.mesh.connect(b, b.lPrev()), b = g.sym;
                                    b = b.lNext
                                }
                            for (f.assert(c.lNext !== b); c.lNext.lNext !== b;) g = f.mesh.connect(c.lNext, c), c = g.sym
                        };
                        f.tessmono.tessellateInterior = function(b) {
                            for (var c,
                                    g = b.fHead.next; g !== b.fHead; g = c) c = g.next, g.inside && f.tessmono.tessellateMonoRegion_(g)
                        };
                        f.tessmono.discardExterior = function(b) {
                            for (var c, g = b.fHead.next; g !== b.fHead; g = c) c = g.next, g.inside || f.mesh.zapFace(g)
                        };
                        f.tessmono.setWindingNumber = function(b, c, g) {
                            for (var e, d = b.eHead.next; d !== b.eHead; d = e) e = d.next, d.rFace().inside !== d.lFace.inside ? d.winding = d.lFace.inside ? c : -c : g ? f.mesh.deleteEdge(d) : d.winding = 0
                        };
                        f.Dict = function(b, c) {
                            this.head_ = new f.DictNode;
                            this.frame_ = b;
                            this.leq_ = c
                        };
                        f.Dict.prototype.deleteDict_ =
                            function() {};
                        f.Dict.prototype.insertBefore = function(b, c) {
                            do b = b.prev; while (null !== b.key && !this.leq_(this.frame_, b.key, c));
                            c = new f.DictNode(c, b.next, b);
                            b.next.prev = c;
                            return b.next = c
                        };
                        f.Dict.prototype.insert = function(b) {
                            return this.insertBefore(this.head_, b)
                        };
                        f.Dict.prototype.deleteNode = function(b) {
                            b.next.prev = b.prev;
                            b.prev.next = b.next
                        };
                        f.Dict.prototype.search = function(b) {
                            var c = this.head_;
                            do c = c.next; while (null !== c.key && !this.leq_(this.frame_, b, c.key));
                            return c
                        };
                        f.Dict.prototype.getMin = function() {
                            return this.head_.next
                        };
                        f.Dict.prototype.getMax = function() {
                            return this.head_.prev
                        };
                        f.DictNode = function(b, c, g) {
                            this.key = b || null;
                            this.next = c || this;
                            this.prev = g || this
                        };
                        f.DictNode.prototype.getKey = function() {
                            return this.key
                        };
                        f.DictNode.prototype.getSuccessor = function() {
                            return this.next
                        };
                        f.DictNode.prototype.getPredecessor = function() {
                            return this.prev
                        };
                        f.GluTesselator = function() {
                            this.state_ = f.GluTesselator.tessState_.T_DORMANT;
                            this.errorCallback_ = this.mesh = this.lastEdge_ = null;
                            this.normal_ = [0, 0, 0];
                            this.windingRule = f.windingRule.GLU_TESS_WINDING_ODD;
                            this.fatalError = !1;
                            this.combineCallback_ = this.event = this.pq = this.dict = null;
                            this.boundaryOnly_ = !1;
                            this.polygonData_ = this.meshCallback_ = this.endCallback_ = this.vertexCallback_ = this.edgeFlagCallback_ = this.beginCallback_ = null
                        };
                        f.GluTesselator.tessState_ = {
                            T_DORMANT: 0,
                            T_IN_POLYGON: 1,
                            T_IN_CONTOUR: 2
                        };
                        f.GluTesselator.prototype.gluDeleteTess = function() {
                            this.requireState_(f.GluTesselator.tessState_.T_DORMANT)
                        };
                        f.GluTesselator.prototype.gluTessProperty = function(b, c) {
                            switch (b) {
                                case f.gluEnum.GLU_TESS_TOLERANCE:
                                    return;
                                case f.gluEnum.GLU_TESS_WINDING_RULE:
                                    switch (c) {
                                        case f.windingRule.GLU_TESS_WINDING_ODD:
                                        case f.windingRule.GLU_TESS_WINDING_NONZERO:
                                        case f.windingRule.GLU_TESS_WINDING_POSITIVE:
                                        case f.windingRule.GLU_TESS_WINDING_NEGATIVE:
                                        case f.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
                                            this.windingRule = c;
                                            return
                                    }
                                    break;
                                case f.gluEnum.GLU_TESS_BOUNDARY_ONLY:
                                    this.boundaryOnly_ = !!c;
                                    return;
                                default:
                                    this.callErrorCallback(f.gluEnum.GLU_INVALID_ENUM);
                                    return
                            }
                            this.callErrorCallback(f.gluEnum.GLU_INVALID_VALUE)
                        };
                        f.GluTesselator.prototype.gluGetTessProperty =
                            function(b) {
                                switch (b) {
                                    case f.gluEnum.GLU_TESS_TOLERANCE:
                                        return 0;
                                    case f.gluEnum.GLU_TESS_WINDING_RULE:
                                        return b = this.windingRule, f.assert(b === f.windingRule.GLU_TESS_WINDING_ODD || b === f.windingRule.GLU_TESS_WINDING_NONZERO || b === f.windingRule.GLU_TESS_WINDING_POSITIVE || b === f.windingRule.GLU_TESS_WINDING_NEGATIVE || b === f.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO), b;
                                    case f.gluEnum.GLU_TESS_BOUNDARY_ONLY:
                                        return f.assert(!0 === this.boundaryOnly_ || !1 === this.boundaryOnly_), this.boundaryOnly_;
                                    default:
                                        this.callErrorCallback(f.gluEnum.GLU_INVALID_ENUM)
                                }
                                return !1
                            };
                        f.GluTesselator.prototype.gluTessNormal = function(b, c, g) {
                            this.normal_[0] = b;
                            this.normal_[1] = c;
                            this.normal_[2] = g
                        };
                        f.GluTesselator.prototype.gluTessCallback = function(b, c) {
                            c = c ? c : null;
                            switch (b) {
                                case f.gluEnum.GLU_TESS_BEGIN:
                                case f.gluEnum.GLU_TESS_BEGIN_DATA:
                                    this.beginCallback_ = c;
                                    break;
                                case f.gluEnum.GLU_TESS_EDGE_FLAG:
                                case f.gluEnum.GLU_TESS_EDGE_FLAG_DATA:
                                    this.edgeFlagCallback_ = c;
                                    break;
                                case f.gluEnum.GLU_TESS_VERTEX:
                                case f.gluEnum.GLU_TESS_VERTEX_DATA:
                                    this.vertexCallback_ = c;
                                    break;
                                case f.gluEnum.GLU_TESS_END:
                                case f.gluEnum.GLU_TESS_END_DATA:
                                    this.endCallback_ =
                                        c;
                                    break;
                                case f.gluEnum.GLU_TESS_ERROR:
                                case f.gluEnum.GLU_TESS_ERROR_DATA:
                                    this.errorCallback_ = c;
                                    break;
                                case f.gluEnum.GLU_TESS_COMBINE:
                                case f.gluEnum.GLU_TESS_COMBINE_DATA:
                                    this.combineCallback_ = c;
                                    break;
                                case f.gluEnum.GLU_TESS_MESH:
                                    this.meshCallback_ = c;
                                    break;
                                default:
                                    this.callErrorCallback(f.gluEnum.GLU_INVALID_ENUM)
                            }
                        };
                        f.GluTesselator.prototype.gluTessVertex = function(b, c) {
                            var g = !1,
                                e = [0, 0, 0];
                            this.requireState_(f.GluTesselator.tessState_.T_IN_CONTOUR);
                            for (var d = 0; 3 > d; ++d) {
                                var h = b[d];
                                h < -f.GLU_TESS_MAX_COORD &&
                                    (h = -f.GLU_TESS_MAX_COORD, g = !0);
                                h > f.GLU_TESS_MAX_COORD && (h = f.GLU_TESS_MAX_COORD, g = !0);
                                e[d] = h
                            }
                            g && this.callErrorCallback(f.errorType.GLU_TESS_COORD_TOO_LARGE);
                            this.addVertex_(e, c)
                        };
                        f.GluTesselator.prototype.gluTessBeginPolygon = function(b) {
                            this.requireState_(f.GluTesselator.tessState_.T_DORMANT);
                            this.state_ = f.GluTesselator.tessState_.T_IN_POLYGON;
                            this.mesh = new f.GluMesh;
                            this.polygonData_ = b
                        };
                        f.GluTesselator.prototype.gluTessBeginContour = function() {
                            this.requireState_(f.GluTesselator.tessState_.T_IN_POLYGON);
                            this.state_ = f.GluTesselator.tessState_.T_IN_CONTOUR;
                            this.lastEdge_ = null
                        };
                        f.GluTesselator.prototype.gluTessEndContour = function() {
                            this.requireState_(f.GluTesselator.tessState_.T_IN_CONTOUR);
                            this.state_ = f.GluTesselator.tessState_.T_IN_POLYGON
                        };
                        f.GluTesselator.prototype.gluTessEndPolygon = function() {
                            this.requireState_(f.GluTesselator.tessState_.T_IN_POLYGON);
                            this.state_ = f.GluTesselator.tessState_.T_DORMANT;
                            f.normal.projectPolygon(this, this.normal_[0], this.normal_[1], this.normal_[2]);
                            f.sweep.computeInterior(this);
                            if (!this.fatalError) {
                                var b = this.mesh;
                                this.boundaryOnly_ ? f.tessmono.setWindingNumber(b, 1, !0) : f.tessmono.tessellateInterior(b);
                                this.mesh.checkMesh();
                                if (this.beginCallback_ || this.endCallback_ || this.vertexCallback_ || this.edgeFlagCallback_) this.boundaryOnly_ ? f.render.renderBoundary(this, this.mesh) : f.render.renderMesh(this, this.mesh, !!this.edgeFlagCallback_);
                                if (this.meshCallback_) {
                                    f.tessmono.discardExterior(this.mesh);
                                    this.meshCallback_(this.mesh);
                                    this.polygonData_ = this.mesh = null;
                                    return
                                }
                            }
                            f.mesh.deleteMesh(this.mesh);
                            this.mesh = this.polygonData_ = null
                        };
                        f.GluTesselator.prototype.requireState_ = function(b) {
                            this.state_ !== b && this.gotoState_(b)
                        };
                        f.GluTesselator.prototype.gotoState_ = function(b) {
                            for (; this.state_ !== b;)
                                if (this.state_ < b) switch (this.state_) {
                                    case f.GluTesselator.tessState_.T_DORMANT:
                                        this.callErrorCallback(f.errorType.GLU_TESS_MISSING_BEGIN_POLYGON);
                                        this.gluTessBeginPolygon(null);
                                        break;
                                    case f.GluTesselator.tessState_.T_IN_POLYGON:
                                        this.callErrorCallback(f.errorType.GLU_TESS_MISSING_BEGIN_CONTOUR), this.gluTessBeginContour()
                                } else switch (this.state_) {
                                    case f.GluTesselator.tessState_.T_IN_CONTOUR:
                                        this.callErrorCallback(f.errorType.GLU_TESS_MISSING_END_CONTOUR);
                                        this.gluTessEndContour();
                                        break;
                                    case f.GluTesselator.tessState_.T_IN_POLYGON:
                                        this.callErrorCallback(f.errorType.GLU_TESS_MISSING_END_POLYGON), this.gluTessEndPolygon()
                                }
                        };
                        f.GluTesselator.prototype.addVertex_ = function(b, c) {
                            var g = this.lastEdge_;
                            null === g ? (g = f.mesh.makeEdge(this.mesh), f.mesh.meshSplice(g, g.sym)) : (f.mesh.splitEdge(g), g = g.lNext);
                            g.org.data = c;
                            g.org.coords[0] = b[0];
                            g.org.coords[1] = b[1];
                            g.org.coords[2] = b[2];
                            g.winding = 1;
                            g.sym.winding = -1;
                            this.lastEdge_ = g
                        };
                        f.GluTesselator.prototype.callBeginCallback =
                            function(b) {
                                this.beginCallback_ && this.beginCallback_(b, this.polygonData_)
                            };
                        f.GluTesselator.prototype.callVertexCallback = function(b) {
                            this.vertexCallback_ && this.vertexCallback_(b, this.polygonData_)
                        };
                        f.GluTesselator.prototype.callEdgeFlagCallback = function(b) {
                            this.edgeFlagCallback_ && this.edgeFlagCallback_(b, this.polygonData_)
                        };
                        f.GluTesselator.prototype.callEndCallback = function() {
                            this.endCallback_ && this.endCallback_(this.polygonData_)
                        };
                        f.GluTesselator.prototype.callCombineCallback = function(b, c, g) {
                            return this.combineCallback_ ?
                                this.combineCallback_(b, c, g, this.polygonData_) || null : null
                        };
                        f.GluTesselator.prototype.callErrorCallback = function(b) {
                            this.errorCallback_ && this.errorCallback_(b, this.polygonData_)
                        };
                        f.GluFace = function(b, c) {
                            this.next = b || this;
                            this.prev = c || this;
                            this.anEdge = null;
                            this.inside = !1
                        };
                        f.GluHalfEdge = function(b) {
                            this.next = b || this;
                            this.activeRegion = this.lFace = this.org = this.lNext = this.oNext = this.sym = null;
                            this.winding = 0
                        };
                        f.GluHalfEdge.prototype.rFace = function() {
                            return this.sym.lFace
                        };
                        f.GluHalfEdge.prototype.dst = function() {
                            return this.sym.org
                        };
                        f.GluHalfEdge.prototype.oPrev = function() {
                            return this.sym.lNext
                        };
                        f.GluHalfEdge.prototype.lPrev = function() {
                            return this.oNext.sym
                        };
                        f.GluHalfEdge.prototype.dPrev = function() {
                            return this.lNext.sym
                        };
                        f.GluHalfEdge.prototype.rPrev = function() {
                            return this.sym.oNext
                        };
                        f.GluHalfEdge.prototype.dNext = function() {
                            return this.rPrev().sym
                        };
                        f.GluHalfEdge.prototype.rNext = function() {
                            return this.oPrev().sym
                        };
                        f.GluMesh = function() {
                            this.vHead = new f.GluVertex;
                            this.fHead = new f.GluFace;
                            this.eHead = new f.GluHalfEdge;
                            this.eHeadSym =
                                new f.GluHalfEdge;
                            this.eHead.sym = this.eHeadSym;
                            this.eHeadSym.sym = this.eHead
                        };
                        f.GluMesh.prototype.checkMesh = function() {
                            if (f.DEBUG) {
                                var b = this.fHead,
                                    c = this.vHead,
                                    g = this.eHead,
                                    e, d;
                                for (e = e = b;
                                    (d = e.next) !== b; e = d) {
                                    f.assert(d.prev === e);
                                    e = d.anEdge;
                                    do f.assert(e.sym !== e), f.assert(e.sym.sym === e), f.assert(e.lNext.oNext.sym === e), f.assert(e.oNext.sym.lNext === e), f.assert(e.lFace === d), e = e.lNext; while (e !== d.anEdge)
                                }
                                f.assert(d.prev === e && null === d.anEdge);
                                for (e = e = c;
                                    (b = e.next) !== c; e = b) {
                                    f.assert(b.prev === e);
                                    e = b.anEdge;
                                    do f.assert(e.sym !== e), f.assert(e.sym.sym === e), f.assert(e.lNext.oNext.sym === e), f.assert(e.oNext.sym.lNext === e), f.assert(e.org === b), e = e.oNext; while (e !== b.anEdge)
                                }
                                f.assert(b.prev === e && null === b.anEdge && null === b.data);
                                for (c = c = g;
                                    (e = c.next) !== g; c = e) f.assert(e.sym.next === c.sym), f.assert(e.sym !== e), f.assert(e.sym.sym === e), f.assert(null !== e.org), f.assert(null !== e.dst()), f.assert(e.lNext.oNext.sym === e), f.assert(e.oNext.sym.lNext === e);
                                f.assert(e.sym.next === c.sym && e.sym === this.eHeadSym && e.sym.sym === e && null ===
                                    e.org && null === e.dst() && null === e.lFace && null === e.rFace())
                            }
                        };
                        f.GluVertex = function(b, c) {
                            this.next = b || this;
                            this.prev = c || this;
                            this.data = this.anEdge = null;
                            this.coords = [0, 0, 0];
                            this.pqHandle = this.t = this.s = 0
                        };
                        f.PriorityQ = function() {
                            this.verts_ = [];
                            this.order_ = null;
                            this.size_ = 0;
                            this.initialized_ = !1;
                            this.heap_ = new f.PriorityQHeap
                        };
                        f.PriorityQ.prototype.deleteQ = function() {
                            this.verts_ = this.order_ = this.heap_ = null
                        };
                        f.PriorityQ.prototype.init = function() {
                            this.order_ = [];
                            for (var b = 0; b < this.size_; b++) this.order_[b] = b;
                            b = function(g) {
                                return function(e, d) {
                                    return f.geom.vertLeq(g[e], g[d]) ? 1 : -1
                                }
                            }(this.verts_);
                            this.order_.sort(b);
                            this.initialized_ = !0;
                            this.heap_.init();
                            if (f.DEBUG) {
                                var c = 0 + this.size_ - 1;
                                for (b = 0; b < c; ++b) f.assert(f.geom.vertLeq(this.verts_[this.order_[b + 1]], this.verts_[this.order_[b]]))
                            }
                        };
                        f.PriorityQ.prototype.insert = function(b) {
                            if (this.initialized_) return this.heap_.insert(b);
                            var c = this.size_++;
                            this.verts_[c] = b;
                            return -(c + 1)
                        };
                        f.PriorityQ.prototype.extractMin = function() {
                            if (0 === this.size_) return this.heap_.extractMin();
                            var b = this.verts_[this.order_[this.size_ - 1]];
                            if (!this.heap_.isEmpty()) {
                                var c = this.heap_.minimum();
                                if (f.geom.vertLeq(c, b)) return this.heap_.extractMin()
                            }
                            do --this.size_; while (0 < this.size_ && null === this.verts_[this.order_[this.size_ - 1]]);
                            return b
                        };
                        f.PriorityQ.prototype.minimum = function() {
                            if (0 === this.size_) return this.heap_.minimum();
                            var b = this.verts_[this.order_[this.size_ - 1]];
                            if (!this.heap_.isEmpty()) {
                                var c = this.heap_.minimum();
                                if (f.geom.vertLeq(c, b)) return c
                            }
                            return b
                        };
                        f.PriorityQ.prototype.remove = function(b) {
                            if (0 <=
                                b) this.heap_.remove(b);
                            else
                                for (b = -(b + 1), f.assert(b < this.verts_.length && null !== this.verts_[b]), this.verts_[b] = null; 0 < this.size_ && null === this.verts_[this.order_[this.size_ - 1]];) --this.size_
                        };
                        f.PriorityQHeap = function() {
                            this.heap_ = f.PriorityQHeap.reallocNumeric_([0], f.PriorityQHeap.INIT_SIZE_ + 1);
                            this.verts_ = [null, null];
                            this.handles_ = [0, 0];
                            this.size_ = 0;
                            this.max_ = f.PriorityQHeap.INIT_SIZE_;
                            this.freeList_ = 0;
                            this.initialized_ = !1;
                            this.heap_[1] = 1
                        };
                        f.PriorityQHeap.INIT_SIZE_ = 32;
                        f.PriorityQHeap.reallocNumeric_ =
                            function(b, c) {
                                for (var g = Array(c), e = 0; e < b.length; e++) g[e] = b[e];
                                for (; e < c; e++) g[e] = 0;
                                return g
                            };
                        f.PriorityQHeap.prototype.init = function() {
                            for (var b = this.size_; 1 <= b; --b) this.floatDown_(b);
                            this.initialized_ = !0
                        };
                        f.PriorityQHeap.prototype.insert = function(b) {
                            var c = ++this.size_;
                            2 * c > this.max_ && (this.max_ *= 2, this.handles_ = f.PriorityQHeap.reallocNumeric_(this.handles_, this.max_ + 1));
                            if (0 === this.freeList_) var g = c;
                            else g = this.freeList_, this.freeList_ = this.handles_[this.freeList_];
                            this.verts_[g] = b;
                            this.handles_[g] =
                                c;
                            this.heap_[c] = g;
                            this.initialized_ && this.floatUp_(c);
                            return g
                        };
                        f.PriorityQHeap.prototype.isEmpty = function() {
                            return 0 === this.size_
                        };
                        f.PriorityQHeap.prototype.minimum = function() {
                            return this.verts_[this.heap_[1]]
                        };
                        f.PriorityQHeap.prototype.extractMin = function() {
                            var b = this.heap_,
                                c = this.verts_,
                                g = this.handles_,
                                e = b[1],
                                d = c[e];
                            0 < this.size_ && (b[1] = b[this.size_], g[b[1]] = 1, c[e] = null, g[e] = this.freeList_, this.freeList_ = e, 0 < --this.size_ && this.floatDown_(1));
                            return d
                        };
                        f.PriorityQHeap.prototype.remove = function(b) {
                            var c =
                                this.heap_,
                                g = this.verts_,
                                e = this.handles_;
                            f.assert(1 <= b && b <= this.max_ && null !== g[b]);
                            var d = e[b];
                            c[d] = c[this.size_];
                            e[c[d]] = d;
                            d <= --this.size_ && (1 >= d ? this.floatDown_(d) : f.geom.vertLeq(g[c[d >> 1]], g[c[d]]) ? this.floatDown_(d) : this.floatUp_(d));
                            g[b] = null;
                            e[b] = this.freeList_;
                            this.freeList_ = b
                        };
                        f.PriorityQHeap.prototype.floatDown_ = function(b) {
                            for (var c = this.heap_, g = this.verts_, e = this.handles_, d = c[b];;) {
                                var h = b << 1;
                                h < this.size_ && f.geom.vertLeq(g[c[h + 1]], g[c[h]]) && (h += 1);
                                f.assert(h <= this.max_);
                                var p = c[h];
                                if (h >
                                    this.size_ || f.geom.vertLeq(g[d], g[p])) {
                                    c[b] = d;
                                    e[d] = b;
                                    break
                                }
                                c[b] = p;
                                e[p] = b;
                                b = h
                            }
                        };
                        f.PriorityQHeap.prototype.floatUp_ = function(b) {
                            for (var c = this.heap_, g = this.verts_, e = this.handles_, d = c[b];;) {
                                var h = b >> 1,
                                    p = c[h];
                                if (0 === h || f.geom.vertLeq(g[p], g[d])) {
                                    c[b] = d;
                                    e[d] = b;
                                    break
                                }
                                c[b] = p;
                                e[p] = b;
                                b = h
                            }
                        };
                        f.ActiveRegion = function() {
                            this.nodeUp = this.eUp = null;
                            this.windingNumber = 0;
                            this.fixUpperEdge = this.dirty = this.sentinel = this.inside = !1
                        };
                        f.ActiveRegion.prototype.regionBelow = function() {
                            return this.nodeUp.getPredecessor().getKey()
                        };
                        f.ActiveRegion.prototype.regionAbove = function() {
                            return this.nodeUp.getSuccessor().getKey()
                        };
                        return f
                    })
                });
                const t = a.getLogger("esri.views.2d.engine.webgl.mesh.templates.Tesselator");
                return function() {
                    function r() {
                        this._indexCounter = this._currentVertexIndex = 0;
                        this._triangleIndices = [-1, -1, -1];
                        this.glu = new w.GluTesselator;
                        this.glu.gluTessCallback(w.gluEnum.GLU_TESS_BEGIN, this._begincallback.bind(this));
                        this.glu.gluTessCallback(w.gluEnum.GLU_TESS_VERTEX_DATA, this._vertexCallback.bind(this));
                        this.glu.gluTessCallback(w.gluEnum.GLU_TESS_END,
                            this._endcallback.bind(this));
                        this.glu.gluTessCallback(w.gluEnum.GLU_TESS_COMBINE, this._combinecallback.bind(this));
                        this.glu.gluTessCallback(w.gluEnum.GLU_TESS_ERROR, this._errorcallback.bind(this));
                        this.glu.gluTessCallback(w.gluEnum.GLU_TESS_EDGE_FLAG, this._edgeCallback.bind(this));
                        this.glu.gluTessProperty(w.gluEnum.GLU_TESS_WINDING_RULE, w.windingRule.GLU_TESS_WINDING_ODD)
                    }
                    var f = r.prototype;
                    f.beginPolygon = function(b, c) {
                        this._triangleIndices[0] = -1;
                        this._triangleIndices[1] = -1;
                        this._triangleIndices[2] = -1;
                        this._indexCounter = this._currentVertexIndex = 0;
                        this.glu.gluTessBeginPolygon(b);
                        this._indices = c
                    };
                    f.endPolygon = function() {
                        this.glu.gluTessEndPolygon()
                    };
                    f.beginContour = function() {
                        this.glu.gluTessBeginContour()
                    };
                    f.endContour = function() {
                        this.glu.gluTessEndContour()
                    };
                    f.addVertex = function(b, c) {
                        this.glu.gluTessVertex(b, c)
                    };
                    f._vertexCallback = function(b, c) {
                        c[c.length] = b[0];
                        c[c.length] = b[1];
                        this._triangleIndices[this._currentVertexIndex] = -1;
                        if (2 <= this._currentVertexIndex) {
                            for (b = 0; 3 > b; b++) - 1 === this._triangleIndices[b] &&
                                (this._triangleIndices[b] = this._indexCounter++), this._indices[this._indices.length] = this._triangleIndices[b];
                            this._currentVertexIndex = 0
                        } else this._currentVertexIndex++
                    };
                    f._begincallback = function() {
                        this._triangleIndices[0] = -1;
                        this._triangleIndices[1] = -1;
                        this._triangleIndices[2] = -1;
                        this._currentVertexIndex = 0
                    };
                    f._endcallback = function() {
                        this._currentVertexIndex = 0
                    };
                    f._errorcallback = function(b) {
                        t.error(`Encountered error during tesselation: ${b}`)
                    };
                    f._combinecallback = function(b) {
                        return [b[0], b[1], b[2]]
                    };
                    f._edgeCallback = function() {};
                    return r
                }()
            })
        },
        "esri/chunks/_commonjsHelpers": function() {
            define(["exports"], function(a) {
                function k() {
                    throw Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
                }
                a.commonjsGlobal = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : {};
                a.commonjsRequire = k;
                a.createCommonjsModule = function(w, t, r) {
                    return r = {
                        path: t,
                        exports: {},
                        require: function(f, b) {
                            return k(f,
                                void 0 === b || null === b ? r.path : b)
                        }
                    }, w(r, r.exports), r.exports
                };
                a.getDefaultExportFromCjs = function(w) {
                    return w && w.__esModule && Object.prototype.hasOwnProperty.call(w, "default") ? w["default"] : w
                }
            })
        },
        "esri/views/2d/engine/vectorTiles/buckets/LineBucket": function() {
            define(["../../../../../chunks/_rollupPluginBabelHelpers", "../../webgl/mesh/templates/util", "../../webgl/TurboLine", "./BaseBucket"], function(a, k, w, t) {
                const r = 1 / 3.8,
                    f = e => d => {
                        d.entry0 = e._lineVertexBuffer.index;
                        e._lineVertexBuffer.add(d.currentVertex.x,
                            d.currentVertex.y, d.prevNormal.x, d.prevNormal.y, 0, -1, d.distance, e._ddValues);
                        d.entry2 = e._lineVertexBuffer.index;
                        e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.prevNormal.x, -d.prevNormal.y, 0, 1, d.distance, e._ddValues);
                        d.exit0 = e._lineVertexBuffer.index;
                        e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.nextNormal.x, d.nextNormal.y, 0, -1, d.distance, e._ddValues);
                        d.exit2 = e._lineVertexBuffer.index;
                        e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.nextNormal.x, -d.nextNormal.y,
                            0, 1, d.distance, e._ddValues)
                    },
                    b = e => d => {
                        e._lineIndexBuffer.add(d.leftExit0, d.rightEntry0, d.leftExit2);
                        e._lineIndexBuffer.add(d.rightEntry0, d.rightEntry2, d.leftExit2)
                    },
                    c = e => d => {
                        var h = 2 === e._joinType ? e._miterLimitCosine : e._roundLimitCosine,
                            p = d.isCap && 0 !== e._capType,
                            l = !1;
                        .97 < d.cosine ? (d.exit0 = d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.bisector.x / d.cosine, d.bisector.y / d.cosine, 0, -1, d.distance, e._ddValues), d.exit2 = d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x,
                            d.currentVertex.y, -d.bisector.x / d.cosine, -d.bisector.y / d.cosine, 0, 1, d.distance, e._ddValues)) : d.cosine < 1 - .97 ? (d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.prevNormal.x, d.prevNormal.y, 0, -1, d.distance, e._ddValues), d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.prevNormal.x, -d.prevNormal.y, 0, 1, d.distance, e._ddValues), d.exit0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y,
                            d.nextNormal.x, d.nextNormal.y, 0, -1, d.distance, e._ddValues), d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.nextNormal.x, -d.nextNormal.y, 0, 1, d.distance, e._ddValues)) : d.canSplit ? (w.splitVertex(), 0 < d.sign ? (d.splitInner ? (d.exit0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.leftInner.x, d.leftInner.y, 0, -1, d.distance, e._ddValues), d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y,
                            d.rightInner.x, d.rightInner.y, 0, -1, d.distance, e._ddValues)) : (d.exit0 = d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.bisector.x / d.cosine, d.bisector.y / d.cosine, 0, -1, d.distance, e._ddValues)), d.cosine < h ? (l = !d.isCap, d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.prevNormal.x, -d.prevNormal.y, 0, 1, d.distance, e._ddValues), d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.nextNormal.x, -d.nextNormal.y, 0, 1, d.distance, e._ddValues)) : d.splitOuter ? (l = l || d.gapOuter, d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.leftOuter.x, -d.leftOuter.y, 0, 1, d.distance, e._ddValues), d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.rightOuter.x, -d.rightOuter.y, 0, 1, d.distance, e._ddValues)) : (d.entry2 = d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.bisector.x / d.cosine, -d.bisector.y / d.cosine, 0, 1, d.distance, e._ddValues))) : (d.splitInner ? (d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.leftInner.x, -d.leftInner.y, 0, 1, d.distance, e._ddValues), d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.rightInner.x, -d.rightInner.y, 0, 1, d.distance, e._ddValues)) : (d.exit2 = d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.bisector.x / d.cosine, -d.bisector.y / d.cosine, 0, 1, d.distance, e._ddValues)), d.cosine < h ? (l = !d.isCap, d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.prevNormal.x, d.prevNormal.y, 0, -1, d.distance, e._ddValues), d.exit0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.nextNormal.x, d.nextNormal.y, 0, -1, d.distance, e._ddValues)) : d.splitOuter ? (l = l || d.gapOuter, d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x,
                            d.currentVertex.y, d.leftOuter.x, d.leftOuter.y, 0, -1, d.distance, e._ddValues), d.exit0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.rightOuter.x, d.rightOuter.y, 0, -1, d.distance, e._ddValues)) : (d.exit0 = d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.bisector.x / d.cosine, d.bisector.y / d.cosine, 0, -1, d.distance, e._ddValues)))) : 0 < d.sign ? (d.exit0 = d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x,
                            d.currentVertex.y, d.bisector.x / d.cosine, d.bisector.y / d.cosine, 0, -1, d.distance, e._ddValues), d.cosine < h ? (l = !d.isCap, d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.prevNormal.x, -d.prevNormal.y, 0, 1, d.distance, e._ddValues), d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.nextNormal.x, -d.nextNormal.y, 0, 1, d.distance, e._ddValues)) : (d.entry2 = d.exit2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x,
                            d.currentVertex.y, -d.bisector.x / d.cosine, -d.bisector.y / d.cosine, 0, 1, d.distance, e._ddValues))) : (d.exit2 = d.entry2 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.bisector.x / d.cosine, -d.bisector.y / d.cosine, 0, 1, d.distance, e._ddValues), d.cosine < h ? (l = !d.isCap, d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.prevNormal.x, d.prevNormal.y, 0, -1, d.distance, e._ddValues), d.exit0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x,
                            d.currentVertex.y, d.nextNormal.x, d.nextNormal.y, 0, -1, d.distance, e._ddValues)) : (d.exit0 = d.entry0 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.bisector.x / d.cosine, d.bisector.y / d.cosine, 0, -1, d.distance, e._ddValues)));
                        d.canSplit && (d.splitInner || d.splitOuter) || l || p ? (h = d.entry1 = d.exit1 = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, 0, 0, 0, 0, d.distance, e._ddValues)) : h = d.entry1 = d.exit1 = null;
                        if (l && 1 !== e._joinType) e._lineIndexBuffer.add(h,
                            0 < d.sign ? d.exit2 : d.entry0, 0 < d.sign ? d.entry2 : d.exit0);
                        else if (p && 1 === e._capType || l && 1 === e._joinType) {
                            let z, v;
                            if (d.isCap) {
                                l = Math.PI;
                                p = Math.ceil(l / .8);
                                var n = l / p;
                                if (d.isFirstVertex) {
                                    var u = d.prevNormal.x;
                                    var y = d.prevNormal.y;
                                    z = d.entry0;
                                    v = d.entry2
                                } else d.isLastVertex && (u = -d.nextNormal.x, y = -d.nextNormal.y, z = d.exit2, v = d.exit0)
                            } else u = 2 * Math.acos(d.cosine), p = Math.ceil(u / .8), n = u / p, u = 0 < d.sign ? -d.prevNormal.x : d.nextNormal.x, y = 0 < d.sign ? -d.prevNormal.y : d.nextNormal.y, z = 0 < d.sign ? d.entry2 : d.exit0, v = 0 < d.sign ? d.exit2 :
                                d.entry0;
                            l = Math.cos(n);
                            n = Math.sin(n);
                            var x = n * u + l * y;
                            u = l * u - n * y;
                            y = x;
                            for (x = 0; x < p; ++x) {
                                var q = B;
                                if (x < p - 1)
                                    if (d.isCap) {
                                        const A = d.isFirstVertex ? -1 : 1;
                                        var B = e._lineVertexBuffer.index;
                                        e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, u, y, A, 0, d.distance, e._ddValues)
                                    } else B = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, u, y, 0, d.sign, d.distance, e._ddValues);
                                e._lineIndexBuffer.add(0 === x ? z : q, h, x === p - 1 ? v : B);
                                q = n * u + l * y;
                                u = l * u - n * y;
                                y = q
                            }
                        } else p && 2 === e._capType && (B = d.isFirstVertex ?
                            1 : -1, e._hasPattern ? (u = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.prevNormal.x - B * d.inbound.x, d.prevNormal.y - B * d.inbound.y, -B, -1, d.distance, e._ddValues), y = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.prevNormal.x - B * d.inbound.x, -d.prevNormal.y - B * d.inbound.y, -B, 1, d.distance, e._ddValues)) : (u = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, d.prevNormal.x - B * d.inbound.x, d.prevNormal.y -
                                B * d.inbound.y, 0, -1, d.distance, e._ddValues), y = e._lineVertexBuffer.index, e._lineVertexBuffer.add(d.currentVertex.x, d.currentVertex.y, -d.prevNormal.x - B * d.inbound.x, -d.prevNormal.y - B * d.inbound.y, 0, 1, d.distance, e._ddValues)), 0 < B ? (e._lineIndexBuffer.add(h, d.entry2, y), e._lineIndexBuffer.add(h, y, u), e._lineIndexBuffer.add(h, u, d.entry0)) : (e._lineIndexBuffer.add(h, y, d.exit2), e._lineIndexBuffer.add(h, u, y), e._lineIndexBuffer.add(h, d.exit0, u)))
                    },
                    g = e => d => {
                        e._lineIndexBuffer.add(d.leftExit0, d.rightEntry0, null != d.leftExit1 ?
                            d.leftExit1 : d.leftExit2);
                        e._lineIndexBuffer.add(d.rightEntry0, null != d.rightEntry1 ? d.rightEntry1 : d.rightEntry2, null != d.leftExit1 ? d.leftExit1 : d.leftExit2);
                        null != d.leftExit1 && null != d.rightEntry1 ? (e._lineIndexBuffer.add(d.leftExit1, d.rightEntry1, d.leftExit2), e._lineIndexBuffer.add(d.rightEntry1, d.rightEntry2, d.leftExit2)) : null != d.leftExit1 ? e._lineIndexBuffer.add(d.leftExit1, d.rightEntry2, d.leftExit2) : null != d.rightEntry1 && e._lineIndexBuffer.add(d.rightEntry1, d.rightEntry2, d.leftExit2)
                    };
                return function(e) {
                    function d(p,
                        l, n, u) {
                        l = e.call(this, p, l) || this;
                        l.type = 2;
                        l._tessellationOptions = {};
                        l.tessellationProperties = {
                            _lineVertexBuffer: null,
                            _lineIndexBuffer: null,
                            _hasPattern: null,
                            _ddValues: null,
                            _capType: null,
                            _joinType: null,
                            _miterLimitCosine: null,
                            _roundLimitCosine: null
                        };
                        l.tessellationProperties._lineVertexBuffer = n;
                        l.tessellationProperties._lineIndexBuffer = u;
                        l.tessellationProperties._hasPattern = p.getPaintValue("line-pattern", l.zoom) || 0 < p.getPaintValue("line-dasharray", l.zoom).length;
                        l._isThinLine = p.isThinLine;
                        l._tessellationCallbacks =
                            l._isThinLine ? {
                                vertex: f(l.tessellationProperties),
                                bridge: b(l.tessellationProperties)
                            } : {
                                vertex: c(l.tessellationProperties),
                                bridge: g(l.tessellationProperties)
                            };
                        return l
                    }
                    a._inheritsLoose(d, e);
                    var h = d.prototype;
                    h.processFeatures = function(p) {
                        this._lineIndexStart = 3 * this.tessellationProperties._lineIndexBuffer.index;
                        this._lineIndexCount = 0;
                        const l = this.layer,
                            n = this.zoom;
                        p && p.setExtent(this.layerExtent);
                        for (const u of this._features) {
                            const y = l.hasDataDrivenLine ? l.lineMaterial.encodeAttributes(u, n, l) : null;
                            this.tessellationProperties._capType = l.getLayoutValue("line-cap", n, u);
                            this.tessellationProperties._joinType = l.getLayoutValue("line-join", n, u);
                            this.tessellationProperties._miterLimitCosine = k.getLimitCosine(l.getLayoutValue("line-miter-limit", n, u));
                            this.tessellationProperties._roundLimitCosine = k.getLimitCosine(l.getLayoutValue("line-round-limit", n, u));
                            const x = u.getGeometry(p);
                            this._processFeature(x, y)
                        }
                        w.cleanup()
                    };
                    h.serialize = function() {
                        var p = 6 + this.layerUIDs.length;
                        p += this.tessellationProperties._lineVertexBuffer.array.length;
                        p += this.tessellationProperties._lineIndexBuffer.array.length;
                        p = new Uint32Array(p);
                        var l = new Int32Array(p.buffer);
                        let n = 0;
                        p[n++] = this.type;
                        p[n++] = this.layerUIDs.length;
                        for (var u = 0; u < this.layerUIDs.length; u++) p[n++] = this.layerUIDs[u];
                        p[n++] = this._lineIndexStart;
                        p[n++] = this._lineIndexCount;
                        p[n++] = this.tessellationProperties._lineVertexBuffer.array.length;
                        for (u = 0; u < this.tessellationProperties._lineVertexBuffer.array.length; u++) l[n++] = this.tessellationProperties._lineVertexBuffer.array[u];
                        p[n++] = this.tessellationProperties._lineIndexBuffer.array.length;
                        for (l = 0; l < this.tessellationProperties._lineIndexBuffer.array.length; l++) p[n++] = this.tessellationProperties._lineIndexBuffer.array[l];
                        return p.buffer
                    };
                    h._processFeature = function(p, l) {
                        if (p) {
                            var n = p.length;
                            for (let u = 0; u < n; u++) this._processGeometry(p[u], l)
                        }
                    };
                    h._processGeometry = function(p, l) {
                        if (!(2 > p.length)) {
                            for (var n = p[0], u = 1, y, x; u < p.length;) y = p[u].x - n.x, x = p[u].y - n.y, 1E-6 > y * y + x * x ? p.splice(u, 1) : (n = p[u], ++u);
                            2 > p.length || (n = 3 * this.tessellationProperties._lineIndexBuffer.index, this._tessellationOptions.trackDistance =
                                this.tessellationProperties._hasPattern, this._tessellationOptions.initialDistance = 0, this._tessellationOptions.thin = this._isThinLine, this._tessellationOptions.wrapDistance = 65535, this._tessellationOptions.outerBisectorAutoSplitThreshold = r, this._tessellationOptions.enableOuterBisectorSplit = this.tessellationProperties._hasPattern, this._tessellationOptions.innerBisectorAutoSplitThreshold = r, this._tessellationOptions.enableInnerBisectorSplit = this.tessellationProperties._hasPattern, this.tessellationProperties._ddValues =
                                l, w.tessellate(p, this._tessellationOptions, this._tessellationCallbacks), this._lineIndexCount += 3 * this.tessellationProperties._lineIndexBuffer.index - n)
                        }
                    };
                    a._createClass(d, [{
                        key: "lineIndexStart",
                        get: function() {
                            return this._lineIndexStart
                        }
                    }, {
                        key: "lineIndexCount",
                        get: function() {
                            return this._lineIndexCount
                        }
                    }]);
                    return d
                }(t)
            })
        },
        "esri/views/2d/engine/webgl/mesh/templates/util": function() {
            define(["exports"], function(a) {
                function k(w, t) {
                    return Math.sqrt(w * w + t * t)
                }
                a.dist = function(w, t) {
                    return k(w[0] - t[0], w[1] - t[1])
                };
                a.getLimitCosine = function(w) {
                    return 1 / Math.max(w, 1)
                };
                a.isExtent = function(w) {
                    return void 0 !== w.xmin && void 0 !== w.ymin && void 0 !== w.xmax && void 0 !== w.ymax
                };
                a.isFunction = function(w) {
                    return "function" === typeof w
                };
                a.isMultipoint = function(w) {
                    return void 0 !== w.points
                };
                a.isPoint = function(w) {
                    return void 0 !== w.x && void 0 !== w.y
                };
                a.isPolygon = function(w) {
                    return void 0 !== w.rings
                };
                a.isPolyline = function(w) {
                    return void 0 !== w.paths
                };
                a.len = k;
                a.normalize = function(w) {
                    const t = k(w[0], w[1]);
                    w[0] /= t;
                    w[1] /= t
                };
                a.sub = function(w,
                    t, r) {
                    w[0] = t[0] - r[0];
                    w[1] = t[1] - r[1];
                    return w
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/webgl/TurboLine": function() {
            define(["exports", "./mesh/templates/util"], function(a, k) {
                function w() {
                    if (q.cosine < d.innerBisectorAutoSplitThreshold) {
                        q.splitInner = !0;
                        q.gapInner = !0;
                        var v = Math.max(d.innerBisectorAutoSplitThreshold, q.cosine);
                        v = Math.sqrt(1 - v * v) / v;
                        q.leftInner.x = q.nextNormal.x + q.sign * v * q.outbound.x;
                        q.leftInner.y = q.nextNormal.y + q.sign * v * q.outbound.y;
                        q.rightInner.x = q.prevNormal.x -
                            q.sign * v * q.inbound.x;
                        q.rightInner.y = q.prevNormal.y - q.sign * v * q.inbound.y
                    } else d.enableInnerBisectorSplit && (q.splitInner = !0, q.gapInner = !1, q.leftInner.x = q.rightInner.x = q.bisector.x / q.cosine, q.leftInner.y = q.rightInner.y = q.bisector.y / q.cosine);
                    q.cosine < d.outerBisectorAutoSplitThreshold ? (q.splitOuter = !0, q.gapOuter = !0, v = Math.max(d.outerBisectorAutoSplitThreshold, q.cosine), v = Math.sqrt(1 - v * v) / v, q.leftOuter.x = q.prevNormal.x - q.sign * v * q.inbound.x, q.leftOuter.y = q.prevNormal.y - q.sign * v * q.inbound.y, q.rightOuter.x =
                        q.nextNormal.x + q.sign * v * q.outbound.x, q.rightOuter.y = q.nextNormal.y + q.sign * v * q.outbound.y) : d.enableOuterBisectorSplit && (q.splitOuter = !0, q.gapOuter = !1, q.leftOuter.x = q.rightOuter.x = q.bisector.x / q.cosine, q.leftOuter.y = q.rightOuter.y = q.bisector.y / q.cosine)
                }

                function t() {
                    if (u) q.distance = 0, u = q.isCap = q.isFirstVertex = q.isLastVertex = !1;
                    else {
                        if (0 === l)
                            if (q.isFirstVertex = 0 === p, x = e[p], 0 === p) {
                                if (l = 0, q.closed) {
                                    q.inbound.x = x.x - e[e.length - 2].x;
                                    q.inbound.y = x.y - e[e.length - 2].y;
                                    var v = Math.sqrt(q.inbound.x * q.inbound.x +
                                        q.inbound.y * q.inbound.y);
                                    q.inbound.x /= v;
                                    q.inbound.y /= v
                                }
                            } else q.inbound.x = x.x - y.x, q.inbound.y = x.y - y.y, l = Math.sqrt(q.inbound.x * q.inbound.x + q.inbound.y * q.inbound.y), q.inbound.x /= l, q.inbound.y /= l;
                        q.distance + l - n <= d.wrapDistance ? (p < e.length - 1 ? (q.outbound.x = e[p + 1].x - x.x, q.outbound.y = e[p + 1].y - x.y, v = Math.sqrt(q.outbound.x * q.outbound.x + q.outbound.y * q.outbound.y), q.outbound.x /= v, q.outbound.y /= v) : q.closed ? (q.outbound.x = e[1].x - x.x, q.outbound.y = e[1].y - x.y, v = Math.sqrt(q.outbound.x * q.outbound.x + q.outbound.y * q.outbound.y),
                            q.outbound.x /= v, q.outbound.y /= v) : (q.outbound.x = q.inbound.x, q.outbound.y = q.inbound.y), 0 !== p || q.closed || (q.inbound.x = q.outbound.x, q.inbound.y = q.outbound.y), ++p, q.isLastVertex = p === e.length, q.isCap = !q.closed && (q.isFirstVertex || q.isLastVertex), q.distance += l - n, n = l = 0, u = q.distance + l - n === d.wrapDistance, q.currentVertex.x = x.x, q.currentVertex.y = x.y, y = x, x = null) : (q.outbound.x = q.inbound.x, q.outbound.y = q.inbound.y, n += d.wrapDistance - q.distance, q.distance = d.wrapDistance, u = !0, v = n / l, q.currentVertex.x = (1 - v) * y.x + v * x.x,
                            q.currentVertex.y = (1 - v) * y.y + v * x.y)
                    }
                }

                function r() {
                    q.prevNormal.x = -q.inbound.y;
                    q.prevNormal.y = q.inbound.x;
                    q.nextNormal.x = -q.outbound.y;
                    q.nextNormal.y = q.outbound.x
                }

                function f() {
                    r();
                    q.bisector.x = q.prevNormal.x + q.nextNormal.x;
                    q.bisector.y = q.prevNormal.y + q.nextNormal.y;
                    const v = Math.sqrt(q.bisector.x * q.bisector.x + q.bisector.y * q.bisector.y);
                    .001 > v ? (q.bisector.x = void 0, q.bisector.y = void 0, q.cosine = 0, q.sign = void 0) : (q.bisector.x /= v, q.bisector.y /= v, q.cosine = q.bisector.x * q.nextNormal.x + q.bisector.y * q.nextNormal.y,
                        q.sign = 0 <= q.prevNormal.x * q.nextNormal.y - q.prevNormal.y * q.nextNormal.x ? 1 : -1)
                }

                function b(v) {
                    h.vertex(q);
                    1 === v ? (q.leftEntry0 = q.entry0, q.leftEntry1 = q.entry1, q.leftEntry2 = q.entry2, q.leftExit0 = q.exit0, q.leftExit1 = q.exit1, q.leftExit2 = q.exit2) : 2 === v && (q.rightEntry0 = q.entry0, q.rightEntry1 = q.entry1, q.rightEntry2 = q.entry2, q.rightExit0 = q.exit0, q.rightExit1 = q.exit1, q.rightExit2 = q.exit2)
                }

                function c(v) {
                    h.vertex(q);
                    1 === v ? (q.leftEntry0 = q.entry0, q.leftEntry2 = q.entry2, q.leftExit0 = q.exit0, q.leftExit2 = q.exit2) : 2 === v &&
                        (q.rightEntry0 = q.entry0, q.rightEntry2 = q.entry2, q.rightExit0 = q.exit0, q.rightExit2 = q.exit2)
                }
                let g = function() {
                        this.isCap = this.isLastVertex = this.isFirstVertex = this.closed = void 0;
                        this.currentVertex = {
                            x: void 0,
                            y: void 0
                        };
                        this.inbound = {
                            x: void 0,
                            y: void 0
                        };
                        this.outbound = {
                            x: void 0,
                            y: void 0
                        };
                        this.prevNormal = {
                            x: void 0,
                            y: void 0
                        };
                        this.nextNormal = {
                            x: void 0,
                            y: void 0
                        };
                        this.bisector = {
                            x: void 0,
                            y: void 0
                        };
                        this.leftInner = {
                            x: void 0,
                            y: void 0
                        };
                        this.rightInner = {
                            x: void 0,
                            y: void 0
                        };
                        this.leftOuter = {
                            x: void 0,
                            y: void 0
                        };
                        this.rightOuter = {
                            x: void 0,
                            y: void 0
                        }
                    },
                    e;
                const d = {};
                let h, p = void 0,
                    l, n, u, y, x;
                const q = new g;
                let B = function() {
                        function v(m, E) {
                            this.writeVertex = m;
                            this.writeTriangle = E;
                            this.capType = 0;
                            this.joinType = 2;
                            this.miterLimitCosine = k.getLimitCosine(2);
                            this.roundLimitCosine = Math.cos(23 * Math.PI / 180);
                            this.almostParallelCosine = .97;
                            this.radsPerSlice = .8;
                            this.joinOnUTurn = this.textured = !1
                        }
                        var A = v.prototype;
                        A.vertex = function(m) {
                            var E = 2 === this.joinType ? this.miterLimitCosine : this.roundLimitCosine,
                                C = m.isCap && 0 !== this.capType,
                                G = !1;
                            m.cosine > this.almostParallelCosine ?
                                (m.exit0 = m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.bisector.x / m.cosine, m.bisector.y / m.cosine, 0, -1, m.distance), m.exit2 = m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.bisector.x / m.cosine, -m.bisector.y / m.cosine, 0, 1, m.distance)) : m.cosine < 1 - this.almostParallelCosine ? (G = !m.isCap && this.joinOnUTurn, m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.prevNormal.x, m.prevNormal.y, 0, -1, m.distance), m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y,
                                    0, 0, -m.prevNormal.x, -m.prevNormal.y, 0, 1, m.distance), m.exit0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.nextNormal.x, m.nextNormal.y, 0, -1, m.distance), m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.nextNormal.x, -m.nextNormal.y, 0, 1, m.distance)) : m.canSplit ? (w(), 0 < m.sign ? (m.splitInner ? (m.exit0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.outbound.x, m.outbound.y, m.leftInner.x, m.leftInner.y, 0, -1, m.distance), m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y,
                                    m.inbound.x, m.inbound.y, m.rightInner.x, m.rightInner.y, 0, -1, m.distance)) : m.exit0 = m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.inbound.x, m.inbound.y, m.bisector.x / m.cosine, m.bisector.y / m.cosine, 0, -1, m.distance), m.cosine < E ? (G = !m.isCap, m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.prevNormal.x, -m.prevNormal.y, 0, 1, m.distance), m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.nextNormal.x, -m.nextNormal.y, 0, 1, m.distance)) : m.splitOuter ? (G = G || m.gapOuter,
                                    m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.inbound.x, m.inbound.y, -m.leftOuter.x, -m.leftOuter.y, 0, 1, m.distance), m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.outbound.x, m.outbound.y, -m.rightOuter.x, -m.rightOuter.y, 0, 1, m.distance)) : m.entry2 = m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.bisector.x / m.cosine, -m.bisector.y / m.cosine, 0, 1, m.distance)) : (m.splitInner ? (m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.outbound.x, m.outbound.y, -m.leftInner.x, -m.leftInner.y, 0, 1, m.distance), m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.inbound.x, m.inbound.y, -m.rightInner.x, -m.rightInner.y, 0, 1, m.distance)) : m.exit2 = m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.bisector.x / m.cosine, -m.bisector.y / m.cosine, 0, 1, m.distance), m.cosine < E ? (G = !m.isCap, m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.prevNormal.x, m.prevNormal.y, 0, -1, m.distance), m.exit0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y,
                                    0, 0, m.nextNormal.x, m.nextNormal.y, 0, -1, m.distance)) : m.splitOuter ? (G = G || m.gapOuter, m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.inbound.x, m.inbound.y, m.leftOuter.x, m.leftOuter.y, 0, -1, m.distance), m.exit0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.outbound.x, m.outbound.y, m.rightOuter.x, m.rightOuter.y, 0, -1, m.distance)) : m.exit0 = m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.bisector.x / m.cosine, m.bisector.y / m.cosine, 0, -1, m.distance))) : 0 < m.sign ? (m.exit0 =
                                    m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, m.inbound.x, m.inbound.y, m.bisector.x / m.cosine, m.bisector.y / m.cosine, 0, -1, m.distance), m.cosine < E ? (G = !m.isCap, m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.prevNormal.x, -m.prevNormal.y, 0, 1, m.distance), m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.nextNormal.x, -m.nextNormal.y, 0, 1, m.distance)) : m.entry2 = m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.bisector.x / m.cosine, -m.bisector.y /
                                        m.cosine, 0, 1, m.distance)) : (m.exit2 = m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.bisector.x / m.cosine, -m.bisector.y / m.cosine, 0, 1, m.distance), m.cosine < E ? (G = !m.isCap, m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.prevNormal.x, m.prevNormal.y, 0, -1, m.distance), m.exit0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.nextNormal.x, m.nextNormal.y, 0, -1, m.distance)) : m.exit0 = m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.bisector.x / m.cosine,
                                    m.bisector.y / m.cosine, 0, -1, m.distance));
                            E = m.canSplit && (m.splitInner || m.splitOuter) || G || C ? m.entry1 = m.exit1 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, 0, 0, 0, 0, m.distance) : m.entry1 = m.exit1 = null;
                            if (G && 1 !== this.joinType) this.writeTriangle(E, 0 < m.sign ? m.exit2 : m.entry0, 0 < m.sign ? m.entry2 : m.exit0);
                            else if (C && 1 === this.capType || G && 1 === this.joinType) {
                                let Y, W;
                                if (m.isCap) {
                                    G = Math.PI;
                                    C = Math.ceil(G / this.radsPerSlice);
                                    var F = G / C;
                                    if (m.isFirstVertex) {
                                        var D = m.prevNormal.x;
                                        var H = m.prevNormal.y;
                                        Y = m.entry0;
                                        W =
                                            m.entry2
                                    } else m.isLastVertex && (D = -m.nextNormal.x, H = -m.nextNormal.y, Y = m.exit2, W = m.exit0)
                                } else D = 2 * Math.acos(m.cosine), C = Math.ceil(D / this.radsPerSlice), F = D / C, D = 0 < m.sign ? -m.prevNormal.x : m.nextNormal.x, H = 0 < m.sign ? -m.prevNormal.y : m.nextNormal.y, Y = 0 < m.sign ? m.entry2 : m.exit0, W = 0 < m.sign ? m.exit2 : m.entry0;
                                G = Math.cos(F);
                                F = Math.sin(F);
                                var I = F * D + G * H;
                                D = G * D - F * H;
                                H = I;
                                var Q;
                                for (I = 0; I < C; ++I) {
                                    var P = Q;
                                    I < C - 1 && (Q = m.isCap ? this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, D, H, m.isFirstVertex ? -1 : 1, 0, m.distance) : this.writeVertex(m.currentVertex.x,
                                        m.currentVertex.y, 0, 0, D, H, 0, m.sign, m.distance));
                                    this.writeTriangle(0 === I ? Y : P, E, I === C - 1 ? W : Q);
                                    P = F * D + G * H;
                                    D = G * D - F * H;
                                    H = P
                                }
                            } else C && 2 === this.capType && (Q = m.isFirstVertex ? 1 : -1, this.textured ? (D = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.prevNormal.x - Q * m.inbound.x, m.prevNormal.y - Q * m.inbound.y, -Q, -1, m.distance), H = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.prevNormal.x - Q * m.inbound.x, -m.prevNormal.y - Q * m.inbound.y, -Q, 1, m.distance)) : (D = this.writeVertex(m.currentVertex.x, m.currentVertex.y,
                                0, 0, m.prevNormal.x - Q * m.inbound.x, m.prevNormal.y - Q * m.inbound.y, 0, -1, m.distance), H = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.prevNormal.x - Q * m.inbound.x, -m.prevNormal.y - Q * m.inbound.y, 0, 1, m.distance)), 0 < Q ? (this.writeTriangle(E, m.entry2, H), this.writeTriangle(E, H, D), this.writeTriangle(E, D, m.entry0)) : (this.writeTriangle(E, H, m.exit2), this.writeTriangle(E, D, H), this.writeTriangle(E, m.exit0, D)))
                        };
                        A.bridge = function(m) {
                            this.writeTriangle(m.leftExit0, m.rightEntry0, null != m.leftExit1 ? m.leftExit1 :
                                m.leftExit2);
                            this.writeTriangle(m.rightEntry0, null != m.rightEntry1 ? m.rightEntry1 : m.rightEntry2, null != m.leftExit1 ? m.leftExit1 : m.leftExit2);
                            null != m.leftExit1 && null != m.rightEntry1 ? (this.writeTriangle(m.leftExit1, m.rightEntry1, m.leftExit2), this.writeTriangle(m.rightEntry1, m.rightEntry2, m.leftExit2)) : null != m.leftExit1 ? this.writeTriangle(m.leftExit1, m.rightEntry2, m.leftExit2) : null != m.rightEntry1 && this.writeTriangle(m.rightEntry1, m.rightEntry2, m.leftExit2)
                        };
                        return v
                    }(),
                    z = function() {
                        function v(m, E) {
                            this.writeVertex =
                                m;
                            this.writeTriangle = E
                        }
                        var A = v.prototype;
                        A.vertex = function(m) {
                            m.entry0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.prevNormal.x, m.prevNormal.y, 0, -1, m.distance);
                            m.entry2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.prevNormal.x, -m.prevNormal.y, 0, 1, m.distance);
                            m.exit0 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, m.nextNormal.x, m.nextNormal.y, 0, -1, m.distance);
                            m.exit2 = this.writeVertex(m.currentVertex.x, m.currentVertex.y, 0, 0, -m.nextNormal.x, -m.nextNormal.y, 0, 1,
                                m.distance)
                        };
                        A.bridge = function(m) {
                            this.writeTriangle(m.leftExit0, m.rightEntry0, m.leftExit2);
                            this.writeTriangle(m.rightEntry0, m.rightEntry2, m.leftExit2)
                        };
                        return v
                    }();
                a.StandardTessellationCallbacks = B;
                a.TessellationState = g;
                a.ThinTessellationCallbacks = z;
                a.cleanup = function() {
                    h = e = null
                };
                a.splitVertex = w;
                a.tessellate = function(v, A, m) {
                    d.trackDistance = null != A.trackDistance ? A.trackDistance : !1;
                    d.wrapDistance = null != A.wrapDistance ? A.wrapDistance : 65535;
                    d.thin = null != A.thin ? A.thin : !1;
                    d.initialDistance = null != A.initialDistance ?
                        A.initialDistance : 0;
                    d.enableOuterBisectorSplit = null != A.enableOuterBisectorSplit ? A.enableOuterBisectorSplit : !1;
                    d.outerBisectorAutoSplitThreshold = null != A.outerBisectorAutoSplitThreshold ? A.outerBisectorAutoSplitThreshold : 0;
                    d.enableInnerBisectorSplit = null != A.enableOuterBisectorSplit ? A.enableOuterBisectorSplit : !1;
                    d.innerBisectorAutoSplitThreshold = null != A.innerBisectorAutoSplitThreshold ? A.innerBisectorAutoSplitThreshold : 0;
                    e = v;
                    h = m;
                    n = l = p = 0;
                    u = !1;
                    x = y = null;
                    q.currentVertex.x = null;
                    q.currentVertex.y = null;
                    q.distance =
                        d.initialDistance;
                    v = e[0];
                    A = e[e.length - 1];
                    q.canSplit = !1;
                    q.closed = v.x === A.x && v.y === A.y;
                    if (!(2 > e.length || 2 === e.length && q.closed))
                        if (d.thin)
                            if (d.trackDistance)
                                for (t(), r(), c(1); l - n > d.wrapDistance || p < e.length;) t(), r(), c(2), h.bridge(q), q.leftExit0 = q.rightExit0, q.leftExit2 = q.rightExit2;
                            else
                                for (; p < e.length;) 0 < p && (q.inbound.x = q.outbound.x, q.inbound.y = q.outbound.y), p < e.length - 1 ? (q.outbound.x = e[p + 1].x - e[p].x, q.outbound.y = e[p + 1].y - e[p].y, v = Math.sqrt(q.outbound.x * q.outbound.x + q.outbound.y * q.outbound.y), q.distance +=
                                    v, q.outbound.x /= v, q.outbound.y /= v) : (q.outbound.x = q.inbound.x, q.outbound.y = q.inbound.y), 0 === p && (q.inbound.x = q.outbound.x, q.inbound.y = q.outbound.y), q.currentVertex.x = e[p].x, q.currentVertex.y = e[p].y, q.prevNormal.x = -q.inbound.y, q.prevNormal.y = q.inbound.x, q.nextNormal.x = -q.outbound.y, q.nextNormal.y = q.outbound.x, 0 === p ? (h.vertex(q), q.leftEntry0 = q.entry0, q.leftEntry2 = q.entry2, q.leftExit0 = q.exit0, q.leftExit2 = q.exit2) : (h.vertex(q), q.rightEntry0 = q.entry0, q.rightEntry2 = q.entry2, q.rightExit0 = q.exit0, q.rightExit2 =
                                    q.exit2, h.bridge(q), q.leftExit0 = q.rightExit0, q.leftExit2 = q.rightExit2), ++p;
                    else {
                        if (d.enableOuterBisectorSplit || 0 < d.outerBisectorAutoSplitThreshold || d.enableInnerBisectorSplit || 0 < d.innerBisectorAutoSplitThreshold)
                            for (q.canSplit = !0, t(), f(), q.splitInner = q.gapInner = q.splitOuter = q.gapOuter = !1, b(1), q.closure0 = q.leftEntry0, q.closure1 = q.leftEntry1, q.closure2 = q.leftEntry2; l - n > d.wrapDistance || p < e.length - 1 || p < e.length && (!q.closed || d.trackDistance);) t(), f(), q.splitInner = q.gapInner = q.splitOuter = q.gapOuter = !1,
                                b(2), h.bridge(q), q.leftExit0 = q.rightExit0, q.leftExit1 = q.rightExit1, q.leftExit2 = q.rightExit2;
                        else
                            for (t(), f(), b(1), q.closure0 = q.leftEntry0, q.closure1 = q.leftEntry1, q.closure2 = q.leftEntry2; l - n > d.wrapDistance || p < e.length - 1 || p < e.length && (!q.closed || d.trackDistance);) t(), f(), b(2), h.bridge(q), q.leftExit0 = q.rightExit0, q.leftExit1 = q.rightExit1, q.leftExit2 = q.rightExit2;
                        q.closed && !d.trackDistance && (q.rightEntry0 = q.closure0, q.rightEntry1 = q.closure1, q.rightEntry2 = q.closure2, h.bridge(q), q.leftExit0 = q.rightExit0,
                            q.leftExit1 = q.rightExit1, q.leftExit2 = q.rightExit2)
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/views/2d/engine/vectorTiles/buckets/SymbolBucket": function() {
            define("../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/string ../../../../../core/BidiEngine ../GeometryUtils ../style/StyleLayer ../../webgl/Geometry ../TextShaping ../Placement ./BaseBucket".split(" "), function(a, k, w, t, r, f, b, c, g) {
                function e(d, h) {
                    return d.iconMosaicItem && h.iconMosaicItem ? d.iconMosaicItem.page ===
                        h.iconMosaicItem.page ? 0 : d.iconMosaicItem.page - h.iconMosaicItem.page : d.iconMosaicItem && !h.iconMosaicItem ? 1 : !d.iconMosaicItem && h.iconMosaicItem ? -1 : 0
                }
                g = function(d) {
                    function h(l, n, u, y, x, q, B, z) {
                        l = d.call(this, l, n) || this;
                        l.type = 3;
                        l._markerMap = new Map;
                        l._glyphMap = new Map;
                        l._glyphBufferDataStorage = new Map;
                        l._isIconSDF = !1;
                        l._iconVertexBuffer = u;
                        l._iconIndexBuffer = y;
                        l._textVertexBuffer = x;
                        l._textIndexBuffer = q;
                        l._placementEngine = B;
                        l._workerTileHandler = z;
                        return l
                    }
                    a._inheritsLoose(h, d);
                    var p = h.prototype;
                    p.getResources =
                        function(l, n, u) {
                            const y = this.layer,
                                x = this.zoom;
                            l && l.setExtent(this.layerExtent);
                            const q = y.getLayoutProperty("icon-image"),
                                B = y.getLayoutProperty("text-field");
                            let z = y.getLayoutProperty("text-transform"),
                                v = y.getLayoutProperty("text-font");
                            const A = [];
                            let m;
                            q && !q.isDataDriven && (m = q.getValue(x));
                            let E;
                            B && !B.isDataDriven && (E = B.getValue(x));
                            let C;
                            z && z.isDataDriven || (C = y.getLayoutValue("text-transform", x), z = null);
                            let G;
                            v && v.isDataDriven || (G = y.getLayoutValue("text-font", x), v = null);
                            for (const I of this._features) {
                                var F =
                                    I.getGeometry(l);
                                if (!F || 0 === F.length) continue;
                                let Q;
                                q && (Q = q.isDataDriven ? q.getValue(x, I) : this._replaceKeys(m, I.values)) && n.add(Q);
                                let P;
                                var D = !1;
                                if (B && (P = B.isDataDriven ? B.getValue(x, I) : this._replaceKeys(E, I.values))) {
                                    P = P.replace(/\\n/g, "\n");
                                    z && (C = z.getValue(x, I));
                                    switch (C) {
                                        case 2:
                                            P = P.toLowerCase();
                                            break;
                                        case 1:
                                            P = P.toUpperCase()
                                    }
                                    h._bidiEngine.hasBidiChar(P) && (D = "rtl" === h._bidiEngine.checkContextual(P) ? "IDNNN" : "ICNNN", P = h._bidiEngine.bidiTransform(P, D, "VLYSN"), D = !0);
                                    var H = P.length;
                                    if (0 < H) {
                                        v && (G = v.getValue(x,
                                            I));
                                        for (const Y of G) {
                                            let W = u[Y];
                                            W || (W = u[Y] = new Set);
                                            for (let X = 0; X < H; X++) {
                                                const ba = P.charCodeAt(X);
                                                W.add(ba)
                                            }
                                        }
                                    }
                                }
                                if (Q || P) H = y.getLayoutValue("symbol-sort-key", x, I), F = {
                                    feature: I,
                                    sprite: Q,
                                    label: P,
                                    rtl: D,
                                    geometry: F,
                                    hash: (P ? k.numericHash(P) : 0) ^ (Q ? k.numericHash(Q) : 0),
                                    priority: H,
                                    textFont: G
                                }, A.push(F)
                            }
                            this._symbolFeatures = A
                        };
                    p.processFeatures = function(l) {
                        l && l.setExtent(this.layerExtent);
                        var n = this.layer;
                        l = this.zoom;
                        const u = n.getLayoutValue("symbol-placement", l),
                            y = 0 !== u,
                            x = n.getLayoutValue("symbol-spacing", l) *
                            c.TILE_PIXEL_RATIO;
                        var q = n.getLayoutProperty("icon-image"),
                            B = n.getLayoutProperty("text-field");
                        const z = q ? new r.IconLayout(n, l, y) : null;
                        n = B ? new r.TextLayout(n, l, y) : null;
                        const v = this._workerTileHandler;
                        let A;
                        q && (A = v.getSpriteItems());
                        this._iconIndexStart = 3 * this._iconIndexBuffer.index;
                        this._textIndexStart = 3 * this._textIndexBuffer.index;
                        this._textIndexCount = this._iconIndexCount = 0;
                        this._markerMap.clear();
                        this._glyphMap.clear();
                        q = [];
                        B = 1;
                        n && n.size && (B = n.size / b.SDF_GLYPH_SIZE);
                        const m = n ? n.maxAngle * t.C_DEG_TO_RAD :
                            0,
                            E = n ? n.size * c.TILE_PIXEL_RATIO : 0;
                        for (const D of this._symbolFeatures) {
                            let H;
                            z && A && D.sprite && (H = A[D.sprite]) && H.sdf && (this._isIconSDF = !0);
                            H && z.update(l, D.feature);
                            var C = void 0,
                                G = 0,
                                F = D.label;
                            if (F) {
                                n.update(l, D.feature);
                                C = y ? n.keepUpright : n.writingMode && 0 <= n.writingMode.indexOf(1);
                                let I = .5;
                                switch (n.anchor) {
                                    case 5:
                                    case 1:
                                    case 7:
                                        I = 0;
                                        break;
                                    case 6:
                                    case 2:
                                    case 8:
                                        I = 1
                                }
                                let Q = .5;
                                switch (n.anchor) {
                                    case 5:
                                    case 3:
                                    case 6:
                                        Q = 0;
                                        break;
                                    case 7:
                                    case 4:
                                    case 8:
                                        Q = 1
                                }
                                let P = .5;
                                switch (n.justify) {
                                    case 0:
                                        P = I;
                                        break;
                                    case 1:
                                        P = 0;
                                        break;
                                    case 3:
                                        P = 1
                                }
                                const Y = n.letterSpacing * b.SDF_GLYPH_SIZE,
                                    W = y ? 0 : n.maxWidth * b.SDF_GLYPH_SIZE,
                                    X = n.lineHeight * b.SDF_GLYPH_SIZE,
                                    ba = D.textFont.map(V => v.getGlyphItems(V));
                                if ((C = (new b.TextShaping(ba, W, X, Y, I, Q, P)).getShaping(F, D.rtl, C)) && 0 < C.length) {
                                    G = 1E30;
                                    F = -1E30;
                                    for (const V of C) G = Math.min(G, V.x), F = Math.max(F, V.x);
                                    G = (F - G + 2 * b.SDF_GLYPH_SIZE) * B * c.TILE_PIXEL_RATIO
                                }
                            }
                            for (let I of D.geometry) {
                                F = [];
                                1 === u ? (C && 0 < C.length && n && n.size && (I = h._smoothVertices(I, n.size * c.TILE_PIXEL_RATIO * (2 + Math.min(2, 4 * Math.abs(n.offset[1]))))),
                                    h._pushAnchors(F, I, x, G)) : 2 === u ? h._pushCenterAnchor(F, I) : 3 === D.feature.type ? h._pushCentroid(F, I) : F.push(new c.Anchor(I[0].x, I[0].y));
                                for (const Q of F) 0 > Q.x || Q.x > c.TILE_COORD_SIZE || 0 > Q.y || Q.y > c.TILE_COORD_SIZE || y && 0 < G && 0 === n.rotationAlignment && !h._honorsTextMaxAngle(I, Q, G, m, E) || (F = {
                                    shaping: C,
                                    line: I,
                                    iconMosaicItem: H,
                                    anchor: Q,
                                    symbolFeature: D,
                                    textColliders: [],
                                    iconColliders: [],
                                    textVertexRanges: [],
                                    iconVertexRanges: []
                                }, q.push(F), this._processFeature(F, z, n))
                            }
                        }
                        q.sort(e);
                        this._addPlacedGlyphs();
                        this._symbolInstances =
                            q
                    };
                    p.serialize = function() {
                        var l = 11 + this.layerUIDs.length;
                        l += 3 * this.markerPageMap.size;
                        l += 3 * this.glyphsPageMap.size;
                        l += h.symbolsSerializationLength(this._symbolInstances);
                        l += this._iconVertexBuffer.array.length;
                        l += this._iconIndexBuffer.array.length;
                        l += this._textVertexBuffer.array.length;
                        l += this._textIndexBuffer.array.length;
                        l = new Uint32Array(l);
                        var n = new Int32Array(l.buffer),
                            u = new Float32Array(l.buffer);
                        let y = 0;
                        l[y++] = this.type;
                        l[y++] = this.layerUIDs.length;
                        for (let x = 0; x < this.layerUIDs.length; x++) l[y++] =
                            this.layerUIDs[x];
                        l[y++] = this._isIconSDF ? 1 : 0;
                        l[y++] = this.markerPageMap.size;
                        for (const [x, [q, B]] of this.markerPageMap) l[y++] = x, l[y++] = q, l[y++] = B;
                        l[y++] = this.glyphsPageMap.size;
                        for (const [x, [q, B]] of this.glyphsPageMap) l[y++] = x, l[y++] = q, l[y++] = B;
                        l[y++] = this._iconVertexBuffer.index / 4;
                        l[y++] = this._textVertexBuffer.index / 4;
                        y = h.serializeSymbols(l, n, u, y, this._symbolInstances);
                        l[y++] = this._iconVertexBuffer.array.length;
                        for (u = 0; u < this._iconVertexBuffer.array.length; u++) n[y++] = this._iconVertexBuffer.array[u];
                        l[y++] = this._iconIndexBuffer.array.length;
                        for (u = 0; u < this._iconIndexBuffer.array.length; u++) l[y++] = this._iconIndexBuffer.array[u];
                        l[y++] = this._textVertexBuffer.array.length;
                        for (u = 0; u < this._textVertexBuffer.array.length; u++) n[y++] = this._textVertexBuffer.array[u];
                        l[y++] = this._textIndexBuffer.array.length;
                        for (n = 0; n < this._textIndexBuffer.array.length; n++) l[y++] = this._textIndexBuffer.array[n];
                        return l.buffer
                    };
                    h.symbolsSerializationLength = function(l) {
                        let n;
                        n = 1;
                        for (const u of l || []) {
                            n += 4;
                            n += 1;
                            for (const y of u.textColliders) n +=
                                10;
                            for (const y of u.iconColliders) n += 10;
                            n += 1;
                            n += 2 * u.textVertexRanges.length;
                            n += 1;
                            n += 2 * u.iconVertexRanges.length
                        }
                        return n
                    };
                    h.serializeSymbols = function(l, n, u, y, x) {
                        x = x || [];
                        n[y++] = x.length;
                        for (const q of x) {
                            n[y++] = q.anchor.x;
                            n[y++] = q.anchor.y;
                            n[y++] = q.symbolFeature.hash;
                            n[y++] = q.symbolFeature.priority;
                            n[y++] = q.textColliders.length + q.iconColliders.length;
                            for (const B of q.textColliders) n[y++] = B.xTile, n[y++] = B.yTile, n[y++] = B.dxPixels, n[y++] = B.dyPixels, n[y++] = B.hard ? 1 : 0, n[y++] = B.partIndex, u[y++] = B.minLod,
                                u[y++] = B.maxLod, n[y++] = B.width, n[y++] = B.height;
                            for (const B of q.iconColliders) n[y++] = B.xTile, n[y++] = B.yTile, n[y++] = B.dxPixels, n[y++] = B.dyPixels, n[y++] = B.hard ? 1 : 0, n[y++] = B.partIndex, u[y++] = B.minLod, u[y++] = B.maxLod, n[y++] = B.width, n[y++] = B.height;
                            n[y++] = q.textVertexRanges.length;
                            for (const [B, z] of q.textVertexRanges) n[y++] = B, n[y++] = z;
                            n[y++] = q.iconVertexRanges.length;
                            for (const [B, z] of q.iconVertexRanges) n[y++] = B, n[y++] = z
                        }
                        return y
                    };
                    p._replaceKeys = function(l, n) {
                        return l.replace(/{([^{}]+)}/g, function(u,
                            y) {
                            return y in n ? n[y] : ""
                        })
                    };
                    p._processFeature = function(l, n, u) {
                        const {
                            line: y,
                            iconMosaicItem: x,
                            shaping: q,
                            anchor: B
                        } = l, z = this.zoom;
                        var v = this.layer,
                            A = !!x,
                            m = !0;
                        A && (m = n.optional || !x);
                        var E = q && 0 < q.length,
                            C = !0;
                        E && (C = u.optional);
                        var G;
                        A && (G = this._placementEngine.getIconPlacement(B, x, n));
                        if (G || m) {
                            var F;
                            E && (F = this._placementEngine.getTextPlacement(B, q, y, u));
                            if (F || C) {
                                G && F || (C || m ? C || F ? m || G || (F = null) : G = null : F = G = null);
                                if (F && (A = v.hasDataDrivenText ? v.textMaterial.encodeAttributes(l.symbolFeature.feature, z, v) : null,
                                        this._storePlacedGlyphs(l, F.shapes, z, u.rotationAlignment, A), F.textColliders)) {
                                    l.textColliders = F.textColliders;
                                    for (var D of F.textColliders)
                                        if (D.minLod = Math.max(z + t.log2(D.minLod), 0), D.maxLod = Math.min(z + t.log2(D.maxLod), 25), u = D.angle) {
                                            m = Math.cos(u);
                                            var H = Math.sin(u);
                                            E = D.dxPixels * m - D.dyPixels * H;
                                            u = D.dxPixels * H + D.dyPixels * m;
                                            C = (D.dxPixels + D.width) * m - D.dyPixels * H;
                                            F = (D.dxPixels + D.width) * H + D.dyPixels * m;
                                            const I = D.dxPixels * m - (D.dyPixels + D.height) * H;
                                            A = D.dxPixels * H + (D.dyPixels + D.height) * m;
                                            const Q = (D.dxPixels +
                                                D.width) * m - (D.dyPixels + D.height) * H;
                                            H = (D.dxPixels + D.width) * H + (D.dyPixels + D.height) * m;
                                            m = Math.min(E, C, I, Q);
                                            E = Math.max(E, C, I, Q);
                                            C = Math.min(u, F, A, H);
                                            u = Math.max(u, F, A, H);
                                            D.dxPixels = m;
                                            D.dyPixels = C;
                                            D.width = E - m;
                                            D.height = u - C
                                        }
                                }
                                if (G && (v = v.hasDataDrivenIcon ? v.iconMaterial.encodeAttributes(l.symbolFeature.feature, z, v) : null, this._addPlacedIcons(l, G.shapes, z, x.page, 1 === n.rotationAlignment, v), G.iconColliders)) {
                                    l.iconColliders = G.iconColliders;
                                    for (const I of G.iconColliders)
                                        if (I.minLod = Math.max(z + t.log2(I.minLod), 0),
                                            I.maxLod = Math.min(z + t.log2(I.maxLod), 25), l = I.angle) v = Math.cos(l), m = Math.sin(l), D = I.dxPixels * v - I.dyPixels * m, l = I.dxPixels * m + I.dyPixels * v, u = (I.dxPixels + I.width) * v - I.dyPixels * m, n = (I.dxPixels + I.width) * m + I.dyPixels * v, F = I.dxPixels * v - (I.dyPixels + I.height) * m, G = I.dxPixels * m + (I.dyPixels + I.height) * v, A = (I.dxPixels + I.width) * v - (I.dyPixels + I.height) * m, m = (I.dxPixels + I.width) * m + (I.dyPixels + I.height) * v, v = Math.min(D, u, F, A), D = Math.max(D, u, F, A), u = Math.min(l, n, G, m), l = Math.max(l, n, G, m), I.dxPixels = v, I.dyPixels = u, I.width =
                                            D - v, I.height = l - u
                                }
                            }
                        }
                    };
                    p._addPlacedIcons = function(l, n, u, y, x, q) {
                        const B = Math.max(u - 1, 0),
                            z = this._iconVertexBuffer,
                            v = this._iconIndexBuffer,
                            A = this._markerMap;
                        for (const E of n) {
                            n = x ? 0 : Math.max(u + t.log2(E.minzoom), B);
                            const C = x ? 25 : Math.min(u + t.log2(E.maxzoom), 25);
                            if (C <= n) continue;
                            const G = E.tl,
                                F = E.tr,
                                D = E.bl,
                                H = E.br;
                            var m = E.mosaicRect;
                            const I = E.labelAngle,
                                Q = E.minAngle,
                                P = E.maxAngle,
                                Y = E.anchor,
                                W = z.index,
                                X = m.x,
                                ba = m.y,
                                V = X + m.width;
                            m = ba + m.height;
                            const ca = z.index;
                            z.add(Y.x, Y.y, G.x, G.y, X, ba, I, Q, P, n, C, q);
                            z.add(Y.x, Y.y,
                                F.x, F.y, V, ba, I, Q, P, n, C, q);
                            z.add(Y.x, Y.y, D.x, D.y, X, m, I, Q, P, n, C, q);
                            z.add(Y.x, Y.y, H.x, H.y, V, m, I, Q, P, n, C, q);
                            0 < l.iconVertexRanges.length && l.iconVertexRanges[0][0] + l.iconVertexRanges[0][1] === ca ? l.iconVertexRanges[0][1] += 4 : l.iconVertexRanges.push([ca, 4]);
                            v.add(W + 0, W + 1, W + 2);
                            v.add(W + 1, W + 2, W + 3);
                            A.has(y) ? A.get(y)[1] += 6 : A.set(y, [this._iconIndexStart + this._iconIndexCount, 6]);
                            this._iconIndexCount += 6
                        }
                    };
                    p._addPlacedGlyphs = function() {
                        const l = this._textVertexBuffer,
                            n = this._textIndexBuffer,
                            u = this._glyphMap;
                        for (const [y,
                                x
                            ] of this._glyphBufferDataStorage)
                            for (const q of x) {
                                const B = l.index,
                                    z = q.symbolInstance,
                                    v = q.ddAttributes,
                                    A = l.index;
                                l.add(q.glyphAnchor[0], q.glyphAnchor[1], q.tl[0], q.tl[1], q.xmin, q.ymin, q.labelAngle, q.minAngle, q.maxAngle, q.minLod, q.maxLod, v);
                                l.add(q.glyphAnchor[0], q.glyphAnchor[1], q.tr[0], q.tr[1], q.xmax, q.ymin, q.labelAngle, q.minAngle, q.maxAngle, q.minLod, q.maxLod, v);
                                l.add(q.glyphAnchor[0], q.glyphAnchor[1], q.bl[0], q.bl[1], q.xmin, q.ymax, q.labelAngle, q.minAngle, q.maxAngle, q.minLod, q.maxLod, v);
                                l.add(q.glyphAnchor[0],
                                    q.glyphAnchor[1], q.br[0], q.br[1], q.xmax, q.ymax, q.labelAngle, q.minAngle, q.maxAngle, q.minLod, q.maxLod, v);
                                0 < z.textVertexRanges.length && z.textVertexRanges[0][0] + z.textVertexRanges[0][1] === A ? z.textVertexRanges[0][1] += 4 : z.textVertexRanges.push([A, 4]);
                                n.add(B + 0, B + 1, B + 2);
                                n.add(B + 1, B + 2, B + 3);
                                u.has(y) ? u.get(y)[1] += 6 : u.set(y, [this._textIndexStart + this._textIndexCount, 6]);
                                this._textIndexCount += 6
                            }
                        this._glyphBufferDataStorage.clear()
                    };
                    p._storePlacedGlyphs = function(l, n, u, y, x) {
                        const q = Math.max(u - 1, 0);
                        y = 1 === y;
                        let B,
                            z, v, A, m, E, C, G, F, D;
                        for (const H of n) n = y ? 0 : Math.max(u + t.log2(H.minzoom), q), B = y ? 25 : Math.min(u + t.log2(H.maxzoom), 25), B <= n || (z = H.tl, v = H.tr, A = H.bl, m = H.br, E = H.labelAngle, C = H.minAngle, G = H.maxAngle, F = H.anchor, D = H.mosaicRect, this._glyphBufferDataStorage.has(H.page) || this._glyphBufferDataStorage.set(H.page, []), this._glyphBufferDataStorage.get(H.page).push({
                            glyphAnchor: [F.x, F.y],
                            tl: [z.x, z.y],
                            tr: [v.x, v.y],
                            bl: [A.x, A.y],
                            br: [m.x, m.y],
                            xmin: D.x,
                            ymin: D.y,
                            xmax: D.x + D.width,
                            ymax: D.y + D.height,
                            labelAngle: E,
                            minAngle: C,
                            maxAngle: G,
                            minLod: n,
                            maxLod: B,
                            placementLod: q,
                            symbolInstance: l,
                            ddAttributes: x
                        }))
                    };
                    h._pushAnchors = function(l, n, u, y) {
                        u += y;
                        var x = 0,
                            q = n.length - 1;
                        for (var B = 0; B < q; B++) x += f.Point.distance(n[B], n[B + 1]);
                        y = .5 * (y || u);
                        if (!(x <= y)) {
                            y /= x;
                            u = x / Math.max(Math.round(x / u), 1);
                            x = 0;
                            q = -u / 2;
                            B = n.length - 1;
                            for (let v = 0; v < B; v++) {
                                const A = n[v],
                                    m = n[v + 1],
                                    E = m.x - A.x,
                                    C = m.y - A.y,
                                    G = Math.sqrt(E * E + C * C);
                                let F;
                                for (; q + u < x + G;) {
                                    q += u;
                                    var z = (q - x) / G;
                                    const D = t.interpolate(A.x, m.x, z);
                                    z = t.interpolate(A.y, m.y, z);
                                    void 0 === F && (F = Math.atan2(C, E));
                                    l.push(new c.Anchor(D,
                                        z, F, v, y))
                                }
                                x += G
                            }
                        }
                    };
                    h._pushCenterAnchor = function(l, n) {
                        var u = 0,
                            y = n.length - 1;
                        for (var x = 0; x < y; x++) u += f.Point.distance(n[x], n[x + 1]);
                        var q = u / 2;
                        let B = 0;
                        const z = n.length - 1;
                        for (u = 0; u < z; u++) {
                            var v = n[u];
                            const A = n[u + 1];
                            y = A.x - v.x;
                            x = A.y - v.y;
                            const m = Math.sqrt(y * y + x * x);
                            if (q < B + m) {
                                q = (q - B) / m;
                                n = t.interpolate(v.x, A.x, q);
                                v = t.interpolate(v.y, A.y, q);
                                l.push(new c.Anchor(n, v, Math.atan2(x, y), u, 0));
                                break
                            }
                            B += m
                        }
                    };
                    h._deviation = function(l, n, u) {
                        return Math.atan2((n.x - l.x) * (u.y - n.y) - (n.y - l.y) * (u.x - n.x), (n.x - l.x) * (u.x - n.x) + (n.y - l.y) *
                            (u.y - n.y))
                    };
                    h._honorsTextMaxAngle = function(l, n, u, y, x) {
                        let q = 0;
                        u /= 2;
                        for (var B = new f.Point(n.x, n.y), z = n.segment + 1; q > -u;) {
                            --z;
                            if (0 > z) return !1;
                            q -= f.Point.distance(l[z], B);
                            B = l[z]
                        }
                        q += f.Point.distance(l[z], l[z + 1]);
                        n = [];
                        B = 0;
                        const v = l.length;
                        for (; q < u;) {
                            var A = l[z];
                            let m;
                            do {
                                ++z;
                                if (z === v) return !1;
                                m = l[z]
                            } while (m.isEqual(A));
                            let E = z,
                                C;
                            do {
                                ++E;
                                if (E === v) return !1;
                                C = l[E]
                            } while (C.isEqual(m));
                            A = this._deviation(A, m, C);
                            n.push({
                                deviation: A,
                                distToAnchor: q
                            });
                            for (B += A; q - n[0].distToAnchor > x;) B -= n.shift().deviation;
                            if (Math.abs(B) >
                                y) return !1;
                            q += f.Point.distance(m, C)
                        }
                        return !0
                    };
                    h._smoothVertices = function(l, n) {
                        if (0 >= n) return l;
                        let u = l.length;
                        if (3 > u) return l;
                        const y = [];
                        var x = 0,
                            q = 0;
                        y.push(0);
                        for (var B = 1; B < u; B++) {
                            var z = f.Point.distance(l[B], l[B - 1]);
                            0 < z && (x += z, y.push(x), q++, q !== B && (l[q] = l[B]))
                        }
                        u = q + 1;
                        if (3 > u) return l;
                        n = Math.min(n, .2 * x);
                        x = l[0].x;
                        q = l[0].y;
                        B = l[u - 1].x;
                        z = l[u - 1].y;
                        var v = f.Point.sub(l[0], l[1]);
                        v.normalize();
                        l[0].x += n * v.x;
                        l[0].y += n * v.y;
                        v.assignSub(l[u - 1], l[u - 2]);
                        v.normalize();
                        l[u - 1].x += n * v.x;
                        l[u - 1].y += n * v.y;
                        y[0] -= n;
                        y[u - 1] +=
                            n;
                        v = [];
                        v.push(new f.Point(x, q));
                        const A = .5 * n;
                        for (let Y = 1; Y < u - 1; Y++) {
                            let W = 0,
                                X = 0,
                                ba = 0;
                            for (var m = Y - 1; 0 <= m; m--) {
                                var E = A + y[m + 1] - y[Y];
                                if (0 > E) break;
                                var C = y[m + 1] - y[m],
                                    G = y[Y] - y[m] < A ? 1 : E / C;
                                if (1E-6 > G) break;
                                var F = G * G,
                                    D = G * E - .5 * F * C,
                                    H = G * C / n,
                                    I = l[m + 1],
                                    Q = l[m].x - I.x,
                                    P = l[m].y - I.y;
                                W += H / D * (I.x * G * E + .5 * F * (E * Q - C * I.x) - F * G * C * Q / 3);
                                X += H / D * (I.y * G * E + .5 * F * (E * P - C * I.y) - F * G * C * P / 3);
                                ba += H
                            }
                            for (m = Y + 1; m < u; m++) {
                                E = A - y[m - 1] + y[Y];
                                if (0 > E) break;
                                C = y[m] - y[m - 1];
                                G = y[m] - y[Y] < A ? 1 : E / C;
                                if (1E-6 > G) break;
                                F = G * G;
                                D = G * E - .5 * F * C;
                                H = G * C / n;
                                I = l[m - 1];
                                Q = l[m].x - I.x;
                                P = l[m].y - I.y;
                                W += H / D * (I.x * G * E + .5 * F * (E * Q - C * I.x) - F * G * C * Q / 3);
                                X += H / D * (I.y * G * E + .5 * F * (E * P - C * I.y) - F * G * C * P / 3);
                                ba += H
                            }
                            v.push(new f.Point(W / ba, X / ba))
                        }
                        v.push(new f.Point(B, z));
                        l[0].x = x;
                        l[0].y = q;
                        l[u - 1].x = B;
                        l[u - 1].y = z;
                        return v
                    };
                    h._pushCentroid = function(l, n) {
                        const u = n.length - 1;
                        let y = 0,
                            x = 0,
                            q = 0,
                            B = n[0].x,
                            z = n[0].y;
                        4096 < B && (B = 4096);
                        0 > B && (B = 0);
                        4096 < z && (z = 4096);
                        0 > z && (z = 0);
                        for (let v = 1; v < u; v++) {
                            let A = n[v].x,
                                m = n[v].y,
                                E = n[v + 1].x,
                                C = n[v + 1].y;
                            4096 < A && (A = 4096);
                            0 > A && (A = 0);
                            4096 < m && (m = 4096);
                            0 > m && (m = 0);
                            4096 < E && (E = 4096);
                            0 > E && (E = 0);
                            4096 < C && (C = 4096);
                            0 > C && (C = 0);
                            const G = (A - B) * (C - z) - (E - B) * (m - z);
                            y += G * (B + A + E);
                            x += G * (z + m + C);
                            q += G
                        }
                        y /= 3 * q;
                        x /= 3 * q;
                        isNaN(y) || isNaN(x) || l.push(new c.Anchor(y, x))
                    };
                    a._createClass(h, [{
                        key: "markerPageMap",
                        get: function() {
                            return this._markerMap
                        }
                    }, {
                        key: "glyphsPageMap",
                        get: function() {
                            return this._glyphMap
                        }
                    }, {
                        key: "symbolInstances",
                        get: function() {
                            return this._symbolInstances
                        }
                    }]);
                    return h
                }(g);
                g._bidiEngine = new w;
                return g
            })
        },
        "esri/core/BidiEngine": function() {
            define(["./bidiEngineTables"], function(a) {
                function k(v, A, m, E,
                    C) {
                    var G = v;
                    void 0 === A && (A = C.defInFormat);
                    void 0 === m && (m = C.defOutFormat);
                    void 0 === E && (E = C.defSwap);
                    if (A !== m) {
                        var F = A.substring(0, 1),
                            D = m.substring(0, 1);
                        var H = A.substring(1, 4);
                        var I = m.substring(1, 4);
                        "C" === H.charAt(0) && (H = w(G), H = "ltr" === H || "rtl" === H ? H.toUpperCase() : "L" === A.charAt(2) ? "LTR" : "RTL", A = F + H);
                        "C" === I.charAt(0) && (H = w(G), "rtl" === H ? I = "RTL" : "ltr" === H ? (G = G.split(""), G.reverse(), H = w(G.join("")), I = H.toUpperCase()) : I = "L" === m.charAt(2) ? "LTR" : "RTL", m = D + I)
                    }
                    if (A === m) return v;
                    D = A.substring(0, 1);
                    G = A.substring(1,
                        4);
                    F = m.substring(0, 1);
                    I = m.substring(1, 4);
                    C.inFormat = A;
                    C.outFormat = m;
                    C.swap = E;
                    if ("L" === D && "VLTR" === m) {
                        if ("LTR" === G) return C.dir = 0, t(v, C);
                        if ("RTL" === G) return C.dir = 1, t(v, C)
                    }
                    if ("V" === D && "V" === F) return C.dir = "RTL" === G ? 1 : 0, f(v, C);
                    if ("L" === D && "VRTL" === m) return C.dir = "LTR" === G ? 0 : 1, v = t(v, C), f(v);
                    if ("VLTR" === A && "LLTR" === m) return C.dir = 0, t(v, C);
                    if ("V" === D && "L" === F && G !== I) return v = f(v), "RTL" === G ? k(v, "LLTR", "VLTR", E, C) : k(v, "LRTL", "VRTL", E, C);
                    if ("VRTL" === A && "LRTL" === m) return k(v, "LRTL", "VRTL", E, C);
                    "L" === D && "L" ===
                        F && (A = C.swap, C.swap = A.substr(0, 1) + "N", "RTL" === G ? (C.dir = 1, v = t(v, C), C.swap = "N" + A.substr(1, 2), C.dir = 0, v = t(v, C)) : (C.dir = 0, v = t(v, C), C.swap = "N" + A.substr(1, 2), v = k(v, "VLTR", "LRTL", C.swap, C)));
                    return v
                }

                function w(v) {
                    return (v = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(v)) ? "z" >= v[0] ? "ltr" : "rtl" : ""
                }

                function t(v, A) {
                    v = v.split("");
                    const m = [];
                    r(v, m, A);
                    if (0 !== A.hiLevel && A.swap.substr(0, 1) !== A.swap.substr(1, 2))
                        for (let G = 0; G < v.length; G++)
                            if (1 === m[G]) {
                                var E = G;
                                b: {
                                    let F = void 0;
                                    var C =
                                        v[G];
                                    let D = 0,
                                        H = a.SwapTable.length - 1;
                                    for (; D <= H;)
                                        if (F = Math.floor((D + H) / 2), C < a.SwapTable[F][0]) H = F - 1;
                                        else if (C > a.SwapTable[F][0]) D = F + 1;
                                    else {
                                        C = a.SwapTable[F][1];
                                        break b
                                    }
                                }
                                v[E] = C
                            }
                    g(2, v, m, A);
                    g(1, v, m, A);
                    x = m;
                    return v.join("")
                }

                function r(v, A, m) {
                    const E = v.length;
                    var C = m.dir ? a.impTabRtl : a.impTabLtr,
                        G = 0,
                        F = -1;
                    const D = [],
                        H = [];
                    m.hiLevel = m.dir;
                    m.lastArabic = !1;
                    m.hasUbatAl = !1;
                    m.hasUbatB = !1;
                    m.hasUbatS = !1;
                    for (var I = 0; I < E; I++) {
                        var Q = I; {
                            var P = v[I].charCodeAt(0);
                            const Y = a.PrimaryTable[P >> 8];
                            P = Y < a.TBBASE ? Y : a.UnicodeTable[Y -
                                a.TBBASE][P & 255]
                        }
                        D[Q] = P
                    }
                    for (Q = 0; Q < E; Q++) {
                        I = e(v, D, H, Q, m);
                        H[Q] = I;
                        G = C[G][I];
                        P = G & 240;
                        G &= 15;
                        I = C[G][5];
                        A[Q] = I;
                        if (0 < P) {
                            if (16 === P)
                                for (; F < Q; F++) A[F] = 1;
                            F = -1
                        }
                        if (C[G][6]) - 1 === F && (F = Q);
                        else if (-1 < F) {
                            for (; F < Q; F++) A[F] = I;
                            F = -1
                        }
                        D[Q] === a.UBAT_B && (A[Q] = 0);
                        m.hiLevel |= I
                    }
                    if (m.hasUbatS)
                        for (v = 0; v < E; v++)
                            if (D[v] === a.UBAT_S)
                                for (A[v] = m.dir, C = v - 1; 0 <= C; C--)
                                    if (D[C] === a.UBAT_WS) A[C] = m.dir;
                                    else break
                }

                function f(v, A) {
                    v = v.split("");
                    if (A) {
                        const m = [];
                        r(v, m, A);
                        x = m
                    }
                    v.reverse();
                    u.reverse();
                    return v.join("")
                }

                function b(v) {
                    for (let A = 0; A <
                        a.ArabicAlefBetIntervalsBegine.length; A++)
                        if (v >= a.ArabicAlefBetIntervalsBegine[A] && v <= a.ArabicAlefBetIntervalsEnd[A]) return !0;
                    return !1
                }

                function c(v, A, m, E) {
                    for (; A * m < E && h(v[A]);) A += m;
                    return A * m < E && b(v[A]) ? !0 : !1
                }

                function g(v, A, m, E) {
                    if (!(E.hiLevel < v))
                        if (1 !== v || 1 !== E.dir || E.hasUbatB) {
                            E = A.length;
                            for (var C = 0, G, F, D; C < E;) {
                                if (m[C] >= v) {
                                    for (G = C + 1; G < E && m[G] >= v;) G++;
                                    for (F = G - 1; C < F; C++, F--) D = A[C], A[C] = A[F], A[F] = D, D = u[C], u[C] = u[F], u[F] = D;
                                    C = G
                                }
                                C++
                            }
                        } else A.reverse(), u.reverse()
                }

                function e(v, A, m, E, C) {
                    return {
                        UBAT_L: () => {
                            C.lastArabic = !1;
                            return a.UBAT_L
                        },
                        UBAT_R: () => {
                            C.lastArabic = !1;
                            return a.UBAT_R
                        },
                        UBAT_ON: () => a.UBAT_ON,
                        UBAT_AN: () => a.UBAT_AN,
                        UBAT_EN: () => C.lastArabic ? a.UBAT_AN : a.UBAT_EN,
                        UBAT_AL: () => {
                            C.lastArabic = !0;
                            C.hasUbatAl = !0;
                            return a.UBAT_R
                        },
                        UBAT_WS: () => a.UBAT_ON,
                        UBAT_CS: () => {
                            let G, F;
                            if (1 > E || E + 1 >= A.length || (G = m[E - 1]) !== a.UBAT_EN && G !== a.UBAT_AN || (F = A[E + 1]) !== a.UBAT_EN && F !== a.UBAT_AN) return a.UBAT_ON;
                            C.lastArabic && (F = a.UBAT_AN);
                            return F === G ? F : a.UBAT_ON
                        },
                        UBAT_ES: () => (0 < E ? m[E - 1] : a.UBAT_B) === a.UBAT_EN && E + 1 < A.length &&
                            A[E + 1] === a.UBAT_EN ? a.UBAT_EN : a.UBAT_ON,
                        UBAT_ET: () => {
                            if (0 < E && m[E - 1] === a.UBAT_EN) return a.UBAT_EN;
                            if (C.lastArabic) return a.UBAT_ON;
                            let G = E + 1;
                            const F = A.length;
                            for (; G < F && A[G] === a.UBAT_ET;) G++;
                            return G < F && A[G] === a.UBAT_EN ? a.UBAT_EN : a.UBAT_ON
                        },
                        UBAT_NSM: () => {
                            if ("VLTR" === C.inFormat) {
                                for (var G = A.length, F = E + 1; F < G && A[F] === a.UBAT_NSM;) F++;
                                if (F < G && (G = v[E].charCodeAt[0], F = A[F], (1425 <= G && 2303 >= G || 64286 === G) && (F === a.UBAT_R || F === a.UBAT_AL))) return a.UBAT_R
                            }
                            return 1 > E || A[E - 1] === a.UBAT_B ? a.UBAT_ON : m[E - 1]
                        },
                        UBAT_B: () => {
                            C.lastArabic = !0;
                            C.hasUbatB = !0;
                            return C.dir
                        },
                        UBAT_S: () => {
                            C.hasUbatS = !0;
                            return a.UBAT_ON
                        },
                        UBAT_LRE: () => {
                            C.lastArabic = !1;
                            return a.UBAT_ON
                        },
                        UBAT_RLE: () => {
                            C.lastArabic = !1;
                            return a.UBAT_ON
                        },
                        UBAT_LRO: () => {
                            C.lastArabic = !1;
                            return a.UBAT_ON
                        },
                        UBAT_RLO: () => {
                            C.lastArabic = !1;
                            return a.UBAT_ON
                        },
                        UBAT_PDF: () => {
                            C.lastArabic = !1;
                            return a.UBAT_ON
                        },
                        UBAT_BN: () => a.UBAT_ON
                    }[a.TYPES_NAMES[A[E]]]()
                }

                function d(v, A) {
                    for (let m = 0; m < a.BaseForm.length; m++)
                        if (v === a.BaseForm[m]) return A[m];
                    return v
                }

                function h(v) {
                    return "\u064b" <= v &&
                        "\u0655" >= v ? !0 : !1
                }

                function p(v) {
                    return "L" === v ? "LTR" : "R" === v ? "RTL" : "C" === v ? "CLR" : "D" === v ? "CRL" : ""
                }

                function l(v, A) {
                    for (let m = 0; m < a.AlefTable.length; m++)
                        if (v === a.AlefTable[m]) return A[m];
                    return v
                }

                function n(v, A, m, E) {
                    for (let C = 0; C < v.length; C++)
                        if (v[C] > A || !m && v[C] === A) v[C] += E
                }
                let u = [],
                    y = [],
                    x = [];
                const q = {
                        dir: 0,
                        defInFormat: "LLTR",
                        defoutFormat: "VLTR",
                        defSwap: "YN",
                        inFormat: "LLTR",
                        outFormat: "VLTR",
                        swap: "YN",
                        hiLevel: 0,
                        lastArabic: !1,
                        hasUbatAl: !1,
                        hasBlockSep: !1,
                        hasSegSep: !1,
                        defOutFormat: ""
                    },
                    B = /^[(I|V)][(L|R|C|D)][(Y|N)][(S|N)][N]$/,
                    z = /[\u0591-\u06ff\ufb1d-\ufefc]/;
                return function() {
                    function v() {
                        this.inputFormat = "ILYNN";
                        this.outputFormat = "VLNNN";
                        this.sourceToTarget = [];
                        this.targetToSource = [];
                        this.levels = []
                    }
                    var A = v.prototype;
                    A.bidiTransform = function(m, E, C) {
                        this.sourceToTarget = [];
                        this.targetToSource = [];
                        if (!m) return "";
                        var G = this.sourceToTarget,
                            F = this.targetToSource,
                            D = m.length;
                        u = [];
                        x = [];
                        for (var H = 0; H < D; H++) G[H] = H, F[H] = H, u[H] = H;
                        if (!this.checkParameters(E, C)) return m;
                        E = this.inputFormat;
                        C = this.outputFormat;
                        G = m;
                        D = p(E.charAt(1));
                        G = p(C.charAt(1));
                        H = "I" === E.charAt(0) ? "L" : E.charAt(0);
                        F = "I" === C.charAt(0) ? "L" : C.charAt(0);
                        D = H + D;
                        G = F + G;
                        F = E.charAt(2) + C.charAt(2);
                        q.defInFormat = D;
                        q.defOutFormat = G;
                        q.defSwap = F;
                        m = k(m, D, G, F, q);
                        G = !1;
                        if ("R" === C.charAt(1)) G = !0;
                        else if ("C" === C.charAt(1) || "D" === C.charAt(1)) G = "rtl" === this.checkContextual(m);
                        F = this.sourceToTarget = u;
                        D = Array(F.length);
                        for (H = 0; H < F.length; H++) D[F[H]] = H;
                        y = this.targetToSource = F = D;
                        if (E.charAt(3) === C.charAt(3)) G = m;
                        else if ("S" === C.charAt(3))
                            if (E = G, C = !0, 0 === m.length) G = "";
                            else {
                                void 0 === E && (E = !0);
                                void 0 ===
                                    C && (C = !0);
                                m = String(m);
                                m = m.split("");
                                D = 0;
                                G = 1;
                                F = m.length;
                                E || (D = m.length - 1, G = -1, F = 1);
                                var I = D;
                                D = C;
                                var Q = 0;
                                H = [];
                                for (var P = 0; I * G < F; I += G)
                                    if (b(m[I]) || h(m[I])) {
                                        var Y;
                                        if (Y = "\u0644" === m[I]) b: {
                                            for (var W = m, X = I + G, ba = G, V = F; X * ba < V && h(W[X]);) X += ba;Y = " ";
                                            if (X * ba < V)
                                                for (Y = W[X], W = 0; W < a.AlefTable.length; W++)
                                                    if (a.AlefTable[W] === Y) {
                                                        Y = !0;
                                                        break b
                                                    }
                                            Y = !1
                                        }
                                        if (Y) {
                                            m[I] = 0 === Q ? l(m[I + G], a.LamAlefInialTableFE) : l(m[I + G], a.LamAlefMedialTableFE);
                                            I += G;
                                            Q = m;
                                            Y = I;
                                            W = G;
                                            for (X = F; Y * W < X && h(Q[Y]);) Y += W;
                                            Y * W < X && (Q[Y] = " ");
                                            D && (H[P] = I, P++);
                                            Q = 0
                                        } else {
                                            Y =
                                                m[I];
                                            if (1 === Q) {
                                                W = I;
                                                if (c(m, I + G, G, F)) b: for (X = m[I], ba = 0; ba < a.BaseForm.length; ba++) {
                                                    if (X === a.BaseForm[ba]) {
                                                        X = a.MedialForm[ba];
                                                        break b
                                                    }
                                                } else X = d(m[I], a.FinalForm);
                                                m[W] = X
                                            } else !0 === c(m, I + G, G, F) ? m[I] = d(m[I], a.InitialForm) : m[I] = d(m[I], a.IsolatedForm);
                                            h(Y) || (Q = 1);
                                            b: {
                                                for (W = 0; W < a.StandAlonForm.length; W++)
                                                    if (a.StandAlonForm[W] === Y) {
                                                        Y = !0;
                                                        break b
                                                    }
                                                Y = !1
                                            }!0 === Y && (Q = 0)
                                        }
                                    } else Q = 0;
                                G = H;
                                F = "";
                                for (D = 0; D < m.length; D++) {
                                    if (H = C) {
                                        b: {
                                            for (H = 0; H < G.length; H++)
                                                if (G[H] === D) break b;H = -1
                                        }
                                        H = -1 < H
                                    }
                                    H ? (n(y, D, !E, -1), u.splice(D, 1)) : F += m[D]
                                }
                                G =
                                    F
                            }
                        else if (E = m, C = G, m = !0, 0 === E.length) G = "";
                        else
                            for (void 0 === m && (m = !0), void 0 === C && (C = !0), E = String(E), G = "", F = E.split(""), D = 0; D < E.length; D++) H = !1, "\ufe70" <= F[D] && "\ufeff" > F[D] ? (P = E.charCodeAt(D), "\ufef5" <= F[D] && "\ufefc" >= F[D] ? (C ? (0 < D && m && " " === F[D - 1] ? G = G.substring(0, G.length - 1) + "\u0644" : (G += "\u0644", H = !0), G += a.AlefTable[(P - 65269) / 2]) : (G += a.AlefTable[(P - 65269) / 2], G += "\u0644", D + 1 < E.length && m && " " === F[D + 1] ? D++ : H = !0), H && (n(y, D, !0, 1), u.splice(D, 0, u[D]))) : G += a.FETo06Table[P - 65136]) : G += F[D];
                        this.sourceToTarget =
                            u;
                        this.targetToSource = y;
                        this.levels = x;
                        return G
                    };
                    A._inputFormatSetter = function(m) {
                        if (!B.test(m)) throw Error("dojox/string/BidiEngine: the bidi layout string is wrong!");
                        this.inputFormat = m
                    };
                    A._outputFormatSetter = function(m) {
                        if (!B.test(m)) throw Error("dojox/string/BidiEngine: the bidi layout string is wrong!");
                        this.outputFormat = m
                    };
                    A.checkParameters = function(m, E) {
                        m ? this._inputFormatSetter(m) : m = this.inputFormat;
                        E ? this._outputFormatSetter(E) : E = this.outputFormat;
                        return m === E ? !1 : !0
                    };
                    A.checkContextual = function(m) {
                        m =
                            w(m);
                        if ("ltr" !== m && "rtl" !== m) {
                            try {
                                m = document.dir.toLowerCase()
                            } catch (E) {}
                            "ltr" !== m && "rtl" !== m && (m = "ltr")
                        }
                        return m
                    };
                    A.hasBidiChar = function(m) {
                        return z.test(m)
                    };
                    return v
                }()
            })
        },
        "esri/core/bidiEngineTables": function() {
            define(["exports"], function(a) {
                a.AlefTable = ["\u0622", "\u0623", "\u0625", "\u0627"];
                a.ArabicAlefBetIntervalsBegine = ["\u0621", "\u0641"];
                a.ArabicAlefBetIntervalsEnd = ["\u063a", "\u064a"];
                a.BaseForm = "\u0627\u0628\u062a\u062b\u062c\u062d\u062e\u062f\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u064a\u0625\u0623\u0622\u0629\u0649\u0644\u0645\u0646\u0647\u0648\u064a\u0625\u0623\u0622\u0629\u0649\u06cc\u0626\u0624".split("");
                a.FETo06Table = "\u064b\u064b\u064c\u061f\u064d\u061f\u064e\u064e\u064f\u064f\u0650\u0650\u0651\u0651\u0652\u0652\u0621\u0622\u0622\u0623\u0623\u0624\u0624\u0625\u0625\u0626\u0626\u0626\u0626\u0627\u0627\u0628\u0628\u0628\u0628\u0629\u0629\u062a\u062a\u062a\u062a\u062b\u062b\u062b\u062b\u062c\u062c\u062c\u062c\u062d\u062d\u062d\u062d\u062e\u062e\u062e\u062e\u062f\u062f\u0630\u0630\u0631\u0631\u0632\u0632\u0633\u0633\u0633\u0633\u0634\u0634\u0634\u0634\u0635\u0635\u0635\u0635\u0636\u0636\u0636\u0636\u0637\u0637\u0637\u0637\u0638\u0638\u0638\u0638\u0639\u0639\u0639\u0639\u063a\u063a\u063a\u063a\u0641\u0641\u0641\u0641\u0642\u0642\u0642\u0642\u0643\u0643\u0643\u0643\u0644\u0644\u0644\u0644\u0645\u0645\u0645\u0645\u0646\u0646\u0646\u0646\u0647\u0647\u0647\u0647\u0648\u0648\u0649\u0649\u064a\u064a\u064a\u064a\ufef5\ufef6\ufef7\ufef8\ufef9\ufefa\ufefb\ufefc\u061f\u061f\u061f".split("");
                a.FinalForm = "\ufe8e\ufe90\ufe96\ufe9a\ufe9e\ufea2\ufea6\ufeaa\ufeac\ufeae\ufeb0\ufeb2\ufeb6\ufeba\ufebe\ufec2\ufec6\ufeca\ufece\ufed2\ufed6\ufeda\ufede\ufee2\ufee6\ufeea\ufeee\ufef2\ufe88\ufe84\ufe82\ufe94\ufef0\ufbfd\ufe8a\ufe86\ufe70\ufe72\ufe74\ufe76\ufe78\ufe7a\ufe7c\ufe7e\ufe80\ufe8a\ufe86".split("");
                a.InitialForm = "\ufe8d\ufe91\ufe97\ufe9b\ufe9f\ufea3\ufea7\ufea9\ufeab\ufead\ufeaf\ufeb3\ufeb7\ufebb\ufebf\ufec3\ufec7\ufecb\ufecf\ufed3\ufed7\ufedb\ufedf\ufee3\ufee7\ufeeb\ufeed\ufef3\ufe87\ufe83\ufe81\ufe93\ufeef\ufbfe\ufe8b\ufe85\ufe70\ufe72\ufe74\ufe76\ufe78\ufe7a\ufe7c\ufe7e\ufe80\ufe8b\ufe85".split("");
                a.IsolatedForm = "\ufe8d\ufe8f\ufe95\ufe99\ufe9d\ufea1\ufea5\ufea9\ufeab\ufead\ufeaf\ufeb1\ufeb5\ufeb9\ufebd\ufec1\ufec5\ufec9\ufecd\ufed1\ufed5\ufed9\ufedd\ufee1\ufee5\ufee9\ufeed\ufef1\ufe87\ufe83\ufe81\ufe93\ufeef\ufbfc\ufe89\ufe85\ufe70\ufe72\ufe74\ufe76\ufe78\ufe7a\ufe7c\ufe7e\ufe80\ufe89\ufe85".split("");
                a.LamAlefInialTableFE = ["\ufef5", "\ufef7", "\ufef9", "\ufefb"];
                a.LamAlefMedialTableFE = ["\ufef6", "\ufef8", "\ufefa", "\ufefc"];
                a.MedialForm = "\ufe8e\ufe92\ufe98\ufe9c\ufea0\ufea4\ufea8\ufeaa\ufeac\ufeae\ufeb0\ufeb4\ufeb8\ufebc\ufec0\ufec4\ufec8\ufecc\ufed0\ufed4\ufed8\ufedc\ufee0\ufee4\ufee8\ufeec\ufeee\ufef4\ufe88\ufe84\ufe82\ufe94\ufef0\ufbff\ufe8c\ufe86\ufe71\ufe72\ufe74\ufe77\ufe79\ufe7b\ufe7d\ufe7f\ufe80\ufe8c\ufe86".split("");
                a.PrimaryTable = [100, 0, 0, 0, 0, 101, 102, 103, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 0, 0, 4, 4, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 105, 7, 7, 106, 107
                ];
                a.StandAlonForm = "\u0621\u0622\u0623\u0624\u0625\u0627\u0629\u062f\u0630\u0631\u0632\u0648\u0649".split("");
                a.SwapTable = [
                    ["(", ")"],
                    [")", "("],
                    ["\x3c", "\x3e"],
                    ["\x3e", "\x3c"],
                    ["[", "]"],
                    ["]", "["],
                    ["{", "}"],
                    ["}", "{"],
                    ["\u00ab", "\u00bb"],
                    ["\u00bb", "\u00ab"],
                    ["\u2039", "\u203a"],
                    ["\u203a", "\u2039"],
                    ["\u207d", "\u207e"],
                    ["\u207e", "\u207d"],
                    ["\u208d", "\u208e"],
                    ["\u208e", "\u208d"],
                    ["\u2264", "\u2265"],
                    ["\u2265", "\u2264"],
                    ["\u2329", "\u232a"],
                    ["\u232a", "\u2329"],
                    ["\ufe59",
                        "\ufe5a"
                    ],
                    ["\ufe5a", "\ufe59"],
                    ["\ufe5b", "\ufe5c"],
                    ["\ufe5c", "\ufe5b"],
                    ["\ufe5d", "\ufe5e"],
                    ["\ufe5e", "\ufe5d"],
                    ["\ufe64", "\ufe65"],
                    ["\ufe65", "\ufe64"]
                ];
                a.TBBASE = 100;
                a.TYPES_NAMES = "UBAT_L UBAT_R UBAT_EN UBAT_AN UBAT_ON UBAT_B UBAT_S UBAT_AL UBAT_WS UBAT_CS UBAT_ES UBAT_ET UBAT_NSM UBAT_LRE UBAT_RLE UBAT_PDF UBAT_LRO UBAT_RLO UBAT_BN".split(" ");
                a.UBAT_AL = 7;
                a.UBAT_AN = 3;
                a.UBAT_B = 5;
                a.UBAT_BN = 18;
                a.UBAT_CS = 9;
                a.UBAT_EN = 2;
                a.UBAT_ES = 10;
                a.UBAT_ET = 11;
                a.UBAT_L = 0;
                a.UBAT_LRE = 13;
                a.UBAT_LRO = 16;
                a.UBAT_NSM = 12;
                a.UBAT_ON =
                    4;
                a.UBAT_PDF = 15;
                a.UBAT_R = 1;
                a.UBAT_RLE = 14;
                a.UBAT_RLO = 17;
                a.UBAT_S = 6;
                a.UBAT_WS = 8;
                a.UnicodeTable = [
                    [18, 18, 18, 18, 18, 18, 18, 18, 18, 6, 5, 6, 8, 5, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 5, 5, 5, 6, 8, 4, 4, 11, 11, 11, 4, 4, 4, 4, 4, 10, 9, 10, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 18, 18, 18, 18, 18, 18, 5, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 9, 4, 11, 11, 11, 11, 4, 4, 4, 4, 0,
                        4, 4, 18, 4, 4, 11, 11, 2, 2, 4, 0, 4, 4, 4, 2, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0
                    ],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
                        12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 12, 1, 12, 12, 1, 12, 12, 1, 12, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
                    ],
                    [3, 3, 3, 3, 4, 4, 4, 4, 7, 11, 11, 7, 9, 7, 4, 4, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 7, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 11, 3, 3, 7, 7, 7, 12,
                        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12, 3, 4, 12, 12, 12, 12, 12, 12, 7, 7, 12, 12, 4, 12, 12, 12, 12, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 7, 7, 7, 7
                    ],
                    [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 7, 7, 12, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 4, 7, 7, 7, 7, 7, 7,
                        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1, 1, 4, 4, 4, 4, 1, 4, 4, 4, 4, 4
                    ],
                    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 18, 18, 18, 0, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 5, 13, 14, 15, 16, 17, 9, 11, 11, 11, 11, 11, 4, 4, 4, 4, 4, 4, 4,
                        4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 18, 18, 18, 18, 18, 4, 4, 4, 4, 4, 18, 18, 18, 18, 18, 18, 2, 0, 4, 4, 2, 2, 2, 2, 2, 2, 10, 10, 4, 4, 4, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 10, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
                    ],
                    [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                        4, 4, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 4, 1, 4, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
                    ],
                    [12, 12, 12, 12, 12, 12, 12,
                        12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 9, 4, 4, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 11, 4, 4, 10, 10, 4, 4, 4, 4, 4, 11, 11, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                        7, 7, 7, 7, 7, 7, 4, 4, 18
                    ],
                    [4, 4, 4, 11, 11, 11, 4, 4, 4, 4, 4, 10, 9, 10, 9, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 9, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 4, 4, 4, 11, 11, 4, 4, 4, 11, 11, 4, 4, 4, 4, 4,
                        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
                    ]
                ];
                a.impTabLtr = [
                    [0, 3, 0, 1, 0, 0, 0],
                    [0, 3, 0, 1, 2, 2, 0],
                    [0, 3, 0, 17, 2, 0, 1],
                    [0, 3, 5, 5, 4, 1, 0],
                    [0, 3, 21, 21, 4, 0, 1],
                    [0, 3, 5, 5, 4, 2, 0]
                ];
                a.impTabRtl = [
                    [2, 0, 1, 1, 0, 1, 0],
                    [2, 0, 1, 1, 0, 2, 0],
                    [2, 0, 2, 1, 3, 2, 0],
                    [2, 0, 2, 33, 3, 1, 1]
                ];
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry": function() {
            define("exports ./core/accessorSupport/ensureType ./geometry/SpatialReference ./geometry/Geometry ./geometry/Point ./geometry/Extent ./geometry/Multipoint ./geometry/Polygon ./geometry/Polyline ./geometry/support/typeUtils ./geometry/support/jsonUtils".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d) {
                    const h = {
                        base: t,
                        key: "type",
                        typeMap: {
                            extent: f,
                            multipoint: b,
                            point: r,
                            polyline: g,
                            polygon: c
                        }
                    };
                    k = k.ensureOneOfType(h);
                    a.SpatialReference = w;
                    a.BaseGeometry = t;
                    a.Point = r;
                    a.Extent = f;
                    a.Multipoint = b;
                    a.Polygon = c;
                    a.Polyline = g;
                    a.featureGeometryTypeKebabDictionary = e.featureGeometryTypeKebabDictionary;
                    a.isFeatureGeometryType = e.isFeatureGeometryType;
                    a.typeKebabDictionary = e.typeKebabDictionary;
                    a.fromJSON = d.fromJSON;
                    a.ensureType = k;
                    a.geometryTypes = h;
                    a.isGeometry = function(p) {
                        return p instanceof
                        t
                    };
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/geometry/SpatialReference": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/JSONSupport ./support/spatialReferenceUtils".split(" "), function(a, k, w, t, r, f, b, c, g) {
                var e;
                c = e = function(d) {
                    function h(l) {
                        l = d.call(this, l) || this;
                        l.latestWkid =
                            null;
                        l.wkid = null;
                        l.wkt = null;
                        l.vcsWkid = null;
                        l.latestVcsWkid = null;
                        l.imageCoordinateSystem = null;
                        return l
                    }
                    a._inheritsLoose(h, d);
                    h.fromJSON = function(l) {
                        if (!l) return null;
                        if (l.wkid) {
                            if (102100 === l.wkid) return e.WebMercator;
                            if (4326 === l.wkid) return e.WGS84
                        }
                        const n = new e;
                        n.read(l);
                        return n
                    };
                    var p = h.prototype;
                    p.normalizeCtorArgs = function(l) {
                        return l && "object" === typeof l ? l : {
                            ["string" === typeof l ? "wkt" : "wkid"]: l
                        }
                    };
                    p.writeWkt = function(l, n) {
                        this.wkid || (n.wkt = l)
                    };
                    p.clone = function() {
                        if (this === e.WGS84) return e.WGS84;
                        if (this === e.WebMercator) return e.WebMercator;
                        const l = new e;
                        null != this.wkid ? (l.wkid = this.wkid, null != this.latestWkid && (l.latestWkid = this.latestWkid), null != this.vcsWkid && (l.vcsWkid = this.vcsWkid), null != this.latestVcsWkid && (l.latestVcsWkid = this.latestVcsWkid)) : null != this.wkt && (l.wkt = this.wkt);
                        this.imageCoordinateSystem && (l.imageCoordinateSystem = w.clone(this.imageCoordinateSystem));
                        return l
                    };
                    p.equals = function(l) {
                        if (null == l) return !1;
                        if (this.imageCoordinateSystem || l.imageCoordinateSystem) {
                            if (null == this.imageCoordinateSystem ||
                                null == l.imageCoordinateSystem) return !1;
                            const {
                                id: n,
                                referenceServiceName: u
                            } = l.imageCoordinateSystem, {
                                geodataXform: y
                            } = l.imageCoordinateSystem, x = this.imageCoordinateSystem;
                            return null == n || y ? JSON.stringify(x) === JSON.stringify(l.imageCoordinateSystem) : u ? x.id === n && x.referenceServiceName === u : x.id === n
                        }
                        return g.equals(this, l)
                    };
                    p.toJSON = function(l) {
                        return this.write(void 0, l)
                    };
                    a._createClass(h, [{
                            key: "isWGS84",
                            get: function() {
                                return g.isWGS84(this)
                            }
                        }, {
                            key: "isWebMercator",
                            get: function() {
                                return g.isWebMercator(this)
                            }
                        },
                        {
                            key: "isGeographic",
                            get: function() {
                                return g.isGeographic(this)
                            }
                        }, {
                            key: "isWrappable",
                            get: function() {
                                return g.isWrappable(this)
                            }
                        }
                    ]);
                    return h
                }(c.JSONSupport);
                c.GCS_NAD_1927 = null;
                c.WGS84 = null;
                c.WebMercator = null;
                k.__decorate([r.property({
                    readOnly: !0
                })], c.prototype, "isWGS84", null);
                k.__decorate([r.property({
                    readOnly: !0
                })], c.prototype, "isWebMercator", null);
                k.__decorate([r.property({
                    readOnly: !0
                })], c.prototype, "isGeographic", null);
                k.__decorate([r.property({
                    readOnly: !0
                })], c.prototype, "isWrappable", null);
                k.__decorate([r.property({
                    type: t.Integer,
                    json: {
                        write: !0
                    }
                })], c.prototype, "latestWkid", void 0);
                k.__decorate([r.property({
                    type: t.Integer,
                    json: {
                        write: !0,
                        origins: {
                            "web-scene": {
                                write: {
                                    overridePolicy() {
                                        return {
                                            isRequired: null === this.wkt ? !0 : !1
                                        }
                                    }
                                }
                            }
                        }
                    }
                })], c.prototype, "wkid", void 0);
                k.__decorate([r.property({
                    type: String,
                    json: {
                        origins: {
                            "web-scene": {
                                write: {
                                    overridePolicy() {
                                        return {
                                            isRequired: null === this.wkid ? !0 : !1
                                        }
                                    }
                                }
                            }
                        }
                    }
                })], c.prototype, "wkt", void 0);
                k.__decorate([b.writer("wkt"), b.writer("web-scene", "wkt")], c.prototype, "writeWkt", null);
                k.__decorate([r.property({
                    type: t.Integer,
                    json: {
                        write: !0
                    }
                })], c.prototype, "vcsWkid", void 0);
                k.__decorate([r.property({
                    type: t.Integer,
                    json: {
                        write: !0
                    }
                })], c.prototype, "latestVcsWkid", void 0);
                k.__decorate([r.property()], c.prototype, "imageCoordinateSystem", void 0);
                c = e = k.__decorate([f.subclass("esri.geometry.SpatialReference")], c);
                c.prototype.toJSON.isDefaultToJSON = !0;
                c.GCS_NAD_1927 = new c({
                    wkid: 4267,
                    wkt: 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]'
                });
                c.WGS84 = new c(g.WGS84);
                c.WebMercator = new c(g.WebMercator);
                Object.freeze && (Object.freeze(c.GCS_NAD_1927), Object.freeze(c.WGS84), Object.freeze(c.WebMercator));
                return c
            })
        },
        "esri/core/accessorSupport/decorators/writer": function() {
            define(["exports", "../../object", "./property"], function(a, k, w) {
                a.writer = function(t, r, f) {
                    let b, c;
                    void 0 === r ? (c = t, b = [void 0]) : "string" !== typeof r ? (c = t, b = [void 0], f = r) : (c = r, b = Array.isArray(t) ? t : [t]);
                    return (g, e) => {
                        const d = g.constructor.prototype;
                        b.forEach(h => {
                            h = w.propertyJSONMeta(g,
                                h, c);
                            h.write && "object" !== typeof h.write && (h.write = {});
                            f && k.setDeepValue("write.target", f, h);
                            k.setDeepValue("write.writer", d[e], h)
                        })
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/JSONSupport": function() {
            define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./accessorSupport/decorators/subclass ./Accessor ./accessorSupport/read ./accessorSupport/write".split(" "), function(a, k, w, t, r, f, b) {
                const c = g => {
                    g = function(e) {
                        function d(...p) {
                            return e.call(this, ...p) || this
                        }
                        k._inheritsLoose(d,
                            e);
                        var h = d.prototype;
                        h.read = function(p, l) {
                            f.read(this, p, l)
                        };
                        h.write = function(p = {}, l) {
                            return b.write(this, p, l)
                        };
                        h.toJSON = function(p) {
                            return this.write({}, p)
                        };
                        d.fromJSON = function(p, l) {
                            if (p) {
                                if (p.declaredClass) throw Error("JSON object is already hydrated");
                                var n = new this;
                                n.read(p, l);
                                p = n
                            } else p = null;
                            return p
                        };
                        return d
                    }(g);
                    g = w.__decorate([t.subclass("esri.core.JSONSupport")], g);
                    g.prototype.toJSON.isDefaultToJSON = !0;
                    return g
                };
                a.JSONSupport = function(g) {
                    function e() {
                        return g.apply(this, arguments) || this
                    }
                    k._inheritsLoose(e,
                        g);
                    return e
                }(c(r));
                a.JSONSupport = w.__decorate([t.subclass("esri.core.JSONSupport")], a.JSONSupport);
                a.JSONSupportMixin = c;
                a.isJSONSupport = function(g) {
                    return g && "read" in g && "write" in g && "toJSON" in g
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/read": function() {
            define(["exports", "./utils", "./get", "./extensions/serializableProperty"], function(a, k, w, t) {
                function r(b, c, g = f) {
                    if (c && "object" === typeof c) {
                        var e = k.getProperties(b),
                            d = e.metadatas,
                            h = {};
                        for (const v of Object.getOwnPropertyNames(c)) {
                            var p =
                                h,
                                l = d,
                                n = v,
                                u = c,
                                y = g,
                                x = t.originSpecificReadPropertyDefinition(l[n], y);
                            x && (!x.read || !1 !== x.read.enabled && !x.read.source) && (p[n] = !0);
                            for (const A of Object.getOwnPropertyNames(l)) {
                                x = t.originSpecificReadPropertyDefinition(l[A], y);
                                a: {
                                    var q = n;
                                    var B = u;
                                    if (x && x.read && !1 !== x.read.enabled && x.read.source) {
                                        x = x.read.source;
                                        if ("string" === typeof x) {
                                            if (x === q || -1 < x.indexOf(".") && 0 === x.indexOf(q) && w.exists(x, B)) {
                                                q = !0;
                                                break a
                                            }
                                        } else
                                            for (const m of x)
                                                if (m === q || -1 < m.indexOf(".") && 0 === m.indexOf(q) && w.exists(m, B)) {
                                                    q = !0;
                                                    break a
                                                }
                                        q = !1
                                    } else q = !1
                                }
                                q && (p[A] = !0)
                            }
                        }
                        e.setDefaultOrigin(g.origin);
                        for (var z of Object.getOwnPropertyNames(h)) l = (l = (p = t.originSpecificReadPropertyDefinition(d[z], g).read) && p.source) && "string" === typeof l ? w.valueOf(c, l) : c[z], p && p.reader && (l = p.reader.call(b, l, c, g)), void 0 !== l && e.set(z, l);
                        if (!g || !g.ignoreDefaults)
                            for (const v of Object.getOwnPropertyNames(d)) h[v] || (z = b, c = v, d = e, p = g, l = (l = t.originSpecificPropertyDefinition(d.metadatas[c], "any", p)) && l.default, void 0 !== l && (z = "function" === typeof l ? l.call(z, c, p) : l, void 0 !==
                                z && d.set(c, z)));
                        e.setDefaultOrigin("user")
                    }
                }
                const f = {
                    origin: "service"
                };
                a.default = r;
                a.read = r;
                a.readLoadable = function(b, c, g, e = f) {
                    var d;
                    c = { ...e,
                        messages: []
                    };
                    g(c);
                    null == (d = c.messages) ? void 0 : d.forEach(h => {
                        "warning" !== h.type || b.loaded ? e && e.messages && e.messages.push(h) : b.loadWarnings.push(h)
                    })
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/core/accessorSupport/write": function() {
            define("exports ../Logger ./utils ./extensions/serializableProperty ../Error ./PropertyOrigin ../arrayUtils".split(" "),
                function(a, k, w, t, r, f, b) {
                    function c(h, p, l, n, u) {
                        var y, x;
                        const q = {};
                        null == (y = p.write) ? void 0 : null == (x = y.writer) ? void 0 : x.call(h, n, q, l, u);
                        return q
                    }

                    function g(h, p, l, n, u, y) {
                        if (!n || !n.write) return !1;
                        var x = h.get(l);
                        if (!u && n.write.overridePolicy) {
                            var q = n.write.overridePolicy.call(h, x, l, y);
                            void 0 !== q && (u = q)
                        }
                        u || (u = n.write);
                        if (!u || !1 === u.enabled) return !1;
                        if ((null === x && !u.allowNull || void 0 === x) && u.isRequired) return (p = new r("web-document-write:property-required", `Missing value for required property '${l}' on '${h.declaredClass}'`, {
                            propertyName: l,
                            target: h
                        }), y) && y.messages ? y.messages.push(p) : p && !y && d.error(p.name, p.message), !1;
                        if (void 0 === x || null === x && !u.allowNull) return !1;
                        q = n.default;
                        void 0 === q ? x = !1 : null != n.defaultEquals ? x = n.defaultEquals(x) : "function" === typeof q ? Array.isArray(x) ? (h = q.call(h, l, y), x = b.equals(h, x)) : x = !1 : x = q === x;
                        return x ? !1 : void 0 !== n.default ? !0 : !u.ignoreOrigin && y && y.origin && p.store.originOf(l) < f.nameToId(y.origin) ? !1 : !0
                    }

                    function e(h, p, l) {
                        if (h && "function" === typeof h.toJSON && (!h.toJSON.isDefaultToJSON || !h.write)) return w.merge(p,
                            h.toJSON());
                        const n = w.getProperties(h),
                            u = n.metadatas;
                        for (const q in u) {
                            const B = t.originSpecificWritePropertyDefinition(u[q], l);
                            if (!g(h, n, q, B, void 0, l)) continue;
                            const z = h.get(q),
                                v = c(h, B, B.write && "string" === typeof B.write.target ? B.write.target : q, z, l);
                            if (0 < Object.keys(v).length) {
                                var y, x;
                                p = w.merge(p, v);
                                null != l && null != (y = l.resources) && null != (x = y.pendingOperations) && x.length && Promise.all(l.resources.pendingOperations).then(() => w.merge(p, v));
                                l && l.writtenProperties && l.writtenProperties.push({
                                    target: h,
                                    propName: q,
                                    oldOrigin: f.idToReadableName(n.store.originOf(q)),
                                    newOrigin: l.origin
                                })
                            }
                        }
                        return p
                    }
                    const d = k.getLogger("esri.core.accessorSupport.write");
                    a.default = e;
                    a.willPropertyWrite = function(h, p, l, n) {
                        const u = w.getProperties(h),
                            y = t.originSpecificWritePropertyDefinition(u.metadatas[p], n);
                        return y ? g(h, u, p, y, l, n) : !1
                    };
                    a.write = e;
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/geometry/support/spatialReferenceUtils": function() {
            define(["exports", "../../core/maybe", "../../core/string", "./WKIDUnitConversion"],
                function(a, k, w, t) {
                    function r(n) {
                        return g(n) && null != n.wkid && !0 === e[n.wkid]
                    }

                    function f(n) {
                        return 104971 === n || 104905 === n
                    }

                    function b(n) {
                        return g(n) && null != n.wkid && f(n.wkid)
                    }

                    function c(n) {
                        return g(n) && null != n.wkid && 104903 === n.wkid
                    }

                    function g(n) {
                        return k.isSome(n) && (null != n.wkid && 2E3 <= n.wkid || null != n.wkt)
                    }
                    const e = {
                            102113: !0,
                            102100: !0,
                            3857: !0,
                            3785: !0
                        },
                        d = {
                            102113: !0,
                            102100: !0,
                            3857: !0,
                            3785: !0,
                            4326: !0
                        },
                        h = [-2.0037508342788905E7, 2.0037508342788905E7],
                        p = [-2.0037508342787E7, 2.0037508342787E7],
                        l = {
                            102113: {
                                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]',
                                valid: h,
                                origin: p,
                                dx: 1E-5
                            },
                            102100: {
                                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]',
                                valid: h,
                                origin: p,
                                dx: 1E-5
                            },
                            3785: {
                                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]',
                                valid: h,
                                origin: p,
                                dx: 1E-5
                            },
                            3857: {
                                wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]',
                                valid: h,
                                origin: p,
                                dx: 1E-5
                            },
                            4326: {
                                wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",{Central_Meridian}],UNIT["Degree",0.0174532925199433]]',
                                altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],UNIT["Degrees",111319.491]]',
                                valid: [-180, 180],
                                origin: [-180, 90],
                                dx: 1E-5
                            },
                            104971: {
                                wkTemplate: 'GEOGCS["Mars_2000_(Sphere)",DATUM["Mars_2000_(Sphere)",SPHEROID["Mars_2000_(Sphere)",3396190.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]',
                                valid: [-180, 180],
                                origin: [-180, 90],
                                dx: 1E-5
                            },
                            104905: {
                                wkTemplate: 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]',
                                valid: [-180, 180],
                                origin: [-180, 90],
                                dx: 1E-5
                            }
                        };
                    w = {
                        wkid: 4326,
                        wkt: w.replace(l[4326].wkTemplate, {
                            Central_Meridian: "0.0"
                        })
                    };
                    a.WGS84 = w;
                    a.WebMercator = {
                        wkid: 102100,
                        latestWkid: 3857
                    };
                    a.equals = function(n, u) {
                        return k.isNone(n) || k.isNone(u) ? !1 : n === u ? !0 : null != n.wkid || null != u.wkid ? n.wkid === u.wkid || r(n) && r(u) || null != u.latestWkid && n.wkid === u.latestWkid || null != n.latestWkid && u.wkid === n.latestWkid : n.wkt && u.wkt ? n.wkt.toUpperCase() === u.wkt.toUpperCase() : !1
                    };
                    a.getInfo = function(n) {
                        return g(n) && n.wkid ? l[n.wkid] : null
                    };
                    a.isCGCS2000 = function(n) {
                        return g(n) && 4490 ===
                            n.wkid
                    };
                    a.isEarth = function(n) {
                        return !(b(n) || c(n))
                    };
                    a.isGeographic = function(n) {
                        return g(n) ? n.wkid ? null == t[n.wkid] : n.wkt ? !!/^\s*GEOGCS/i.test(n.wkt) : !1 : !1
                    };
                    a.isMars = b;
                    a.isMoon = c;
                    a.isValid = g;
                    a.isWGS84 = function(n) {
                        return g(n) && 4326 === n.wkid
                    };
                    a.isWKIDFromMars = f;
                    a.isWKIDFromMoon = function(n) {
                        return 104903 === n
                    };
                    a.isWebMercator = r;
                    a.isWrappable = function(n) {
                        return g(n) && null != n.wkid && !0 === d[n.wkid]
                    };
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/geometry/support/WKIDUnitConversion": function() {
            define(function() {
                let a;
                const k = {
                    values: [1, .3048, .3048006096012192, .3047972654, .9143917962, .201166195164, .9143984146160287, .3047994715386762, 20.11676512155263, 20.11678249437587, .9143985307444408, .91439523, .3047997101815088, 20.116756, 5E4, 15E4],
                    units: "Meter Foot Foot_US Foot_Clarke Yard_Clarke Link_Clarke Yard_Sears Foot_Sears Chain_Sears Chain_Benoit_1895_B Yard_Indian Yard_Indian_1937 Foot_Gold_Coast Chain_Sears_1922_Truncated 50_Kilometers 150_Kilometers".split(" "),
                    2066: 5,
                    2136: 12,
                    2155: 2,
                    2157: 0,
                    2158: 0,
                    2159: 12,
                    2160: 12,
                    2204: 2,
                    2219: 0,
                    2220: 0,
                    2254: 2,
                    2255: 2,
                    2256: 1,
                    2265: 1,
                    2266: 1,
                    2267: 2,
                    2268: 2,
                    2269: 1,
                    2270: 1,
                    2271: 2,
                    2272: 2,
                    2273: 1,
                    2294: 0,
                    2295: 0,
                    2314: 3,
                    2899: 2,
                    2900: 2,
                    2901: 1,
                    2909: 1,
                    2910: 1,
                    2911: 2,
                    2912: 2,
                    2913: 1,
                    2914: 1,
                    2992: 1,
                    2993: 0,
                    2994: 1,
                    3080: 1,
                    3089: 2,
                    3090: 0,
                    3091: 2,
                    3102: 2,
                    3141: 0,
                    3142: 0,
                    3167: 13,
                    3359: 2,
                    3360: 0,
                    3361: 1,
                    3362: 0,
                    3363: 2,
                    3364: 0,
                    3365: 2,
                    3366: 3,
                    3404: 2,
                    3405: 0,
                    3406: 0,
                    3407: 3,
                    3439: 0,
                    3440: 0,
                    3479: 1,
                    3480: 0,
                    3481: 1,
                    3482: 0,
                    3483: 1,
                    3484: 0,
                    3485: 2,
                    3486: 0,
                    3487: 2,
                    3488: 0,
                    3489: 0,
                    3490: 2,
                    3491: 0,
                    3492: 2,
                    3493: 0,
                    3494: 2,
                    3495: 0,
                    3496: 2,
                    3497: 0,
                    3498: 2,
                    3499: 0,
                    3500: 2,
                    3501: 0,
                    3502: 2,
                    3503: 0,
                    3504: 2,
                    3505: 0,
                    3506: 2,
                    3507: 0,
                    3508: 2,
                    3509: 0,
                    3510: 2,
                    3511: 0,
                    3512: 2,
                    3513: 0,
                    3514: 0,
                    3515: 2,
                    3516: 0,
                    3517: 2,
                    3518: 0,
                    3519: 2,
                    3520: 0,
                    3521: 2,
                    3522: 0,
                    3523: 2,
                    3524: 0,
                    3525: 2,
                    3526: 0,
                    3527: 2,
                    3528: 0,
                    3529: 2,
                    3530: 0,
                    3531: 2,
                    3532: 0,
                    3533: 2,
                    3534: 0,
                    3535: 2,
                    3536: 0,
                    3537: 2,
                    3538: 0,
                    3539: 2,
                    3540: 0,
                    3541: 2,
                    3542: 0,
                    3543: 2,
                    3544: 0,
                    3545: 2,
                    3546: 0,
                    3547: 2,
                    3548: 0,
                    3549: 2,
                    3550: 0,
                    3551: 2,
                    3552: 0,
                    3553: 2,
                    3582: 2,
                    3583: 0,
                    3584: 2,
                    3585: 0,
                    3586: 2,
                    3587: 0,
                    3588: 1,
                    3589: 0,
                    3590: 1,
                    3591: 0,
                    3592: 0,
                    3593: 1,
                    3598: 2,
                    3599: 0,
                    3600: 2,
                    3605: 1,
                    3606: 0,
                    3607: 0,
                    3608: 2,
                    3609: 0,
                    3610: 2,
                    3611: 0,
                    3612: 2,
                    3613: 0,
                    3614: 2,
                    3615: 0,
                    3616: 2,
                    3617: 0,
                    3618: 2,
                    3619: 0,
                    3620: 2,
                    3621: 0,
                    3622: 2,
                    3623: 0,
                    3624: 2,
                    3625: 0,
                    3626: 2,
                    3627: 0,
                    3628: 2,
                    3629: 0,
                    3630: 2,
                    3631: 0,
                    3632: 2,
                    3633: 0,
                    3634: 1,
                    3635: 0,
                    3636: 1,
                    3640: 2,
                    3641: 0,
                    3642: 2,
                    3643: 0,
                    3644: 1,
                    3645: 0,
                    3646: 1,
                    3647: 0,
                    3648: 1,
                    3649: 0,
                    3650: 2,
                    3651: 0,
                    3652: 2,
                    3653: 0,
                    3654: 2,
                    3655: 0,
                    3656: 1,
                    3657: 0,
                    3658: 2,
                    3659: 0,
                    3660: 2,
                    3661: 0,
                    3662: 2,
                    3663: 0,
                    3664: 2,
                    3668: 2,
                    3669: 0,
                    3670: 2,
                    3671: 0,
                    3672: 2,
                    3673: 0,
                    3674: 2,
                    3675: 0,
                    3676: 1,
                    3677: 2,
                    3678: 0,
                    3679: 1,
                    3680: 2,
                    3681: 0,
                    3682: 1,
                    3683: 2,
                    3684: 0,
                    3685: 0,
                    3686: 2,
                    3687: 0,
                    3688: 2,
                    3689: 0,
                    3690: 2,
                    3691: 0,
                    3692: 2,
                    3696: 2,
                    3697: 0,
                    3698: 2,
                    3699: 0,
                    3700: 2,
                    3793: 0,
                    3794: 0,
                    3812: 0,
                    3854: 0,
                    3857: 0,
                    3920: 0,
                    3978: 0,
                    3979: 0,
                    3991: 2,
                    3992: 2,
                    4026: 0,
                    4037: 0,
                    4038: 0,
                    4071: 0,
                    4082: 0,
                    4083: 0,
                    4087: 0,
                    4088: 0,
                    4217: 2,
                    4414: 0,
                    4415: 0,
                    4417: 0,
                    4434: 0,
                    4437: 0,
                    4438: 2,
                    4439: 2,
                    4462: 0,
                    4467: 0,
                    4471: 0,
                    4474: 0,
                    4559: 0,
                    4647: 0,
                    4822: 0,
                    4826: 0,
                    4839: 0,
                    5018: 0,
                    5048: 0,
                    5167: 0,
                    5168: 0,
                    5221: 0,
                    5223: 0,
                    5234: 0,
                    5235: 0,
                    5243: 0,
                    5247: 0,
                    5266: 0,
                    5316: 0,
                    5320: 0,
                    5321: 0,
                    5325: 0,
                    5337: 0,
                    5361: 0,
                    5362: 0,
                    5367: 0,
                    5382: 0,
                    5383: 0,
                    5396: 0,
                    5456: 0,
                    5457: 0,
                    5469: 0,
                    5472: 4,
                    5490: 0,
                    5513: 0,
                    5514: 0,
                    5523: 0,
                    5559: 0,
                    5588: 1,
                    5589: 3,
                    5596: 0,
                    5627: 0,
                    5629: 0,
                    5641: 0,
                    5643: 0,
                    5644: 0,
                    5646: 2,
                    5654: 2,
                    5655: 2,
                    5659: 0,
                    5700: 0,
                    5825: 0,
                    5836: 0,
                    5837: 0,
                    5839: 0,
                    5842: 0,
                    5844: 0,
                    5858: 0,
                    5879: 0,
                    5880: 0,
                    5887: 0,
                    5890: 0,
                    6128: 1,
                    6129: 1,
                    6141: 1,
                    6204: 0,
                    6210: 0,
                    6211: 0,
                    6307: 0,
                    6312: 0,
                    6316: 0,
                    6362: 0,
                    6391: 1,
                    6405: 1,
                    6406: 0,
                    6407: 1,
                    6408: 0,
                    6409: 1,
                    6410: 0,
                    6411: 2,
                    6412: 0,
                    6413: 2,
                    6414: 0,
                    6415: 0,
                    6416: 2,
                    6417: 0,
                    6418: 2,
                    6419: 0,
                    6420: 2,
                    6421: 0,
                    6422: 2,
                    6423: 0,
                    6424: 2,
                    6425: 0,
                    6426: 2,
                    6427: 0,
                    6428: 2,
                    6429: 0,
                    6430: 2,
                    6431: 0,
                    6432: 2,
                    6433: 0,
                    6434: 2,
                    6435: 0,
                    6436: 2,
                    6437: 0,
                    6438: 2,
                    6439: 0,
                    6440: 0,
                    6441: 2,
                    6442: 0,
                    6443: 2,
                    6444: 0,
                    6445: 2,
                    6446: 0,
                    6447: 2,
                    6448: 0,
                    6449: 2,
                    6450: 0,
                    6451: 2,
                    6452: 0,
                    6453: 2,
                    6454: 0,
                    6455: 2,
                    6456: 0,
                    6457: 2,
                    6458: 0,
                    6459: 2,
                    6460: 0,
                    6461: 2,
                    6462: 0,
                    6463: 2,
                    6464: 0,
                    6465: 2,
                    6466: 0,
                    6467: 2,
                    6468: 0,
                    6469: 2,
                    6470: 0,
                    6471: 2,
                    6472: 0,
                    6473: 2,
                    6474: 0,
                    6475: 2,
                    6476: 0,
                    6477: 2,
                    6478: 0,
                    6479: 2,
                    6484: 2,
                    6485: 0,
                    6486: 2,
                    6487: 0,
                    6488: 2,
                    6489: 0,
                    6490: 2,
                    6491: 0,
                    6492: 2,
                    6493: 0,
                    6494: 1,
                    6495: 0,
                    6496: 1,
                    6497: 0,
                    6498: 0,
                    6499: 1,
                    6500: 0,
                    6501: 2,
                    6502: 0,
                    6503: 2,
                    6504: 0,
                    6505: 2,
                    6506: 0,
                    6507: 2,
                    6508: 0,
                    6509: 0,
                    6510: 2,
                    6515: 1,
                    6516: 0,
                    6518: 0,
                    6519: 2,
                    6520: 0,
                    6521: 2,
                    6522: 0,
                    6523: 2,
                    6524: 0,
                    6525: 2,
                    6526: 0,
                    6527: 2,
                    6528: 0,
                    6529: 2,
                    6530: 0,
                    6531: 2,
                    6532: 0,
                    6533: 2,
                    6534: 0,
                    6535: 2,
                    6536: 0,
                    6537: 2,
                    6538: 0,
                    6539: 2,
                    6540: 0,
                    6541: 2,
                    6542: 0,
                    6543: 2,
                    6544: 0,
                    6545: 1,
                    6546: 0,
                    6547: 1,
                    6548: 0,
                    6549: 2,
                    6550: 0,
                    6551: 2,
                    6552: 0,
                    6553: 2,
                    6554: 0,
                    6555: 2,
                    6556: 0,
                    6557: 1,
                    6558: 0,
                    6559: 1,
                    6560: 0,
                    6561: 1,
                    6562: 0,
                    6563: 2,
                    6564: 0,
                    6565: 2,
                    6566: 0,
                    6567: 0,
                    6568: 2,
                    6569: 0,
                    6570: 1,
                    6571: 0,
                    6572: 2,
                    6573: 0,
                    6574: 2,
                    6575: 0,
                    6576: 2,
                    6577: 0,
                    6578: 2,
                    6582: 2,
                    6583: 0,
                    6584: 2,
                    6585: 0,
                    6586: 2,
                    6587: 0,
                    6588: 2,
                    6589: 0,
                    6590: 2,
                    6591: 0,
                    6592: 0,
                    6593: 2,
                    6594: 0,
                    6595: 2,
                    6596: 0,
                    6597: 2,
                    6598: 0,
                    6599: 2,
                    6600: 0,
                    6601: 2,
                    6602: 0,
                    6603: 2,
                    6605: 2,
                    6606: 0,
                    6607: 2,
                    6608: 0,
                    6609: 2,
                    6610: 0,
                    6611: 0,
                    6612: 2,
                    6613: 0,
                    6614: 2,
                    6615: 0,
                    6616: 2,
                    6617: 0,
                    6618: 2,
                    6633: 2,
                    6646: 0,
                    6703: 0,
                    6784: 0,
                    6785: 1,
                    6786: 0,
                    6787: 1,
                    6788: 0,
                    6789: 1,
                    6790: 0,
                    6791: 1,
                    6792: 0,
                    6793: 1,
                    6794: 0,
                    6795: 1,
                    6796: 0,
                    6797: 1,
                    6798: 0,
                    6799: 1,
                    6800: 0,
                    6801: 1,
                    6802: 0,
                    6803: 1,
                    6804: 0,
                    6805: 1,
                    6806: 0,
                    6807: 1,
                    6808: 0,
                    6809: 1,
                    6810: 0,
                    6811: 1,
                    6812: 0,
                    6813: 1,
                    6814: 0,
                    6815: 1,
                    6816: 0,
                    6817: 1,
                    6818: 0,
                    6819: 1,
                    6820: 0,
                    6821: 1,
                    6822: 0,
                    6823: 1,
                    6824: 0,
                    6825: 1,
                    6826: 0,
                    6827: 1,
                    6828: 0,
                    6829: 1,
                    6830: 0,
                    6831: 1,
                    6832: 0,
                    6833: 1,
                    6834: 0,
                    6835: 1,
                    6836: 0,
                    6837: 1,
                    6838: 0,
                    6839: 1,
                    6840: 0,
                    6841: 1,
                    6842: 0,
                    6843: 1,
                    6844: 0,
                    6845: 1,
                    6846: 0,
                    6847: 1,
                    6848: 0,
                    6849: 1,
                    6850: 0,
                    6851: 1,
                    6852: 0,
                    6853: 1,
                    6854: 0,
                    6855: 1,
                    6856: 0,
                    6857: 1,
                    6858: 0,
                    6859: 1,
                    6860: 0,
                    6861: 1,
                    6862: 0,
                    6863: 1,
                    6867: 0,
                    6868: 1,
                    6870: 0,
                    6875: 0,
                    6876: 0,
                    6879: 0,
                    6880: 2,
                    6884: 0,
                    6885: 1,
                    6886: 0,
                    6887: 1,
                    6915: 0,
                    6922: 0,
                    6923: 2,
                    6924: 0,
                    6925: 2,
                    6962: 0,
                    6984: 0,
                    6991: 0,
                    7128: 2,
                    7131: 0,
                    7132: 2,
                    7142: 0,
                    7257: 0,
                    7258: 2,
                    7259: 0,
                    7260: 2,
                    7261: 0,
                    7262: 2,
                    7263: 0,
                    7264: 2,
                    7265: 0,
                    7266: 2,
                    7267: 0,
                    7268: 2,
                    7269: 0,
                    7270: 2,
                    7271: 0,
                    7272: 2,
                    7273: 0,
                    7274: 2,
                    7275: 0,
                    7276: 2,
                    7277: 0,
                    7278: 2,
                    7279: 0,
                    7280: 2,
                    7281: 0,
                    7282: 2,
                    7283: 0,
                    7284: 2,
                    7285: 0,
                    7286: 2,
                    7287: 0,
                    7288: 2,
                    7289: 0,
                    7290: 2,
                    7291: 0,
                    7292: 2,
                    7293: 0,
                    7294: 2,
                    7295: 0,
                    7296: 2,
                    7297: 0,
                    7298: 2,
                    7299: 0,
                    7300: 2,
                    7301: 0,
                    7302: 2,
                    7303: 0,
                    7304: 2,
                    7305: 0,
                    7306: 2,
                    7307: 0,
                    7308: 2,
                    7309: 0,
                    7310: 2,
                    7311: 0,
                    7312: 2,
                    7313: 0,
                    7314: 2,
                    7315: 0,
                    7316: 2,
                    7317: 0,
                    7318: 2,
                    7319: 0,
                    7320: 2,
                    7321: 0,
                    7322: 2,
                    7323: 0,
                    7324: 2,
                    7325: 0,
                    7326: 2,
                    7327: 0,
                    7328: 2,
                    7329: 0,
                    7330: 2,
                    7331: 0,
                    7332: 2,
                    7333: 0,
                    7334: 2,
                    7335: 0,
                    7336: 2,
                    7337: 0,
                    7338: 2,
                    7339: 0,
                    7340: 2,
                    7341: 0,
                    7342: 2,
                    7343: 0,
                    7344: 2,
                    7345: 0,
                    7346: 2,
                    7347: 0,
                    7348: 2,
                    7349: 0,
                    7350: 2,
                    7351: 0,
                    7352: 2,
                    7353: 0,
                    7354: 2,
                    7355: 0,
                    7356: 2,
                    7357: 0,
                    7358: 2,
                    7359: 0,
                    7360: 2,
                    7361: 0,
                    7362: 2,
                    7363: 0,
                    7364: 2,
                    7365: 0,
                    7366: 2,
                    7367: 0,
                    7368: 2,
                    7369: 0,
                    7370: 2,
                    7877: 0,
                    7878: 0,
                    7882: 0,
                    7883: 0,
                    7887: 0,
                    7899: 0,
                    7991: 0,
                    7992: 0,
                    8035: 2,
                    8036: 2,
                    8058: 0,
                    8059: 0,
                    8082: 0,
                    8083: 0,
                    8088: 0,
                    8090: 0,
                    8091: 2,
                    8092: 0,
                    8093: 2,
                    8095: 0,
                    8096: 2,
                    8097: 0,
                    8098: 2,
                    8099: 0,
                    8100: 2,
                    8101: 0,
                    8102: 2,
                    8103: 0,
                    8104: 2,
                    8105: 0,
                    8106: 2,
                    8107: 0,
                    8108: 2,
                    8109: 0,
                    8110: 2,
                    8111: 0,
                    8112: 2,
                    8113: 0,
                    8114: 2,
                    8115: 0,
                    8116: 2,
                    8117: 0,
                    8118: 2,
                    8119: 0,
                    8120: 2,
                    8121: 0,
                    8122: 2,
                    8123: 0,
                    8124: 2,
                    8125: 0,
                    8126: 2,
                    8127: 0,
                    8128: 2,
                    8129: 0,
                    8130: 2,
                    8131: 0,
                    8132: 2,
                    8133: 0,
                    8134: 2,
                    8135: 0,
                    8136: 2,
                    8137: 0,
                    8138: 2,
                    8139: 0,
                    8140: 2,
                    8141: 0,
                    8142: 2,
                    8143: 0,
                    8144: 2,
                    8145: 0,
                    8146: 2,
                    8147: 0,
                    8148: 2,
                    8149: 0,
                    8150: 2,
                    8151: 0,
                    8152: 2,
                    8153: 0,
                    8154: 2,
                    8155: 0,
                    8156: 2,
                    8157: 0,
                    8158: 2,
                    8159: 0,
                    8160: 2,
                    8161: 0,
                    8162: 2,
                    8163: 0,
                    8164: 2,
                    8165: 0,
                    8166: 2,
                    8167: 0,
                    8168: 2,
                    8169: 0,
                    8170: 2,
                    8171: 0,
                    8172: 2,
                    8173: 0,
                    8177: 2,
                    8179: 0,
                    8180: 2,
                    8181: 0,
                    8182: 2,
                    8184: 0,
                    8185: 2,
                    8187: 0,
                    8189: 2,
                    8191: 0,
                    8193: 2,
                    8196: 0,
                    8197: 2,
                    8198: 0,
                    8200: 2,
                    8201: 0,
                    8202: 2,
                    8203: 0,
                    8204: 2,
                    8205: 0,
                    8206: 2,
                    8207: 0,
                    8208: 2,
                    8209: 0,
                    8210: 2,
                    8212: 0,
                    8213: 2,
                    8214: 0,
                    8216: 2,
                    8218: 0,
                    8220: 2,
                    8222: 0,
                    8224: 2,
                    8225: 0,
                    8226: 2,
                    8311: 0,
                    8312: 1,
                    8313: 0,
                    8314: 1,
                    8315: 0,
                    8316: 1,
                    8317: 0,
                    8318: 1,
                    8319: 0,
                    8320: 1,
                    8321: 0,
                    8322: 1,
                    8323: 0,
                    8324: 1,
                    8325: 0,
                    8326: 1,
                    8327: 0,
                    8328: 1,
                    8329: 0,
                    8330: 1,
                    8331: 0,
                    8332: 1,
                    8333: 0,
                    8334: 1,
                    8335: 0,
                    8336: 1,
                    8337: 0,
                    8338: 1,
                    8339: 0,
                    8340: 1,
                    8341: 0,
                    8342: 1,
                    8343: 0,
                    8344: 1,
                    8345: 0,
                    8346: 1,
                    8347: 0,
                    8348: 1,
                    8352: 0,
                    8353: 0,
                    8379: 0,
                    8380: 2,
                    8381: 0,
                    8382: 2,
                    8383: 0,
                    8384: 2,
                    8385: 0,
                    8387: 2,
                    8391: 0,
                    8395: 0,
                    8433: 0,
                    8441: 0,
                    8455: 0,
                    8456: 0,
                    8531: 2,
                    8682: 0,
                    8686: 0,
                    8687: 0,
                    8692: 0,
                    8693: 0,
                    8826: 0,
                    8903: 0,
                    8950: 0,
                    8951: 0,
                    9039: 0,
                    9040: 0,
                    9141: 0,
                    9149: 0,
                    9150: 0,
                    9191: 0,
                    9221: 0,
                    9222: 0,
                    9249: 0,
                    9250: 0,
                    9252: 0,
                    9254: 0,
                    9265: 0,
                    9284: 0,
                    9285: 0,
                    9367: 0,
                    20499: 0,
                    20538: 0,
                    20539: 0,
                    20790: 0,
                    20791: 0,
                    21291: 0,
                    21292: 0,
                    21500: 0,
                    21817: 0,
                    21818: 0,
                    22032: 0,
                    22033: 0,
                    22091: 0,
                    22092: 0,
                    22332: 0,
                    22391: 0,
                    22392: 0,
                    22700: 0,
                    22770: 0,
                    22780: 0,
                    22832: 0,
                    23090: 0,
                    23095: 0,
                    23239: 0,
                    23240: 0,
                    23433: 0,
                    23700: 0,
                    24047: 0,
                    24048: 0,
                    24100: 3,
                    24200: 0,
                    24305: 0,
                    24306: 0,
                    24382: 10,
                    24383: 0,
                    24500: 0,
                    24547: 0,
                    24548: 0,
                    24571: 9,
                    24600: 0,
                    25E3: 0,
                    25231: 0,
                    25884: 0,
                    25932: 0,
                    26237: 0,
                    26331: 0,
                    26332: 0,
                    26432: 0,
                    26591: 0,
                    26592: 0,
                    26632: 0,
                    26692: 0,
                    27120: 0,
                    27200: 0,
                    27291: 6,
                    27292: 6,
                    27429: 0,
                    27492: 0,
                    27493: 0,
                    27500: 0,
                    27700: 0,
                    28232: 0,
                    28600: 0,
                    28991: 0,
                    28992: 0,
                    29100: 0,
                    29101: 0,
                    29220: 0,
                    29221: 0,
                    29333: 0,
                    29635: 0,
                    29636: 0,
                    29701: 0,
                    29738: 0,
                    29739: 0,
                    29849: 0,
                    29850: 0,
                    29871: 8,
                    29872: 7,
                    29873: 0,
                    30200: 5,
                    30339: 0,
                    30340: 0,
                    30591: 0,
                    30592: 0,
                    30791: 0,
                    30792: 0,
                    30800: 0,
                    31028: 0,
                    31121: 0,
                    31154: 0,
                    31170: 0,
                    31171: 0,
                    31370: 0,
                    31528: 0,
                    31529: 0,
                    31600: 0,
                    31700: 0,
                    31838: 0,
                    31839: 0,
                    31900: 0,
                    31901: 0,
                    32061: 0,
                    32062: 0,
                    32098: 0,
                    32099: 2,
                    32100: 0,
                    32104: 0,
                    32161: 0,
                    32766: 0,
                    53048: 0,
                    53049: 0,
                    54090: 0,
                    54091: 0,
                    65061: 2,
                    65062: 2,
                    65161: 0,
                    65163: 0,
                    102041: 2,
                    102064: 11,
                    102068: 14,
                    102069: 15,
                    102118: 2,
                    102119: 1,
                    102120: 2,
                    102121: 2,
                    102217: 2,
                    102218: 0,
                    102219: 2,
                    102220: 2,
                    102378: 1,
                    102379: 1,
                    102380: 0,
                    102381: 1,
                    102589: 2,
                    102599: 2,
                    102600: 2,
                    102604: 2,
                    102647: 0,
                    102704: 2,
                    102705: 2,
                    102706: 0,
                    102761: 2,
                    102762: 0,
                    102763: 2,
                    102764: 0,
                    102765: 0,
                    102766: 2,
                    102962: 0,
                    102963: 0,
                    102970: 1,
                    102974: 2,
                    102993: 0,
                    102994: 0,
                    102995: 2,
                    102996: 2,
                    103015: 0,
                    103016: 2,
                    103017: 0,
                    103018: 2,
                    103025: 0,
                    103026: 0,
                    103027: 2,
                    103028: 2,
                    103035: 0,
                    103036: 0,
                    103037: 2,
                    103038: 2,
                    103039: 0,
                    103040: 0,
                    103041: 2,
                    103042: 2,
                    103043: 0,
                    103044: 0,
                    103045: 2,
                    103046: 2,
                    103047: 0,
                    103048: 0,
                    103049: 2,
                    103050: 2,
                    103051: 0,
                    103052: 2,
                    103053: 0,
                    103054: 2,
                    103055: 0,
                    103056: 2,
                    103057: 0,
                    103058: 0,
                    103059: 2,
                    103060: 2,
                    103061: 0,
                    103062: 0,
                    103063: 2,
                    103064: 2,
                    103069: 2,
                    103070: 0,
                    103071: 0,
                    103072: 2,
                    103073: 2,
                    103086: 0,
                    103087: 0,
                    103088: 2,
                    103089: 2,
                    103094: 1,
                    103095: 0,
                    103096: 2,
                    103103: 0,
                    103104: 2,
                    103105: 0,
                    103106: 2,
                    103121: 0,
                    103122: 2,
                    103123: 0,
                    103124: 0,
                    103125: 1,
                    103126: 1,
                    103127: 0,
                    103128: 0,
                    103129: 2,
                    103130: 2,
                    103131: 0,
                    103132: 0,
                    103133: 2,
                    103134: 2,
                    103135: 0,
                    103136: 0,
                    103137: 1,
                    103138: 1,
                    103139: 0,
                    103140: 2,
                    103141: 0,
                    103142: 2,
                    103143: 0,
                    103144: 2,
                    103145: 0,
                    103146: 1,
                    103147: 0,
                    103148: 0,
                    103149: 2,
                    103150: 2,
                    103151: 0,
                    103152: 2,
                    103172: 0,
                    103173: 2,
                    103174: 0,
                    103175: 0,
                    103176: 2,
                    103177: 2,
                    103178: 0,
                    103179: 0,
                    103180: 2,
                    103181: 2,
                    103182: 0,
                    103183: 0,
                    103184: 2,
                    103185: 2,
                    103228: 0,
                    103229: 0,
                    103230: 2,
                    103231: 2,
                    103250: 0,
                    103251: 2,
                    103252: 0,
                    103253: 2,
                    103260: 0,
                    103261: 0,
                    103262: 2,
                    103263: 2,
                    103270: 0,
                    103271: 0,
                    103272: 2,
                    103273: 2,
                    103274: 0,
                    103275: 0,
                    103276: 2,
                    103277: 2,
                    103278: 0,
                    103279: 0,
                    103280: 2,
                    103281: 2,
                    103282: 0,
                    103283: 0,
                    103284: 2,
                    103285: 2,
                    103286: 0,
                    103287: 2,
                    103288: 0,
                    103289: 2,
                    103290: 0,
                    103291: 2,
                    103292: 0,
                    103293: 0,
                    103294: 2,
                    103295: 2,
                    103296: 0,
                    103297: 0,
                    103298: 2,
                    103299: 2,
                    103376: 2,
                    103377: 0,
                    103378: 0,
                    103379: 2,
                    103380: 2,
                    103393: 0,
                    103394: 0,
                    103395: 2,
                    103396: 2,
                    103472: 0,
                    103473: 1,
                    103474: 0,
                    103475: 2,
                    103482: 0,
                    103483: 2,
                    103484: 0,
                    103485: 2,
                    103500: 0,
                    103501: 2,
                    103502: 0,
                    103503: 0,
                    103504: 1,
                    103505: 1,
                    103506: 0,
                    103507: 0,
                    103508: 2,
                    103509: 2,
                    103510: 0,
                    103511: 0,
                    103512: 2,
                    103513: 2,
                    103514: 0,
                    103515: 2,
                    103516: 0,
                    103517: 2,
                    103518: 0,
                    103519: 2,
                    103520: 0,
                    103521: 1,
                    103522: 0,
                    103523: 0,
                    103524: 2,
                    103525: 2,
                    103526: 0,
                    103527: 2,
                    103561: 2,
                    103562: 2,
                    103563: 0,
                    103564: 0,
                    103565: 2,
                    103566: 2,
                    103567: 0,
                    103568: 0,
                    103569: 2,
                    103570: 2,
                    103584: 0,
                    103585: 2,
                    103586: 0,
                    103587: 2,
                    103588: 1,
                    103589: 0,
                    103590: 2,
                    103591: 1,
                    103592: 0,
                    103593: 2,
                    103594: 1,
                    103695: 2
                };
                for (a = 2E3; 2045 >= a; a++) k[a] = 0;
                for (a = 2056; 2065 >= a; a++) k[a] = 0;
                for (a = 2067; 2135 >= a; a++) k[a] = 0;
                for (a = 2137; 2154 >= a; a++) k[a] = 0;
                for (a = 2161; 2170 >= a; a++) k[a] = 0;
                for (a = 2172; 2193 >= a; a++) k[a] =
                    0;
                for (a = 2195; 2198 >= a; a++) k[a] = 0;
                for (a = 2200; 2203 >= a; a++) k[a] = 0;
                for (a = 2205; 2217 >= a; a++) k[a] = 0;
                for (a = 2222; 2224 >= a; a++) k[a] = 1;
                for (a = 2225; 2250 >= a; a++) k[a] = 2;
                for (a = 2251; 2253 >= a; a++) k[a] = 1;
                for (a = 2257; 2264 >= a; a++) k[a] = 2;
                for (a = 2274; 2279 >= a; a++) k[a] = 2;
                for (a = 2280; 2282 >= a; a++) k[a] = 1;
                for (a = 2283; 2289 >= a; a++) k[a] = 2;
                for (a = 2290; 2292 >= a; a++) k[a] = 0;
                for (a = 2308; 2313 >= a; a++) k[a] = 0;
                for (a = 2315; 2491 >= a; a++) k[a] = 0;
                for (a = 2494; 2866 >= a; a++) k[a] = 0;
                for (a = 2867; 2869 >= a; a++) k[a] = 1;
                for (a = 2870; 2888 >= a; a++) k[a] = 2;
                for (a = 2891; 2895 >= a; a++) k[a] =
                    2;
                for (a = 2896; 2898 >= a; a++) k[a] = 1;
                for (a = 2902; 2908 >= a; a++) k[a] = 2;
                for (a = 2915; 2920 >= a; a++) k[a] = 2;
                for (a = 2921; 2923 >= a; a++) k[a] = 1;
                for (a = 2924; 2930 >= a; a++) k[a] = 2;
                for (a = 2931; 2962 >= a; a++) k[a] = 0;
                for (a = 2964; 2968 >= a; a++) k[a] = 2;
                for (a = 2969; 2973 >= a; a++) k[a] = 0;
                for (a = 2975; 2991 >= a; a++) k[a] = 0;
                for (a = 2995; 3051 >= a; a++) k[a] = 0;
                for (a = 3054; 3079 >= a; a++) k[a] = 0;
                for (a = 3081; 3088 >= a; a++) k[a] = 0;
                for (a = 3092; 3101 >= a; a++) k[a] = 0;
                for (a = 3106; 3138 >= a; a++) k[a] = 0;
                for (a = 3146; 3151 >= a; a++) k[a] = 0;
                for (a = 3153; 3166 >= a; a++) k[a] = 0;
                for (a = 3168; 3172 >= a; a++) k[a] =
                    0;
                for (a = 3174; 3203 >= a; a++) k[a] = 0;
                for (a = 3294; 3358 >= a; a++) k[a] = 0;
                for (a = 3367; 3403 >= a; a++) k[a] = 0;
                for (a = 3408; 3416 >= a; a++) k[a] = 0;
                for (a = 3417; 3438 >= a; a++) k[a] = 2;
                for (a = 3441; 3446 >= a; a++) k[a] = 2;
                for (a = 3447; 3450 >= a; a++) k[a] = 0;
                for (a = 3451; 3459 >= a; a++) k[a] = 2;
                for (a = 3460; 3478 >= a; a++) k[a] = 0;
                for (a = 3554; 3559 >= a; a++) k[a] = 0;
                for (a = 3560; 3570 >= a; a++) k[a] = 2;
                for (a = 3571; 3581 >= a; a++) k[a] = 0;
                for (a = 3594; 3597 >= a; a++) k[a] = 0;
                for (a = 3601; 3604 >= a; a++) k[a] = 0;
                for (a = 3637; 3639 >= a; a++) k[a] = 0;
                for (a = 3665; 3667 >= a; a++) k[a] = 0;
                for (a = 3693; 3695 >= a; a++) k[a] =
                    0;
                for (a = 3701; 3727 >= a; a++) k[a] = 0;
                for (a = 3728; 3739 >= a; a++) k[a] = 2;
                for (a = 3740; 3751 >= a; a++) k[a] = 0;
                for (a = 3753; 3760 >= a; a++) k[a] = 2;
                for (a = 3761; 3773 >= a; a++) k[a] = 0;
                for (a = 3775; 3777 >= a; a++) k[a] = 0;
                for (a = 3779; 3781 >= a; a++) k[a] = 0;
                for (a = 3783; 3785 >= a; a++) k[a] = 0;
                for (a = 3788; 3791 >= a; a++) k[a] = 0;
                for (a = 3797; 3802 >= a; a++) k[a] = 0;
                for (a = 3814; 3816 >= a; a++) k[a] = 0;
                for (a = 3825; 3829 >= a; a++) k[a] = 0;
                for (a = 3832; 3841 >= a; a++) k[a] = 0;
                for (a = 3844; 3852 >= a; a++) k[a] = 0;
                for (a = 3873; 3885 >= a; a++) k[a] = 0;
                for (a = 3890; 3893 >= a; a++) k[a] = 0;
                for (a = 3907; 3912 >= a; a++) k[a] =
                    0;
                for (a = 3942; 3950 >= a; a++) k[a] = 0;
                for (a = 3968; 3970 >= a; a++) k[a] = 0;
                for (a = 3973; 3976 >= a; a++) k[a] = 0;
                for (a = 3986; 3989 >= a; a++) k[a] = 0;
                for (a = 3994; 3997 >= a; a++) k[a] = 0;
                for (a = 4048; 4051 >= a; a++) k[a] = 0;
                for (a = 4056; 4063 >= a; a++) k[a] = 0;
                for (a = 4093; 4096 >= a; a++) k[a] = 0;
                for (a = 4390; 4398 >= a; a++) k[a] = 0;
                for (a = 4399; 4413 >= a; a++) k[a] = 2;
                for (a = 4418; 4433 >= a; a++) k[a] = 2;
                for (a = 4455; 4457 >= a; a++) k[a] = 2;
                for (a = 4484; 4489 >= a; a++) k[a] = 0;
                for (a = 4491; 4554 >= a; a++) k[a] = 0;
                for (a = 4568; 4589 >= a; a++) k[a] = 0;
                for (a = 4652; 4656 >= a; a++) k[a] = 0;
                for (a = 4766; 4800 >= a; a++) k[a] =
                    0;
                for (a = 5014; 5016 >= a; a++) k[a] = 0;
                for (a = 5069; 5072 >= a; a++) k[a] = 0;
                for (a = 5105; 5130 >= a; a++) k[a] = 0;
                for (a = 5173; 5188 >= a; a++) k[a] = 0;
                for (a = 5253; 5259 >= a; a++) k[a] = 0;
                for (a = 5269; 5275 >= a; a++) k[a] = 0;
                for (a = 5292; 5311 >= a; a++) k[a] = 0;
                for (a = 5329; 5331 >= a; a++) k[a] = 0;
                for (a = 5343; 5349 >= a; a++) k[a] = 0;
                for (a = 5355; 5357 >= a; a++) k[a] = 0;
                for (a = 5387; 5389 >= a; a++) k[a] = 0;
                for (a = 5459; 5463 >= a; a++) k[a] = 0;
                for (a = 5479; 5482 >= a; a++) k[a] = 0;
                for (a = 5518; 5520 >= a; a++) k[a] = 0;
                for (a = 5530; 5539 >= a; a++) k[a] = 0;
                for (a = 5550; 5552 >= a; a++) k[a] = 0;
                for (a = 5562; 5583 >= a; a++) k[a] =
                    0;
                for (a = 5623; 5625 >= a; a++) k[a] = 2;
                for (a = 5631; 5639 >= a; a++) k[a] = 0;
                for (a = 5649; 5653 >= a; a++) k[a] = 0;
                for (a = 5663; 5680 >= a; a++) k[a] = 0;
                for (a = 5682; 5685 >= a; a++) k[a] = 0;
                for (a = 5875; 5877 >= a; a++) k[a] = 0;
                for (a = 5896; 5899 >= a; a++) k[a] = 0;
                for (a = 5921; 5940 >= a; a++) k[a] = 0;
                for (a = 6050; 6125 >= a; a++) k[a] = 0;
                for (a = 6244; 6275 >= a; a++) k[a] = 0;
                for (a = 6328; 6348 >= a; a++) k[a] = 0;
                for (a = 6350; 6356 >= a; a++) k[a] = 0;
                for (a = 6366; 6372 >= a; a++) k[a] = 0;
                for (a = 6381; 6387 >= a; a++) k[a] = 0;
                for (a = 6393; 6404 >= a; a++) k[a] = 0;
                for (a = 6480; 6483 >= a; a++) k[a] = 0;
                for (a = 6511; 6514 >= a; a++) k[a] =
                    0;
                for (a = 6579; 6581 >= a; a++) k[a] = 0;
                for (a = 6619; 6624 >= a; a++) k[a] = 0;
                for (a = 6625; 6627 >= a; a++) k[a] = 2;
                for (a = 6628; 6632 >= a; a++) k[a] = 0;
                for (a = 6634; 6637 >= a; a++) k[a] = 0;
                for (a = 6669; 6692 >= a; a++) k[a] = 0;
                for (a = 6707; 6709 >= a; a++) k[a] = 0;
                for (a = 6720; 6723 >= a; a++) k[a] = 0;
                for (a = 6732; 6738 >= a; a++) k[a] = 0;
                for (a = 6931; 6933 >= a; a++) k[a] = 0;
                for (a = 6956; 6959 >= a; a++) k[a] = 0;
                for (a = 7005; 7007 >= a; a++) k[a] = 0;
                for (a = 7057; 7070 >= a; a++) k[a] = 2;
                for (a = 7074; 7082 >= a; a++) k[a] = 0;
                for (a = 7109; 7118 >= a; a++) k[a] = 0;
                for (a = 7119; 7127 >= a; a++) k[a] = 1;
                for (a = 7374; 7376 >= a; a++) k[a] =
                    0;
                for (a = 7528; 7586 >= a; a++) k[a] = 0;
                for (a = 7587; 7645 >= a; a++) k[a] = 2;
                for (a = 7692; 7696 >= a; a++) k[a] = 0;
                for (a = 7755; 7787 >= a; a++) k[a] = 0;
                for (a = 7791; 7795 >= a; a++) k[a] = 0;
                for (a = 7799; 7801 >= a; a++) k[a] = 0;
                for (a = 7803; 7805 >= a; a++) k[a] = 0;
                for (a = 7825; 7831 >= a; a++) k[a] = 0;
                for (a = 7845; 7859 >= a; a++) k[a] = 0;
                for (a = 8013; 8032 >= a; a++) k[a] = 0;
                for (a = 8065; 8068 >= a; a++) k[a] = 1;
                for (a = 8518; 8529 >= a; a++) k[a] = 2;
                for (a = 8533; 8536 >= a; a++) k[a] = 2;
                for (a = 8538; 8540 >= a; a++) k[a] = 2;
                for (a = 8677; 8679 >= a; a++) k[a] = 0;
                for (a = 8836; 8840 >= a; a++) k[a] = 0;
                for (a = 8857; 8859 >= a; a++) k[a] =
                    0;
                for (a = 8908; 8910 >= a; a++) k[a] = 0;
                for (a = 9154; 9159 >= a; a++) k[a] = 0;
                for (a = 9205; 9218 >= a; a++) k[a] = 0;
                for (a = 9271; 9273 >= a; a++) k[a] = 0;
                for (a = 9295; 9297 >= a; a++) k[a] = 0;
                for (a = 20002; 20032 >= a; a++) k[a] = 0;
                for (a = 20062; 20092 >= a; a++) k[a] = 0;
                for (a = 20135; 20138 >= a; a++) k[a] = 0;
                for (a = 20248; 20258 >= a; a++) k[a] = 0;
                for (a = 20348; 20358 >= a; a++) k[a] = 0;
                for (a = 20436; 20440 >= a; a++) k[a] = 0;
                for (a = 20822; 20824 >= a; a++) k[a] = 0;
                for (a = 20934; 20936 >= a; a++) k[a] = 0;
                for (a = 21035; 21037 >= a; a++) k[a] = 0;
                for (a = 21095; 21097 >= a; a++) k[a] = 0;
                for (a = 21148; 21150 >= a; a++) k[a] =
                    0;
                for (a = 21413; 21423 >= a; a++) k[a] = 0;
                for (a = 21453; 21463 >= a; a++) k[a] = 0;
                for (a = 21473; 21483 >= a; a++) k[a] = 0;
                for (a = 21780; 21782 >= a; a++) k[a] = 0;
                for (a = 21891; 21894 >= a; a++) k[a] = 0;
                for (a = 21896; 21899 >= a; a++) k[a] = 0;
                for (a = 22171; 22177 >= a; a++) k[a] = 0;
                for (a = 22181; 22187 >= a; a++) k[a] = 0;
                for (a = 22191; 22197 >= a; a++) k[a] = 0;
                for (a = 22234; 22236 >= a; a++) k[a] = 0;
                for (a = 22521; 22525 >= a; a++) k[a] = 0;
                for (a = 22991; 22994 >= a; a++) k[a] = 0;
                for (a = 23028; 23038 >= a; a++) k[a] = 0;
                for (a = 23830; 23853 >= a; a++) k[a] = 0;
                for (a = 23866; 23872 >= a; a++) k[a] = 0;
                for (a = 23877; 23884 >=
                    a; a++) k[a] = 0;
                for (a = 23886; 23894 >= a; a++) k[a] = 0;
                for (a = 23946; 23948 >= a; a++) k[a] = 0;
                for (a = 24311; 24313 >= a; a++) k[a] = 0;
                for (a = 24342; 24347 >= a; a++) k[a] = 0;
                for (a = 24370; 24374 >= a; a++) k[a] = 10;
                for (a = 24375; 24381 >= a; a++) k[a] = 0;
                for (a = 24718; 24721 >= a; a++) k[a] = 0;
                for (a = 24817; 24821 >= a; a++) k[a] = 0;
                for (a = 24877; 24882 >= a; a++) k[a] = 0;
                for (a = 24891; 24893 >= a; a++) k[a] = 0;
                for (a = 25391; 25395 >= a; a++) k[a] = 0;
                for (a = 25828; 25838 >= a; a++) k[a] = 0;
                for (a = 26191; 26195 >= a; a++) k[a] = 0;
                for (a = 26391; 26393 >= a; a++) k[a] = 0;
                for (a = 26701; 26722 >= a; a++) k[a] = 0;
                for (a = 26729; 26799 >=
                    a; a++) k[a] = 2;
                for (a = 26801; 26803 >= a; a++) k[a] = 2;
                for (a = 26811; 26813 >= a; a++) k[a] = 2;
                for (a = 26847; 26870 >= a; a++) k[a] = 2;
                for (a = 26891; 26899 >= a; a++) k[a] = 0;
                for (a = 26901; 26923 >= a; a++) k[a] = 0;
                for (a = 26929; 26946 >= a; a++) k[a] = 0;
                for (a = 26948; 26998 >= a; a++) k[a] = 0;
                for (a = 27037; 27040 >= a; a++) k[a] = 0;
                for (a = 27205; 27232 >= a; a++) k[a] = 0;
                for (a = 27258; 27260 >= a; a++) k[a] = 0;
                for (a = 27391; 27398 >= a; a++) k[a] = 0;
                for (a = 27561; 27564 >= a; a++) k[a] = 0;
                for (a = 27571; 27574 >= a; a++) k[a] = 0;
                for (a = 27581; 27584 >= a; a++) k[a] = 0;
                for (a = 27591; 27594 >= a; a++) k[a] = 0;
                for (a = 28191; 28193 >=
                    a; a++) k[a] = 0;
                for (a = 28348; 28358 >= a; a++) k[a] = 0;
                for (a = 28402; 28432 >= a; a++) k[a] = 0;
                for (a = 28462; 28492 >= a; a++) k[a] = 0;
                for (a = 29118; 29122 >= a; a++) k[a] = 0;
                for (a = 29168; 29172 >= a; a++) k[a] = 0;
                for (a = 29177; 29185 >= a; a++) k[a] = 0;
                for (a = 29187; 29195 >= a; a++) k[a] = 0;
                for (a = 29900; 29903 >= a; a++) k[a] = 0;
                for (a = 30161; 30179 >= a; a++) k[a] = 0;
                for (a = 30491; 30494 >= a; a++) k[a] = 0;
                for (a = 30729; 30732 >= a; a++) k[a] = 0;
                for (a = 31251; 31259 >= a; a++) k[a] = 0;
                for (a = 31265; 31268 >= a; a++) k[a] = 0;
                for (a = 31275; 31279 >= a; a++) k[a] = 0;
                for (a = 31281; 31297 >= a; a++) k[a] = 0;
                for (a = 31461; 31469 >=
                    a; a++) k[a] = 0;
                for (a = 31491; 31495 >= a; a++) k[a] = 0;
                for (a = 31917; 31922 >= a; a++) k[a] = 0;
                for (a = 31965; 32E3 >= a; a++) k[a] = 0;
                for (a = 32001; 32003 >= a; a++) k[a] = 2;
                for (a = 32005; 32031 >= a; a++) k[a] = 2;
                for (a = 32033; 32060 >= a; a++) k[a] = 2;
                for (a = 32064; 32067 >= a; a++) k[a] = 2;
                for (a = 32074; 32077 >= a; a++) k[a] = 2;
                for (a = 32081; 32086 >= a; a++) k[a] = 0;
                for (a = 32107; 32130 >= a; a++) k[a] = 0;
                for (a = 32133; 32158 >= a; a++) k[a] = 0;
                for (a = 32164; 32167 >= a; a++) k[a] = 2;
                for (a = 32180; 32199 >= a; a++) k[a] = 0;
                for (a = 32201; 32260 >= a; a++) k[a] = 0;
                for (a = 32301; 32360 >= a; a++) k[a] = 0;
                for (a = 32601; 32662 >=
                    a; a++) k[a] = 0;
                for (a = 32664; 32667 >= a; a++) k[a] = 2;
                for (a = 32701; 32761 >= a; a++) k[a] = 0;
                for (a = 53001; 53004 >= a; a++) k[a] = 0;
                for (a = 53008; 53019 >= a; a++) k[a] = 0;
                for (a = 53021; 53032 >= a; a++) k[a] = 0;
                for (a = 53034; 53037 >= a; a++) k[a] = 0;
                for (a = 53042; 53046 >= a; a++) k[a] = 0;
                for (a = 53074; 53080 >= a; a++) k[a] = 0;
                for (a = 54001; 54004 >= a; a++) k[a] = 0;
                for (a = 54008; 54019 >= a; a++) k[a] = 0;
                for (a = 54021; 54032 >= a; a++) k[a] = 0;
                for (a = 54034; 54037 >= a; a++) k[a] = 0;
                for (a = 54042; 54046 >= a; a++) k[a] = 0;
                for (a = 54048; 54053 >= a; a++) k[a] = 0;
                for (a = 54074; 54080 >= a; a++) k[a] = 0;
                for (a = 54098; 54101 >=
                    a; a++) k[a] = 0;
                for (a = 102001; 102040 >= a; a++) k[a] = 0;
                for (a = 102042; 102063 >= a; a++) k[a] = 0;
                for (a = 102065; 102067 >= a; a++) k[a] = 0;
                for (a = 102070; 102117 >= a; a++) k[a] = 0;
                for (a = 102122; 102216 >= a; a++) k[a] = 0;
                for (a = 102221; 102377 >= a; a++) k[a] = 0;
                for (a = 102382; 102388 >= a; a++) k[a] = 0;
                for (a = 102389; 102398 >= a; a++) k[a] = 2;
                for (a = 102399; 102444 >= a; a++) k[a] = 0;
                for (a = 102445; 102447 >= a; a++) k[a] = 2;
                for (a = 102448; 102458 >= a; a++) k[a] = 0;
                for (a = 102459; 102468 >= a; a++) k[a] = 2;
                for (a = 102469; 102499 >= a; a++) k[a] = 0;
                for (a = 102500; 102519 >= a; a++) k[a] = 1;
                for (a = 102520; 102524 >=
                    a; a++) k[a] = 0;
                for (a = 102525; 102529 >= a; a++) k[a] = 2;
                for (a = 102530; 102588 >= a; a++) k[a] = 0;
                for (a = 102590; 102598 >= a; a++) k[a] = 0;
                for (a = 102601; 102603 >= a; a++) k[a] = 0;
                for (a = 102605; 102628 >= a; a++) k[a] = 0;
                for (a = 102629; 102646 >= a; a++) k[a] = 2;
                for (a = 102648; 102700 >= a; a++) k[a] = 2;
                for (a = 102701; 102703 >= a; a++) k[a] = 0;
                for (a = 102707; 102730 >= a; a++) k[a] = 2;
                for (a = 102733; 102758 >= a; a++) k[a] = 2;
                for (a = 102767; 102900 >= a; a++) k[a] = 0;
                for (a = 102965; 102969 >= a; a++) k[a] = 0;
                for (a = 102971; 102973 >= a; a++) k[a] = 0;
                for (a = 102975; 102989 >= a; a++) k[a] = 0;
                for (a = 102990; 102992 >=
                    a; a++) k[a] = 1;
                for (a = 102997; 103002 >= a; a++) k[a] = 0;
                for (a = 103003; 103008 >= a; a++) k[a] = 2;
                for (a = 103009; 103011 >= a; a++) k[a] = 0;
                for (a = 103012; 103014 >= a; a++) k[a] = 2;
                for (a = 103019; 103021 >= a; a++) k[a] = 0;
                for (a = 103022; 103024 >= a; a++) k[a] = 2;
                for (a = 103029; 103031 >= a; a++) k[a] = 0;
                for (a = 103032; 103034 >= a; a++) k[a] = 2;
                for (a = 103065; 103068 >= a; a++) k[a] = 0;
                for (a = 103074; 103076 >= a; a++) k[a] = 0;
                for (a = 103077; 103079 >= a; a++) k[a] = 1;
                for (a = 103080; 103082 >= a; a++) k[a] = 0;
                for (a = 103083; 103085 >= a; a++) k[a] = 2;
                for (a = 103090; 103093 >= a; a++) k[a] = 0;
                for (a = 103097; 103099 >=
                    a; a++) k[a] = 0;
                for (a = 103100; 103102 >= a; a++) k[a] = 2;
                for (a = 103107; 103109 >= a; a++) k[a] = 0;
                for (a = 103110; 103112 >= a; a++) k[a] = 2;
                for (a = 103113; 103116 >= a; a++) k[a] = 0;
                for (a = 103117; 103120 >= a; a++) k[a] = 2;
                for (a = 103153; 103157 >= a; a++) k[a] = 0;
                for (a = 103158; 103162 >= a; a++) k[a] = 2;
                for (a = 103163; 103165 >= a; a++) k[a] = 0;
                for (a = 103166; 103168 >= a; a++) k[a] = 1;
                for (a = 103169; 103171 >= a; a++) k[a] = 2;
                for (a = 103186; 103188 >= a; a++) k[a] = 0;
                for (a = 103189; 103191 >= a; a++) k[a] = 2;
                for (a = 103192; 103195 >= a; a++) k[a] = 0;
                for (a = 103196; 103199 >= a; a++) k[a] = 2;
                for (a = 103200; 103224 >=
                    a; a++) k[a] = 0;
                for (a = 103225; 103227 >= a; a++) k[a] = 1;
                for (a = 103232; 103237 >= a; a++) k[a] = 0;
                for (a = 103238; 103243 >= a; a++) k[a] = 2;
                for (a = 103244; 103246 >= a; a++) k[a] = 0;
                for (a = 103247; 103249 >= a; a++) k[a] = 2;
                for (a = 103254; 103256 >= a; a++) k[a] = 0;
                for (a = 103257; 103259 >= a; a++) k[a] = 2;
                for (a = 103264; 103266 >= a; a++) k[a] = 0;
                for (a = 103267; 103269 >= a; a++) k[a] = 2;
                for (a = 103300; 103375 >= a; a++) k[a] = 0;
                for (a = 103381; 103383 >= a; a++) k[a] = 0;
                for (a = 103384; 103386 >= a; a++) k[a] = 1;
                for (a = 103387; 103389 >= a; a++) k[a] = 0;
                for (a = 103390; 103392 >= a; a++) k[a] = 2;
                for (a = 103397; 103399 >=
                    a; a++) k[a] = 0;
                for (a = 103400; 103471 >= a; a++) k[a] = 2;
                for (a = 103476; 103478 >= a; a++) k[a] = 0;
                for (a = 103479; 103481 >= a; a++) k[a] = 2;
                for (a = 103486; 103488 >= a; a++) k[a] = 0;
                for (a = 103489; 103491 >= a; a++) k[a] = 2;
                for (a = 103492; 103495 >= a; a++) k[a] = 0;
                for (a = 103496; 103499 >= a; a++) k[a] = 2;
                for (a = 103528; 103543 >= a; a++) k[a] = 0;
                for (a = 103544; 103548 >= a; a++) k[a] = 2;
                for (a = 103549; 103551 >= a; a++) k[a] = 0;
                for (a = 103552; 103554 >= a; a++) k[a] = 1;
                for (a = 103555; 103557 >= a; a++) k[a] = 2;
                for (a = 103558; 103560 >= a; a++) k[a] = 0;
                for (a = 103571; 103573 >= a; a++) k[a] = 0;
                for (a = 103574; 103576 >=
                    a; a++) k[a] = 2;
                for (a = 103577; 103580 >= a; a++) k[a] = 0;
                for (a = 103581; 103583 >= a; a++) k[a] = 2;
                for (a = 103595; 103694 >= a; a++) k[a] = 0;
                for (a = 103696; 103699 >= a; a++) k[a] = 0;
                for (a = 103700; 103793 >= a; a++) k[a] = 2;
                for (a = 103794; 103872 >= a; a++) k[a] = 0;
                for (a = 103900; 103971 >= a; a++) k[a] = 2;
                return k
            })
        },
        "esri/geometry/Geometry": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/has ../core/Logger ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/jsonMap ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/urlUtils ../core/uuid ../portal/support/resourceExtension ../core/JSONSupport ./SpatialReference".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l) {
                    w = function(n) {
                        function u(...x) {
                            x = n.call(this, ...x) || this;
                            x.type = null;
                            x.hasM = !1;
                            x.hasZ = !1;
                            x.spatialReference = l.WGS84;
                            return x
                        }
                        a._inheritsLoose(u, n);
                        var y = u.prototype;
                        y.readSpatialReference = function(x, q) {
                            if (x instanceof l) return x;
                            if (null != x) {
                                const B = new l;
                                B.read(x, q);
                                return B
                            }
                            return x
                        };
                        y.clone = function() {
                            console.warn(".clone() is not implemented for " + this.declaredClass);
                            return null
                        };
                        y.clearCache = function() {
                            this.notifyChange("cache")
                        };
                        y.getCacheValue = function(x) {
                            return this.cache[x]
                        };
                        y.setCacheValue = function(x, q) {
                            this.cache[x] = q
                        };
                        a._createClass(u, [{
                            key: "cache",
                            get: function() {
                                this.commitProperty("spatialReference");
                                return {}
                            }
                        }, {
                            key: "extent",
                            get: function() {
                                return null
                            }
                        }]);
                        return u
                    }(p.JSONSupport);
                    k.__decorate([f.property()], w.prototype, "type", void 0);
                    k.__decorate([f.property({
                        readOnly: !0
                    })], w.prototype, "cache", null);
                    k.__decorate([f.property({
                        readOnly: !0
                    })], w.prototype, "extent", null);
                    k.__decorate([f.property({
                            type: Boolean,
                            json: {
                                write: {
                                    overridePolicy(n) {
                                        return {
                                            enabled: n
                                        }
                                    }
                                }
                            }
                        })], w.prototype,
                        "hasM", void 0);
                    k.__decorate([f.property({
                        type: Boolean,
                        json: {
                            write: {
                                overridePolicy(n) {
                                    return {
                                        enabled: n
                                    }
                                }
                            }
                        }
                    })], w.prototype, "hasZ", void 0);
                    k.__decorate([f.property({
                        type: l,
                        json: {
                            write: !0
                        }
                    })], w.prototype, "spatialReference", void 0);
                    k.__decorate([c.reader("spatialReference")], w.prototype, "readSpatialReference", null);
                    return w = k.__decorate([g.subclass("esri.geometry.Geometry")], w)
                })
        },
        "esri/core/accessorSupport/decorators/reader": function() {
            define(["exports", "../../object", "./property"], function(a, k, w) {
                a.reader =
                    function(t, r, f) {
                        let b, c;
                        void 0 === r || Array.isArray(r) ? (c = t, f = r, b = [void 0]) : (c = r, b = Array.isArray(t) ? t : [t]);
                        return (g, e) => {
                            const d = g.constructor.prototype;
                            b.forEach(h => {
                                h = w.propertyJSONMeta(g, h, c);
                                h.read && "object" !== typeof h.read && (h.read = {});
                                k.setDeepValue("read.reader", d[e], h);
                                f && (h.read.source = (h.read.source || []).concat(f))
                            })
                        }
                    };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/Point": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/has ../core/Logger ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/jsonMap ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/urlUtils ../core/uuid ../portal/support/resourceExtension ./support/spatialReferenceUtils ./SpatialReference ./Geometry ./support/offset ./support/pointUtils ./support/webMercatorUtils".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l, n, u, y, x, q, B) {
                    function z(E) {
                        return E && ("esri.geometry.SpatialReference" === E.declaredClass || null != E.wkid)
                    }
                    var v;
                    const A = [0, 0],
                        m = t.getLogger("esri.geometry.Point");
                    w = v = function(E) {
                        function C(...F) {
                            F = E.call(this, ...F) || this;
                            F.x = 0;
                            F.y = 0;
                            F.z = void 0;
                            F.m = void 0;
                            F.type = "point";
                            return F
                        }
                        a._inheritsLoose(C, E);
                        C.copy = function(F, D) {
                            D._set("x", F._get("x"));
                            D._set("y", F._get("y"));
                            D._set("z", F._get("z"));
                            D._set("m", F._get("m"));
                            F = F._get("spatialReference");
                            D._set("spatialReference",
                                Object.isFrozen(F) ? F : F.clone())
                        };
                        var G = C.prototype;
                        G.normalizeCtorArgs = function(F, D, H, I, Q) {
                            let P;
                            if (Array.isArray(F)) P = F, Q = D, F = P[0], D = P[1], H = P[2], I = P[3];
                            else if (F && "object" === typeof F) {
                                if (P = F, F = null != P.x ? P.x : P.longitude, D = null != P.y ? P.y : P.latitude, H = P.z, I = P.m, (Q = P.spatialReference) && "esri.geometry.SpatialReference" !== Q.declaredClass && (Q = new u(Q)), null != P.longitude || null != P.latitude) null == P.longitude ? m.warn(".longitude\x3d", "Latitude was defined without longitude") : null == P.latitude ? m.warn(".latitude\x3d",
                                    "Longitude was defined without latitude") : !P.declaredClass && Q && Q.isWebMercator && (D = B.lngLatToXY(P.longitude, P.latitude, A), F = D[0], D = D[1])
                            } else z(H) ? (Q = H, H = null) : z(I) && (Q = I, I = null);
                            F = {
                                x: F,
                                y: D
                            };
                            null == F.x && null != F.y ? m.warn(".y\x3d", "Y coordinate was defined without an X coordinate") : null == F.y && null != F.x && m.warn(".x\x3d", "X coordinate was defined without a Y coordinate");
                            null != Q && (F.spatialReference = Q);
                            null != H && (F.z = H);
                            null != I && (F.m = I);
                            return F
                        };
                        G.writeX = function(F, D, H) {
                            D[H] = isNaN(F) ? "NaN" : F
                        };
                        G.readX =
                            function(F) {
                                return "string" === typeof F ? NaN : F
                            };
                        G.clone = function() {
                            const F = new v;
                            F.x = this.x;
                            F.y = this.y;
                            F.z = this.z;
                            F.m = this.m;
                            F.spatialReference = this.spatialReference;
                            return F
                        };
                        G.copy = function(F) {
                            v.copy(F, this);
                            return this
                        };
                        G.equals = function(F) {
                            if (!F) return !1;
                            const {
                                x: D,
                                y: H,
                                z: I,
                                m: Q,
                                spatialReference: P
                            } = this, {
                                z: Y,
                                m: W
                            } = F;
                            let {
                                x: X,
                                y: ba,
                                spatialReference: V
                            } = F;
                            if (!P.equals(V))
                                if (P.isWebMercator && V.isWGS84)[X, ba] = B.lngLatToXY(X, ba), V = P;
                                else if (P.isWGS84 && V.isWebMercator)[X, ba] = B.xyToLngLat(X, ba), V = P;
                            else return !1;
                            return D === X && H === ba && I === Y && Q === W && P.wkid === V.wkid
                        };
                        G.offset = function(F, D, H) {
                            return x.offsetPoint(this, F, D, H)
                        };
                        G.normalize = function() {
                            if (!this.spatialReference) return this;
                            var F = n.getInfo(this.spatialReference);
                            if (!F) return this;
                            let D = this.x;
                            const [H, I] = F.valid;
                            F = 2 * I;
                            let Q;
                            D > I ? (Q = Math.ceil(Math.abs(D - I) / F), D -= Q * F) : D < H && (Q = Math.ceil(Math.abs(D - H) / F), D += Q * F);
                            this._set("x", D);
                            return this
                        };
                        G.distance = function(F) {
                            return q.distance(this, F)
                        };
                        G.toArray = function() {
                            const F = this.hasZ,
                                D = this.hasM;
                            return F &&
                                D ? [this.x, this.y, this.z, this.m] : F ? [this.x, this.y, this.z] : D ? [this.x, this.y, this.m] : [this.x, this.y]
                        };
                        G.toJSON = function(F) {
                            return this.write(null, F)
                        };
                        a._createClass(C, [{
                            key: "cache",
                            get: function() {
                                this.commitProperty("x");
                                this.commitProperty("y");
                                this.commitProperty("z");
                                this.commitProperty("m");
                                this.commitProperty("spatialReference");
                                return {}
                            }
                        }, {
                            key: "hasM",
                            get: function() {
                                return void 0 !== this.m
                            },
                            set: function(F) {
                                const D = void 0 !== this._get("m");
                                F !== D && (this._set("m", F ? 0 : void 0), this._set("hasM", F))
                            }
                        }, {
                            key: "hasZ",
                            get: function() {
                                return void 0 !== this.z
                            },
                            set: function(F) {
                                const D = void 0 !== this._get("z");
                                F !== D && (this._set("z", F ? 0 : void 0), this._set("hasZ", F))
                            }
                        }, {
                            key: "latitude",
                            get: function() {
                                const {
                                    spatialReference: F,
                                    x: D,
                                    y: H
                                } = this;
                                if (F) {
                                    if (F.isWebMercator) return B.xyToLngLat(D, H, A)[1];
                                    if (F.isGeographic) return H
                                }
                                return null
                            },
                            set: function(F) {
                                const {
                                    spatialReference: D,
                                    x: H
                                } = this;
                                D && (D.isWebMercator ? this._set("y", B.lngLatToXY(H, F, A)[1]) : D.isGeographic && this._set("y", F), this._set("latitude", F))
                            }
                        }, {
                            key: "longitude",
                            get: function() {
                                const {
                                    x: F,
                                    y: D,
                                    spatialReference: H
                                } = this;
                                if (H) {
                                    if (H.isWebMercator) return B.xyToLngLat(F, D, A)[0];
                                    if (H.isGeographic) return F
                                }
                                return NaN
                            },
                            set: function(F) {
                                const {
                                    y: D,
                                    spatialReference: H
                                } = this;
                                H && (H.isWebMercator ? this._set("x", B.lngLatToXY(F, D, A)[0]) : H.isGeographic && this._set("x", F), this._set("longitude", F))
                            }
                        }]);
                        return C
                    }(y);
                    k.__decorate([f.property({
                        readOnly: !0
                    })], w.prototype, "cache", null);
                    k.__decorate([f.property({
                        type: Boolean,
                        json: {
                            read: !1,
                            write: {
                                enabled: !1,
                                overridePolicy: null
                            }
                        }
                    })], w.prototype, "hasM", null);
                    k.__decorate([f.property({
                        type: Boolean,
                        json: {
                            read: !1,
                            write: {
                                enabled: !1,
                                overridePolicy: null
                            }
                        }
                    })], w.prototype, "hasZ", null);
                    k.__decorate([f.property({
                        type: Number
                    })], w.prototype, "latitude", null);
                    k.__decorate([f.property({
                        type: Number
                    })], w.prototype, "longitude", null);
                    k.__decorate([f.property({
                        type: Number,
                        json: {
                            type: [Number, String],
                            write: {
                                isRequired: !0,
                                allowNull: !0
                            }
                        }
                    }), b.cast(E => isNaN(E) ? E : r.ensureNumber(E))], w.prototype, "x", void 0);
                    k.__decorate([d.writer("x")], w.prototype, "writeX", null);
                    k.__decorate([g.reader("x")], w.prototype, "readX", null);
                    k.__decorate([f.property({
                        type: Number,
                        json: {
                            write: !0
                        }
                    })], w.prototype, "y", void 0);
                    k.__decorate([f.property({
                        type: Number,
                        json: {
                            write: {
                                overridePolicy() {
                                    return {
                                        enabled: this.hasZ
                                    }
                                }
                            }
                        }
                    })], w.prototype, "z", void 0);
                    k.__decorate([f.property({
                        type: Number,
                        json: {
                            write: {
                                overridePolicy() {
                                    return {
                                        enabled: this.hasM
                                    }
                                }
                            }
                        }
                    })], w.prototype, "m", void 0);
                    w = v = k.__decorate([e.subclass("esri.geometry.Point")], w);
                    w.prototype.toJSON.isDefaultToJSON = !0;
                    return w
                })
        },
        "esri/core/accessorSupport/decorators/cast": function() {
            define(["exports",
                "../ensureType", "../metadata"
            ], function(a, k, w) {
                function t(c) {
                    const g = "__accessorMetadata__" in c ? k.ensureType(c) : c;
                    return function(...e) {
                        e.push(g);
                        if ("number" === typeof e[2]) throw Error("Using @cast has parameter decorator is not supported since 4.16");
                        return r.apply(this, e)
                    }
                }

                function r(c, g, e, d) {
                    w.getOwnPropertyMetadata(c, g).cast = d
                }

                function f(c) {
                    return function(g, e) {
                        w.getOwnPropertyMetadata(g, c).cast = g[e]
                    }
                }
                const b = Object.prototype.toString;
                a.cast = function(...c) {
                    if (3 !== c.length || "string" !== typeof c[1]) {
                        if (1 ===
                            c.length && "[object Function]" === b.call(c[0])) return t(c[0]);
                        if (1 === c.length && "string" === typeof c[0]) return f(c[0])
                    }
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/offset": function() {
            define(["exports"], function(a) {
                a.offsetCoordsX = function(k, w) {
                    k[0] += w;
                    return k
                };
                a.offsetPoint = function(k, w, t, r) {
                    k.x += w;
                    k.y += t;
                    null != r && null != k.z && (k.z += r);
                    return k
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/pointUtils": function() {
            define(["exports"], function(a) {
                a.distance =
                    function(k, w) {
                        const t = k.x - w.x,
                            r = k.y - w.y;
                        k = k.hasZ && w.hasZ ? k.z - w.z : 0;
                        return Math.sqrt(t * t + r * r + k * k)
                    };
                a.squareDistance = function(k, w) {
                    const t = k.x - w.x,
                        r = k.y - w.y;
                    k = k.hasZ && w.hasZ ? k.z - w.z : 0;
                    return t * t + r * r + k * k
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/webMercatorUtils": function() {
            define(["exports", "../../core/lang", "./spatialReferenceUtils", "../SpatialReference", "./Ellipsoid"], function(a, k, w, t, r) {
                function f(d, h, p, l, n) {
                    n.spatialReference = p;
                    if ("x" in d && "x" in n)[n.x, n.y] = h(d.x,
                        d.y, e, l);
                    else if ("xmin" in d && "xmin" in n)[n.xmin, n.ymin] = h(d.xmin, d.ymin, e, l), [n.xmax, n.ymax] = h(d.xmax, d.ymax, e, l);
                    else if ("paths" in d && "paths" in n || "rings" in d && "rings" in n) {
                        d = "paths" in d ? d.paths : d.rings;
                        p = [];
                        for (let y = 0; y < d.length; y++) {
                            const x = d[y];
                            var u = [];
                            p.push(u);
                            for (let q = 0; q < x.length; q++) u.push(h(x[q][0], x[q][1], [0, 0], l)), 2 < x[q].length && u[q].push(x[q][2]), 3 < x[q].length && u[q].push(x[q][3])
                        }
                        "paths" in n ? n.paths = p : n.rings = p
                    } else if ("points" in d && "points" in n) {
                        d = d.points;
                        p = [];
                        for (u = 0; u < d.length; u++) p[u] =
                            h(d[u][0], d[u][1], [0, 0], l), 2 < d[u].length && p[u].push(d[u][2]), 3 < d[u].length && p[u].push(d[u][3]);
                        n.points = p
                    }
                    return n
                }

                function b(d, h) {
                    const p = d && (null != d.wkid || null != d.wkt ? d : d.spatialReference),
                        l = h && (null != h.wkid || null != h.wkt ? h : h.spatialReference);
                    return d && "type" in d && "mesh" === d.type || h && "type" in h && "mesh" === h.type || !p || !l ? !1 : w.equals(l, p) ? !0 : w.isWebMercator(l) && w.isWGS84(p) || w.isWebMercator(p) && w.isWGS84(l)
                }

                function c(d, h, p = [0, 0]) {
                    89.99999 < h ? h = 89.99999 : -89.99999 > h && (h = -89.99999);
                    h *= .017453292519943;
                    p[0] = .017453292519943 * d * r.earth.radius;
                    p[1] = r.earth.halfSemiMajorAxis * Math.log((1 + Math.sin(h)) / (1 - Math.sin(h)));
                    return p
                }

                function g(d, h, p = [0, 0], l = !1) {
                    d = d / r.earth.radius * 57.29577951308232;
                    p[0] = l ? d : d - 360 * Math.floor((d + 180) / 360);
                    p[1] = 57.29577951308232 * (Math.PI / 2 - 2 * Math.atan(Math.exp(-1 * h / r.earth.radius)));
                    return p
                }
                const e = [0, 0];
                a.canProject = b;
                a.geographicToWebMercator = function(d, h = !1, p = k.clone(d)) {
                    return f(d, c, t.WebMercator, h, p)
                };
                a.lngLatToXY = c;
                a.project = function(d, h) {
                    const p = d && d.spatialReference;
                    h =
                        h && (null != h.wkid || null != h.wkt ? h : h.spatialReference);
                    return b(p, h) ? w.equals(p, h) ? k.clone(d) : w.isWebMercator(h) ? f(d, c, t.WebMercator, !1, k.clone(d)) : w.isWGS84(h) ? f(d, g, t.WGS84, !1, k.clone(d)) : null : null
                };
                a.webMercatorToGeographic = function(d, h = !1, p = k.clone(d)) {
                    return f(d, g, t.WGS84, h, p)
                };
                a.x2lon = function(d) {
                    return d / r.earth.radius
                };
                a.xyToLngLat = g;
                a.y2lat = function(d) {
                    return Math.PI / 2 - 2 * Math.atan(Math.exp(-1 * d / r.earth.radius))
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/Ellipsoid": function() {
            define(["exports",
                "../../chunks/_rollupPluginBabelHelpers"
            ], function(a, k) {
                let w = function() {
                    function b(c, g, e, d) {
                        this.semiMajorAxis = c;
                        this.flattening = g;
                        this.outerAtmosphereRimWidth = e;
                        this.semiMinorAxis = this.semiMajorAxis * (1 - this.flattening);
                        this.halfSemiMajorAxis = this.semiMajorAxis / 2;
                        this.halfCircumference = Math.PI * this.semiMajorAxis;
                        this.metersPerDegree = this.halfCircumference / 180;
                        this.inverseFlattening = 1 / (1 - this.flattening) - 1;
                        this.eccentricitySquared = d ? d : 2 * this.flattening - this.flattening * this.flattening;
                        this.meanRadiusSemiAxes =
                            (2 * this.semiMajorAxis + this.semiMinorAxis) / 3
                    }
                    k._createClass(b, [{
                        key: "radius",
                        get: function() {
                            return this.semiMajorAxis
                        }
                    }]);
                    return b
                }();
                const t = new w(6378137, 1 / 298.257223563, 3E5, .006694379990137799),
                    r = new w(3396190, .005886007555525457, 23E4),
                    f = new w(1737400, 0, 0);
                a.Ellipsoid = w;
                a.earth = t;
                a.mars = r;
                a.moon = f;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/Extent": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/has ../core/maybe ../core/string ../core/Logger ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/jsonMap ../core/accessorSupport/decorators/subclass ../core/urlUtils ../core/uuid ../portal/support/resourceExtension ./support/spatialReferenceUtils ./SpatialReference ./Geometry ./support/webMercatorUtils ./Point ./support/contains ./support/intersects".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l, n, u, y, x, q, B) {
                    function z(A, m, E) {
                        return null == m ? E : null == E ? m : A(m, E)
                    }
                    var v;
                    w = v = function(A) {
                        function m(...C) {
                            C = A.call(this, ...C) || this;
                            C.type = "extent";
                            C.xmin = 0;
                            C.ymin = 0;
                            C.mmin = void 0;
                            C.zmin = void 0;
                            C.xmax = 0;
                            C.ymax = 0;
                            C.mmax = void 0;
                            C.zmax = void 0;
                            return C
                        }
                        a._inheritsLoose(m, A);
                        var E = m.prototype;
                        E.normalizeCtorArgs = function(C, G, F, D, H) {
                            return !C || "esri.geometry.SpatialReference" !== C.declaredClass && null == C.wkid ? "object" === typeof C ? (C.spatialReference = null == C.spatialReference ?
                                n.WGS84 : C.spatialReference, C) : {
                                xmin: C,
                                ymin: G,
                                xmax: F,
                                ymax: D,
                                spatialReference: null == H ? n.WGS84 : H
                            } : {
                                spatialReference: C,
                                xmin: 0,
                                ymin: 0,
                                xmax: 0,
                                ymax: 0
                            }
                        };
                        m.fromBounds = function(C, G) {
                            return new v({
                                xmin: C[0],
                                ymin: C[1],
                                xmax: C[2],
                                ymax: C[3],
                                spatialReference: G
                            })
                        };
                        E.centerAt = function(C) {
                            const G = this.center;
                            return null != C.z && this.hasZ ? this.offset(C.x - G.x, C.y - G.y, C.z - G.z) : this.offset(C.x - G.x, C.y - G.y)
                        };
                        E.clone = function() {
                            const C = new v;
                            C.xmin = this.xmin;
                            C.ymin = this.ymin;
                            C.xmax = this.xmax;
                            C.ymax = this.ymax;
                            C.spatialReference =
                                this.spatialReference;
                            null != this.zmin && (C.zmin = this.zmin, C.zmax = this.zmax);
                            null != this.mmin && (C.mmin = this.mmin, C.mmax = this.mmax);
                            return C
                        };
                        E.contains = function(C) {
                            if (!C) return !1;
                            const G = this.spatialReference,
                                F = C.spatialReference;
                            G && F && !G.equals(F) && y.canProject(G, F) && (C = G.isWebMercator ? y.geographicToWebMercator(C) : y.webMercatorToGeographic(C, !0));
                            return "point" === C.type ? q.extentContainsPoint(this, C) : "extent" === C.type ? q.extentContainsExtent(this, C) : !1
                        };
                        E.equals = function(C) {
                            if (!C) return !1;
                            const G = this.spatialReference,
                                F = C.spatialReference;
                            G && F && !G.equals(F) && y.canProject(G, F) && (C = G.isWebMercator ? y.geographicToWebMercator(C) : y.webMercatorToGeographic(C, !0));
                            return this.xmin === C.xmin && this.ymin === C.ymin && this.zmin === C.zmin && this.mmin === C.mmin && this.xmax === C.xmax && this.ymax === C.ymax && this.zmax === C.zmax && this.mmax === C.mmax
                        };
                        E.expand = function(C) {
                            C = .5 * (1 - C);
                            var G = this.width * C;
                            const F = this.height * C;
                            this.xmin += G;
                            this.ymin += F;
                            this.xmax -= G;
                            this.ymax -= F;
                            this.hasZ && (G = (this.zmax - this.zmin) * C, this.zmin += G, this.zmax -= G);
                            this.hasM &&
                                (C *= this.mmax - this.mmin, this.mmin += C, this.mmax -= C);
                            return this
                        };
                        E.intersects = function(C) {
                            if (t.isNone(C)) return !1;
                            "mesh" === C.type && (C = C.extent);
                            const G = this.spatialReference,
                                F = C.spatialReference;
                            G && F && !G.equals(F) && y.canProject(G, F) && (C = G.isWebMercator ? y.geographicToWebMercator(C) : y.webMercatorToGeographic(C, !0));
                            return B.getExtentIntersector(C.type)(this, C)
                        };
                        E.normalize = function() {
                            const C = this._normalize(!1, !0);
                            return Array.isArray(C) ? C : [C]
                        };
                        E.offset = function(C, G, F) {
                            this.xmin += C;
                            this.ymin += G;
                            this.xmax +=
                                C;
                            this.ymax += G;
                            null != F && (this.zmin += F, this.zmax += F);
                            return this
                        };
                        E.shiftCentralMeridian = function() {
                            return this._normalize(!0)
                        };
                        E.union = function(C) {
                            this.xmin = Math.min(this.xmin, C.xmin);
                            this.ymin = Math.min(this.ymin, C.ymin);
                            this.xmax = Math.max(this.xmax, C.xmax);
                            this.ymax = Math.max(this.ymax, C.ymax);
                            if (this.hasZ || C.hasZ) this.zmin = z(Math.min, this.zmin, C.zmin), this.zmax = z(Math.max, this.zmax, C.zmax);
                            if (this.hasM || C.hasM) this.mmin = z(Math.min, this.mmin, C.mmin), this.mmax = z(Math.max, this.mmax, C.mmax);
                            return this
                        };
                        E.intersection = function(C) {
                            if (!this.intersects(C)) return null;
                            this.xmin = Math.max(this.xmin, C.xmin);
                            this.ymin = Math.max(this.ymin, C.ymin);
                            this.xmax = Math.min(this.xmax, C.xmax);
                            this.ymax = Math.min(this.ymax, C.ymax);
                            if (this.hasZ || C.hasZ) this.zmin = z(Math.max, this.zmin, C.zmin), this.zmax = z(Math.min, this.zmax, C.zmax);
                            if (this.hasM || C.hasM) this.mmin = z(Math.max, this.mmin, C.mmin), this.mmax = z(Math.min, this.mmax, C.mmax);
                            return this
                        };
                        E.toJSON = function(C) {
                            return this.write(null, C)
                        };
                        E._shiftCM = function(C = l.getInfo(this.spatialReference)) {
                            if (!C ||
                                !this.spatialReference) return this;
                            const G = this.spatialReference,
                                F = this._getCM(C);
                            if (F) {
                                const D = G.isWebMercator ? y.webMercatorToGeographic(F) : F;
                                this.xmin -= F.x;
                                this.xmax -= F.x;
                                G.isWebMercator || (D.x = this._normalizeX(D.x, C).x);
                                this.spatialReference = new n(r.replace(G.isWGS84 ? C.altTemplate : C.wkTemplate, {
                                    Central_Meridian: D.x
                                }))
                            }
                            return this
                        };
                        E._getCM = function(C) {
                            let G = null;
                            const [F, D] = C.valid;
                            C = this.xmin;
                            const H = this.xmax;
                            C >= F && C <= D && H >= F && H <= D || (G = this.center);
                            return G
                        };
                        E._normalize = function(C, G, F) {
                            const D =
                                this.spatialReference;
                            if (!D) return this;
                            F = F || l.getInfo(D);
                            if (!F) return this;
                            const H = this._getParts(F).map(P => P.extent);
                            if (2 > H.length) return H[0] || this;
                            if (2 < H.length) return C ? this._shiftCM(F) : this.set({
                                xmin: F.valid[0],
                                xmax: F.valid[1]
                            });
                            if (C) return this._shiftCM(F);
                            if (G) return H;
                            let I = !0,
                                Q = !0;
                            H.forEach(P => {
                                P.hasZ || (I = !1);
                                P.hasM || (Q = !1)
                            });
                            return {
                                rings: H.map(P => {
                                    const Y = [
                                        [P.xmin, P.ymin],
                                        [P.xmin, P.ymax],
                                        [P.xmax, P.ymax],
                                        [P.xmax, P.ymin],
                                        [P.xmin, P.ymin]
                                    ];
                                    if (I) {
                                        var W = (P.zmax - P.zmin) / 2;
                                        for (let X = 0; X < Y.length; X++) Y[X].push(W)
                                    }
                                    if (Q)
                                        for (P =
                                            (P.mmax - P.mmin) / 2, W = 0; W < Y.length; W++) Y[W].push(P);
                                    return Y
                                }),
                                hasZ: I,
                                hasM: Q,
                                spatialReference: D
                            }
                        };
                        E._getParts = function(C) {
                            let G = this.cache._parts;
                            if (!G) {
                                G = [];
                                const {
                                    ymin: W,
                                    ymax: X,
                                    spatialReference: ba
                                } = this;
                                var F = this.width,
                                    D = this.xmin,
                                    H = this.xmax;
                                C = C || l.getInfo(ba);
                                const [V, ca] = C.valid;
                                var I = this._normalizeX(this.xmin, C);
                                var Q = I.x,
                                    P = I.frameId;
                                I = this._normalizeX(this.xmax, C);
                                C = I.x;
                                I = I.frameId;
                                var Y = Q === C && 0 < F;
                                if (F > 2 * ca) {
                                    F = new v(D < H ? Q : C, W, ca, X, ba);
                                    D = new v(V, W, D < H ? C : Q, X, ba);
                                    H = new v(0, W, ca, X, ba);
                                    Q = new v(V,
                                        W, 0, X, ba);
                                    C = [];
                                    Y = [];
                                    F.contains(H) && C.push(P);
                                    F.contains(Q) && Y.push(P);
                                    D.contains(H) && C.push(I);
                                    D.contains(Q) && Y.push(I);
                                    for (let ea = P + 1; ea < I; ea++) C.push(ea), Y.push(ea);
                                    G.push({
                                        extent: F,
                                        frameIds: [P]
                                    }, {
                                        extent: D,
                                        frameIds: [I]
                                    }, {
                                        extent: H,
                                        frameIds: C
                                    }, {
                                        extent: Q,
                                        frameIds: Y
                                    })
                                } else Q > C || Y ? G.push({
                                    extent: new v(Q, W, ca, X, ba),
                                    frameIds: [P]
                                }, {
                                    extent: new v(V, W, C, X, ba),
                                    frameIds: [I]
                                }) : G.push({
                                    extent: new v(Q, W, C, X, ba),
                                    frameIds: [P]
                                });
                                this.cache._parts = G
                            }
                            I = this.hasZ;
                            F = this.hasM;
                            if (I || F)
                                for (P = {}, I && (P.zmin = this.zmin, P.zmax =
                                        this.zmax), F && (P.mmin = this.mmin, P.mmax = this.mmax), I = 0; I < G.length; I++) G[I].extent.set(P);
                            return G
                        };
                        E._normalizeX = function(C, G) {
                            const [F, D] = G.valid;
                            G = 2 * D;
                            var H = 0;
                            C > D ? (H = Math.ceil(Math.abs(C - D) / G), C -= H * G) : C < F && (H = Math.ceil(Math.abs(C - F) / G), C += H * G, H = -H);
                            return {
                                x: C,
                                frameId: H
                            }
                        };
                        a._createClass(m, [{
                                key: "cache",
                                get: function() {
                                    this.commitProperty("xmin");
                                    this.commitProperty("ymin");
                                    this.commitProperty("zmin");
                                    this.commitProperty("mmin");
                                    this.commitProperty("xmax");
                                    this.commitProperty("ymax");
                                    this.commitProperty("zmax");
                                    this.commitProperty("mmax");
                                    this.commitProperty("spatialReference");
                                    return {}
                                }
                            }, {
                                key: "center",
                                get: function() {
                                    const C = new x({
                                        x: .5 * (this.xmin + this.xmax),
                                        y: .5 * (this.ymin + this.ymax),
                                        spatialReference: this.spatialReference
                                    });
                                    this.hasZ && (C.z = .5 * (this.zmin + this.zmax));
                                    this.hasM && (C.m = .5 * (this.mmin + this.mmax));
                                    return C
                                }
                            }, {
                                key: "extent",
                                get: function() {
                                    return this.clone()
                                }
                            }, {
                                key: "hasM",
                                get: function() {
                                    return null != this.mmin && null != this.mmax
                                }
                            }, {
                                key: "hasZ",
                                get: function() {
                                    return null != this.zmin && null != this.zmax
                                }
                            },
                            {
                                key: "height",
                                get: function() {
                                    return Math.abs(this.ymax - this.ymin)
                                }
                            }, {
                                key: "width",
                                get: function() {
                                    return Math.abs(this.xmax - this.xmin)
                                }
                            }
                        ]);
                        return m
                    }(u);
                    k.__decorate([c.property({
                        readOnly: !0
                    })], w.prototype, "cache", null);
                    k.__decorate([c.property({
                        readOnly: !0
                    })], w.prototype, "center", null);
                    k.__decorate([c.property({
                        readOnly: !0
                    })], w.prototype, "extent", null);
                    k.__decorate([c.property({
                        readOnly: !0,
                        json: {
                            write: {
                                enabled: !1,
                                overridePolicy: null
                            }
                        }
                    })], w.prototype, "hasM", null);
                    k.__decorate([c.property({
                        readOnly: !0,
                        json: {
                            write: {
                                enabled: !1,
                                overridePolicy: null
                            }
                        }
                    })], w.prototype, "hasZ", null);
                    k.__decorate([c.property({
                        readOnly: !0
                    })], w.prototype, "height", null);
                    k.__decorate([c.property({
                        readOnly: !0
                    })], w.prototype, "width", null);
                    k.__decorate([c.property({
                        type: Number,
                        json: {
                            type: [Number, String],
                            write: {
                                enabled: !0,
                                allowNull: !0
                            }
                        }
                    })], w.prototype, "xmin", void 0);
                    k.__decorate([c.property({
                        type: Number,
                        json: {
                            write: !0
                        }
                    })], w.prototype, "ymin", void 0);
                    k.__decorate([c.property({
                            type: Number,
                            json: {
                                origins: {
                                    "web-scene": {
                                        write: !1
                                    }
                                },
                                write: {
                                    overridePolicy() {
                                        return {
                                            enabled: this.hasM
                                        }
                                    }
                                }
                            }
                        })],
                        w.prototype, "mmin", void 0);
                    k.__decorate([c.property({
                        type: Number,
                        json: {
                            origins: {
                                "web-scene": {
                                    write: !1
                                }
                            },
                            write: {
                                overridePolicy() {
                                    return {
                                        enabled: this.hasZ
                                    }
                                }
                            }
                        }
                    })], w.prototype, "zmin", void 0);
                    k.__decorate([c.property({
                        type: Number,
                        json: {
                            write: !0
                        }
                    })], w.prototype, "xmax", void 0);
                    k.__decorate([c.property({
                        type: Number,
                        json: {
                            write: !0
                        }
                    })], w.prototype, "ymax", void 0);
                    k.__decorate([c.property({
                            type: Number,
                            json: {
                                origins: {
                                    "web-scene": {
                                        write: !1
                                    }
                                },
                                write: {
                                    overridePolicy() {
                                        return {
                                            enabled: this.hasM
                                        }
                                    }
                                }
                            }
                        })], w.prototype, "mmax",
                        void 0);
                    k.__decorate([c.property({
                        type: Number,
                        json: {
                            origins: {
                                "web-scene": {
                                    write: !1
                                }
                            },
                            write: {
                                overridePolicy() {
                                    return {
                                        enabled: this.hasZ
                                    }
                                }
                            }
                        }
                    })], w.prototype, "zmax", void 0);
                    w = v = k.__decorate([e.subclass("esri.geometry.Extent")], w);
                    w.prototype.toJSON.isDefaultToJSON = !0;
                    return w
                })
        },
        "esri/geometry/support/contains": function() {
            define(["exports"], function(a) {
                function k(b, c) {
                    return w(b, c[0], c[1])
                }

                function w(b, c, g, e) {
                    return c >= b.xmin && c <= b.xmax && g >= b.ymin && g <= b.ymax ? null != e && b.hasZ ? e >= b.zmin && e <= b.zmax : !0 : !1
                }

                function t(b, c) {
                    if (b = b.rings)
                        if (Array.isArray(b[0][0])) {
                            var g = !1;
                            for (let e = 0, d = b.length; e < d; e++) g = r(g, b[e], c);
                            c = g
                        } else c = r(!1, b, c);
                    else c = !1;
                    return c
                }

                function r(b, c, g) {
                    const [e, d] = g;
                    g = 0;
                    for (let h = 0, p = c.length; h < p; h++) {
                        g++;
                        g === p && (g = 0);
                        const [l, n] = c[h], [u, y] = c[g];
                        (n < d && y >= d || y < d && n >= d) && l + (d - n) / (y - n) * (u - l) < e && (b = !b)
                    }
                    return b
                }
                const f = [0, 0];
                a.extentContainsCoords2D = k;
                a.extentContainsCoords3D = function(b, c) {
                    return w(b, c[0], c[1], c[2])
                };
                a.extentContainsExtent = function(b, c) {
                    const {
                        xmin: g,
                        ymin: e,
                        zmin: d,
                        xmax: h,
                        ymax: p,
                        zmax: l
                    } = c;
                    return b.hasZ && c.hasZ ? w(b, g, e, d) && w(b, g, p, d) && w(b, h, p, d) && w(b, h, e, d) && w(b, g, e, l) && w(b, g, p, l) && w(b, h, p, l) && w(b, h, e, l) : w(b, g, e) && w(b, g, p) && w(b, h, p) && w(b, h, e)
                };
                a.extentContainsMultipoint = function(b, c) {
                    if (!c.points || c.points.length) return !1;
                    for (const g of c.points)
                        if (!k(b, g)) return !1;
                    return !0
                };
                a.extentContainsPoint = function(b, c) {
                    return w(b, c.x, c.y, c.z)
                };
                a.polygonContainsCoords = t;
                a.polygonContainsPoint = function(b, c) {
                    f[1] = c.y;
                    f[0] = c.x;
                    return t(b, f)
                };
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/intersects": function() {
            define(["exports", "./contains"], function(a, k) {
                function w(y, x) {
                    return k.extentContainsPoint(y, x)
                }

                function t(y, x) {
                    var q = y.hasZ && x.hasZ;
                    if (y.xmin <= x.xmin) {
                        var B = x.xmin;
                        if (y.xmax < B) return !1
                    } else if (B = y.xmin, x.xmax < B) return !1;
                    if (y.ymin <= x.ymin) {
                        if (B = x.ymin, y.ymax < B) return !1
                    } else if (B = y.ymin, x.ymax < B) return !1;
                    if (q && x.hasZ)
                        if (y.zmin <= x.zmin) {
                            if (q = x.zmin, y.zmax < q) return !1
                        } else if (q = y.zmin, x.zmax < q) return !1;
                    return !0
                }

                function r(y, x) {
                    const {
                        points: q,
                        hasZ: B
                    } = x;
                    x = B ? k.extentContainsCoords3D : k.extentContainsCoords2D;
                    for (const z of q)
                        if (x(y, z)) return !0;
                    return !1
                }

                function f(y, x) {
                    e[0] = y.xmin;
                    e[1] = y.ymax;
                    d[0] = y.xmax;
                    d[1] = y.ymax;
                    h[0] = y.xmin;
                    h[1] = y.ymin;
                    p[0] = y.xmax;
                    p[1] = y.ymin;
                    for (var q of l)
                        if (k.polygonContainsCoords(x, q)) return !0;
                    for (const B of x.rings)
                        if (B.length) {
                            x = B[0];
                            if (k.extentContainsCoords2D(y, x)) return !0;
                            for (q = 1; q < B.length; q++) {
                                const z = B[q];
                                if (k.extentContainsCoords2D(y, z) || c(x, z, n)) return !0;
                                x = z
                            }
                        }
                    return !1
                }

                function b(y, x) {
                    e[0] = y.xmin;
                    e[1] = y.ymax;
                    d[0] = y.xmax;
                    d[1] = y.ymax;
                    h[0] = y.xmin;
                    h[1] = y.ymin;
                    p[0] = y.xmax;
                    p[1] = y.ymin;
                    x = x.paths;
                    for (const q of x) {
                        if (!x.length) continue;
                        let B = q[0];
                        if (k.extentContainsCoords2D(y, B)) return !0;
                        for (let z = 1; z < q.length; z++) {
                            const v = q[z];
                            if (k.extentContainsCoords2D(y, v) || c(B, v, n)) return !0;
                            B = v
                        }
                    }
                    return !1
                }

                function c(y, x, q) {
                    for (let B = 0; B < q.length; B++)
                        if (g(y, x, q[B][0], q[B][1])) return !0;
                    return !1
                }

                function g(y, x, q, B, z) {
                    const [v, A] = y, [m, E] = x, [C, G] = q, [F, D] = B;
                    var H = F - C;
                    y = v - C;
                    x = m - v;
                    const I = D - G;
                    q = A - G;
                    B = E - A;
                    const Q = I * x - H * B;
                    if (0 === Q) return !1;
                    H = (H * q - I * y) / Q;
                    y = (x * q - B * y) / Q;
                    return 0 <= H && 1 >= H && 0 <= y && 1 >= y ? (z && (z[0] = v + H * (m - v), z[1] = A + H * (E - A)), !0) : !1
                }
                const e = [0, 0],
                    d = [0, 0],
                    h = [0, 0],
                    p = [0, 0],
                    l = [e, d, h, p],
                    n = [
                        [h, e],
                        [e, d],
                        [d, p],
                        [p, h]
                    ],
                    u = [0, 0];
                a.extentIntersectsExtent = t;
                a.extentIntersectsMultipoint = r;
                a.extentIntersectsPoint = w;
                a.extentIntersectsPolygon = f;
                a.extentIntersectsPolyline = b;
                a.getExtentIntersector = function(y) {
                    switch (y) {
                        case "esriGeometryEnvelope":
                        case "extent":
                            return t;
                        case "esriGeometryMultipoint":
                        case "multipoint":
                            return r;
                        case "esriGeometryPoint":
                        case "point":
                            return w;
                        case "esriGeometryPolygon":
                        case "polygon":
                            return f;
                        case "esriGeometryPolyline":
                        case "polyline":
                            return b;
                        case "mesh":
                            return t
                    }
                };
                a.isSelfIntersecting = function(y) {
                    for (let E = 0; E < y.length; E++) {
                        const C = y[E];
                        for (var x = 0; x < C.length - 1; x++) {
                            var q = C[x],
                                B = C[x + 1];
                            for (var z = E + 1; z < y.length; z++)
                                for (var v = 0; v < y[z].length - 1; v++) {
                                    var A = y[z][v],
                                        m = y[z][v + 1];
                                    if (g(q, B, A, m, u) && !(u[0] === q[0] && u[1] === q[1] || u[0] === A[0] && u[1] === A[1] || u[0] === B[0] && u[1] === B[1] || u[0] === m[0] && u[1] === m[1])) return !0
                                }
                        }
                        x = C.length;
                        if (!(4 >= x))
                            for (q = 0; q <
                                x - 3; q++)
                                for (B = x - 1, 0 === q && (B = x - 2), z = C[q], v = C[q + 1], A = q + 2; A < B; A++) {
                                    m = C[A];
                                    const G = C[A + 1];
                                    if (g(z, v, m, G, u) && !(u[0] === z[0] && u[1] === z[1] || u[0] === m[0] && u[1] === m[1] || u[0] === v[0] && u[1] === v[1] || u[0] === G[0] && u[1] === G[1])) return !0
                                }
                    }
                    return !1
                };
                a.segmentIntersects = g;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/Multipoint": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/has ../core/lang ../core/Logger ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/jsonMap ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/urlUtils ../core/uuid ../portal/support/resourceExtension ./Geometry ./Point ./Extent ./support/zmUtils".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l, n, u, y) {
                    function x(B) {
                        return (z, v) => null == z ? v : null == v ? z : B(z, v)
                    }
                    var q;
                    w = q = function(B) {
                        function z(...A) {
                            A = B.call(this, ...A) || this;
                            A.points = [];
                            A.type = "multipoint";
                            return A
                        }
                        a._inheritsLoose(z, B);
                        var v = z.prototype;
                        v.normalizeCtorArgs = function(A, m) {
                            if (!A && !m) return null;
                            const E = {};
                            Array.isArray(A) ? (E.points = A, E.spatialReference = m) : !A || "esri.geometry.SpatialReference" !== A.declaredClass && null == A.wkid ? (A.points && (E.points = A.points), A.spatialReference && (E.spatialReference =
                                A.spatialReference), A.hasZ && (E.hasZ = A.hasZ), A.hasM && (E.hasM = A.hasM)) : E.spatialReference = A;
                            if (A = E.points && E.points[0]) void 0 === E.hasZ && void 0 === E.hasM ? (E.hasZ = 2 < A.length, E.hasM = !1) : void 0 === E.hasZ ? E.hasZ = 3 < A.length : void 0 === E.hasM && (E.hasM = 3 < A.length);
                            return E
                        };
                        v.writePoints = function(A, m) {
                            m.points = t.clone(this.points)
                        };
                        v.addPoint = function(A) {
                            y.updateSupportFromPoint(this, A);
                            Array.isArray(A) ? this.points.push(A) : this.points.push(A.toArray());
                            this.notifyChange("points");
                            return this
                        };
                        v.clone = function() {
                            const A = {
                                points: t.clone(this.points),
                                spatialReference: this.spatialReference
                            };
                            this.hasZ && (A.hasZ = !0);
                            this.hasM && (A.hasM = !0);
                            return new q(A)
                        };
                        v.getPoint = function(A) {
                            if (!this._validateInputs(A)) return null;
                            A = this.points[A];
                            const m = {
                                x: A[0],
                                y: A[1],
                                spatialReference: this.spatialReference
                            };
                            let E = 2;
                            this.hasZ && (m.z = A[2], E = 3);
                            this.hasM && (m.m = A[E]);
                            return new n(m)
                        };
                        v.removePoint = function(A) {
                            if (!this._validateInputs(A)) return null;
                            A = new n(this.points.splice(A, 1)[0], this.spatialReference);
                            this.notifyChange("points");
                            return A
                        };
                        v.setPoint = function(A, m) {
                            if (!this._validateInputs(A)) return this;
                            y.updateSupportFromPoint(this, m);
                            Array.isArray(m) || (m = m.toArray());
                            this.points[A] = m;
                            this.notifyChange("points");
                            return this
                        };
                        v.toJSON = function(A) {
                            return this.write(null, A)
                        };
                        v._validateInputs = function(A) {
                            return null != A && 0 <= A && A < this.points.length
                        };
                        a._createClass(z, [{
                            key: "cache",
                            get: function() {
                                this.commitProperty("points");
                                this.commitProperty("hasZ");
                                this.commitProperty("hasM");
                                this.commitProperty("spatialReference");
                                return {}
                            }
                        }, {
                            key: "extent",
                            get: function() {
                                const A = this.points;
                                if (!A.length) return null;
                                const m = new u,
                                    E = this.hasZ,
                                    C = this.hasM,
                                    G = E ? 3 : 2;
                                var F = A[0];
                                const D = x(Math.min),
                                    H = x(Math.max);
                                let [I, Q] = F, [P, Y] = F, W, X, ba, V;
                                for (let ca = 0, ea = A.length; ca < ea; ca++) {
                                    F = A[ca];
                                    const [sa, ma] = F;
                                    I = D(I, sa);
                                    Q = D(Q, ma);
                                    P = H(P, sa);
                                    Y = H(Y, ma);
                                    if (E && 2 < F.length) {
                                        const ra = F[2];
                                        W = D(W, ra);
                                        ba = H(ba, ra)
                                    }
                                    C && F.length > G && (F = F[G], X = D(X, F), V = H(V, F))
                                }
                                m.xmin = I;
                                m.ymin = Q;
                                m.xmax = P;
                                m.ymax = Y;
                                m.spatialReference = this.spatialReference;
                                E ? (m.zmin = W, m.zmax = ba) : (m.zmin = null, m.zmax = null);
                                C ? (m.mmin = X, m.mmax = V) : (m.mmin = null, m.mmax = null);
                                return m
                            }
                        }]);
                        return z
                    }(l);
                    k.__decorate([b.property({
                        readOnly: !0
                    })], w.prototype, "cache", null);
                    k.__decorate([b.property()], w.prototype, "extent", null);
                    k.__decorate([b.property({
                        type: [
                            [Number]
                        ],
                        json: {
                            write: {
                                isRequired: !0
                            }
                        }
                    })], w.prototype, "points", void 0);
                    k.__decorate([e.writer("points")], w.prototype, "writePoints", null);
                    w = q = k.__decorate([g.subclass("esri.geometry.Multipoint")], w);
                    w.prototype.toJSON.isDefaultToJSON = !0;
                    return w
                })
        },
        "esri/geometry/support/zmUtils": function() {
            define(["exports"],
                function(a) {
                    a.updateSupportFromPoint = function(k, w, t = !1) {
                        let {
                            hasM: r,
                            hasZ: f
                        } = k;
                        Array.isArray(w) ? 4 !== w.length || r || f ? 3 === w.length && t && !r ? (f = !0, r = !1) : 3 === w.length && r && f && (f = r = !1) : f = r = !0 : (f = !f && w.hasZ && (!r || w.hasM), r = !r && w.hasM && (!f || w.hasZ));
                        k.hasZ = f;
                        k.hasM = r
                    };
                    Object.defineProperty(a, "__esModule", {
                        value: !0
                    })
                })
        },
        "esri/geometry/Polygon": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/has ../core/lang ../core/Logger ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/jsonMap ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/urlUtils ../core/uuid ../portal/support/resourceExtension ./SpatialReference ./Geometry ./support/webMercatorUtils ./Point ./support/contains ./support/intersects ./Extent ./support/zmUtils ./support/coordsUtils ./support/centroid ./support/extentUtils".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l, n, u, y, x, q, B, z, v, A, m) {
                    var E;
                    w = E = function(C) {
                        function G(...D) {
                            D = C.call(this, ...D) || this;
                            D.rings = [];
                            D.type = "polygon";
                            return D
                        }
                        a._inheritsLoose(G, C);
                        G.fromExtent = function(D) {
                            var H = D.clone().normalize();
                            D = D.spatialReference;
                            let I = !1,
                                Q = !1;
                            H.map(P => {
                                P.hasZ && (I = !0);
                                P.hasM && (Q = !0)
                            });
                            H = {
                                rings: H.map(function(P) {
                                    const Y = [
                                        [P.xmin, P.ymin],
                                        [P.xmin, P.ymax],
                                        [P.xmax, P.ymax],
                                        [P.xmax, P.ymin],
                                        [P.xmin, P.ymin]
                                    ];
                                    if (I && P.hasZ) {
                                        var W = P.zmin + .5 * (P.zmax - P.zmin);
                                        for (let X = 0; X < Y.length; X++) Y[X].push(W)
                                    }
                                    if (Q &&
                                        P.hasM)
                                        for (P = P.mmin + .5 * (P.mmax - P.mmin), W = 0; W < Y.length; W++) Y[W].push(P);
                                    return Y
                                }),
                                spatialReference: D
                            };
                            I && (H.hasZ = !0);
                            Q && (H.hasM = !0);
                            return new E(H)
                        };
                        var F = G.prototype;
                        F.normalizeCtorArgs = function(D, H) {
                            let I = null,
                                Q, P, Y = null;
                            D && !Array.isArray(D) ? (I = D.rings ? D.rings : null, H || (D.spatialReference ? H = D.spatialReference : D.rings || (H = D)), Q = D.hasZ, P = D.hasM) : I = D;
                            I = I || [];
                            H = H || l.WGS84;
                            I.length && I[0] && null != I[0][0] && "number" === typeof I[0][0] && (I = [I]);
                            if (Y = I[0] && I[0][0]) void 0 === Q && void 0 === P ? (Q = 2 < Y.length, P = !1) : void 0 ===
                                Q ? Q = !P && 3 < Y.length : void 0 === P && (P = !Q && 3 < Y.length);
                            return {
                                rings: I,
                                spatialReference: H,
                                hasZ: Q,
                                hasM: P
                            }
                        };
                        F.writeRings = function(D, H) {
                            H.rings = t.clone(this.rings)
                        };
                        F.addRing = function(D) {
                            if (D) {
                                var H = this.rings,
                                    I = H.length;
                                if (Array.isArray(D[0])) H[I] = D.concat();
                                else {
                                    const Q = [];
                                    for (let P = 0, Y = D.length; P < Y; P++) Q[P] = D[P].toArray();
                                    H[I] = Q
                                }
                                this.notifyChange("rings");
                                return this
                            }
                        };
                        F.clone = function() {
                            const D = new E;
                            D.spatialReference = this.spatialReference;
                            D.rings = t.clone(this.rings);
                            D.hasZ = this.hasZ;
                            D.hasM = this.hasM;
                            return D
                        };
                        F.contains = function(D) {
                            if (!D) return !1;
                            u.canProject(D, this.spatialReference) && (D = u.project(D, this.spatialReference));
                            return x.polygonContainsPoint(this, D)
                        };
                        F.isClockwise = function(D) {
                            D = Array.isArray(D[0]) ? D : D.map(H => this.hasZ ? this.hasM ? [H.x, H.y, H.z, H.m] : [H.x, H.y, H.z] : [H.x, H.y]);
                            return v.isClockwise(D, this.hasM, this.hasZ)
                        };
                        F.getPoint = function(D, H) {
                            if (!this._validateInputs(D, H)) return null;
                            D = this.rings[D][H];
                            H = this.hasZ;
                            const I = this.hasM;
                            return H && !I ? new y(D[0], D[1], D[2], void 0, this.spatialReference) :
                                I && !H ? new y(D[0], D[1], void 0, D[2], this.spatialReference) : H && I ? new y(D[0], D[1], D[2], D[3], this.spatialReference) : new y(D[0], D[1], this.spatialReference)
                        };
                        F.insertPoint = function(D, H, I) {
                            if (!this._validateInputs(D, H, !0)) return this;
                            z.updateSupportFromPoint(this, I);
                            Array.isArray(I) || (I = I.toArray());
                            this.rings[D].splice(H, 0, I);
                            this.notifyChange("rings");
                            return this
                        };
                        F.removePoint = function(D, H) {
                            if (!this._validateInputs(D, H)) return null;
                            D = new y(this.rings[D].splice(H, 1)[0], this.spatialReference);
                            this.notifyChange("rings");
                            return D
                        };
                        F.removeRing = function(D) {
                            if (!this._validateInputs(D, null)) return null;
                            D = this.rings.splice(D, 1)[0];
                            const H = this.spatialReference;
                            D = D.map(I => new y(I, H));
                            this.notifyChange("rings");
                            return D
                        };
                        F.setPoint = function(D, H, I) {
                            if (!this._validateInputs(D, H)) return this;
                            z.updateSupportFromPoint(this, I);
                            Array.isArray(I) || (I = I.toArray());
                            this.rings[D][H] = I;
                            this.notifyChange("rings");
                            return this
                        };
                        F._validateInputs = function(D, H, I = !1) {
                            return null == D || 0 > D || D >= this.rings.length || null != H && (D = this.rings[D], I &&
                                (0 > H || H > D.length) || !I && (0 > H || H >= D.length)) ? !1 : !0
                        };
                        F.toJSON = function(D) {
                            return this.write(null, D)
                        };
                        a._createClass(G, [{
                            key: "cache",
                            get: function() {
                                this.commitProperty("rings");
                                this.commitProperty("hasZ");
                                this.commitProperty("hasM");
                                this.commitProperty("spatialReference");
                                return {}
                            }
                        }, {
                            key: "centroid",
                            get: function() {
                                const D = A.polygonCentroid(this);
                                if (!D || isNaN(D[0]) || isNaN(D[1]) || this.hasZ && isNaN(D[2])) return null;
                                const H = new y;
                                H.x = D[0];
                                H.y = D[1];
                                H.spatialReference = this.spatialReference;
                                this.hasZ && (H.z = D[2]);
                                return H
                            }
                        }, {
                            key: "extent",
                            get: function() {
                                const {
                                    spatialReference: D
                                } = this;
                                var H = m.getPolygonExtent(this);
                                if (!H) return null;
                                H = new B(H);
                                H.spatialReference = D;
                                return H
                            }
                        }, {
                            key: "isSelfIntersecting",
                            get: function() {
                                return q.isSelfIntersecting(this.rings)
                            }
                        }]);
                        return G
                    }(n);
                    k.__decorate([b.property({
                        readOnly: !0
                    })], w.prototype, "cache", null);
                    k.__decorate([b.property({
                        readOnly: !0
                    })], w.prototype, "centroid", null);
                    k.__decorate([b.property({
                        readOnly: !0
                    })], w.prototype, "extent", null);
                    k.__decorate([b.property({
                            readOnly: !0
                        })],
                        w.prototype, "isSelfIntersecting", null);
                    k.__decorate([b.property({
                        type: [
                            [
                                [Number]
                            ]
                        ],
                        json: {
                            write: {
                                isRequired: !0
                            }
                        }
                    })], w.prototype, "rings", void 0);
                    k.__decorate([e.writer("rings")], w.prototype, "writeRings", null);
                    w = E = k.__decorate([g.subclass("esri.geometry.Polygon")], w);
                    w.prototype.toJSON.isDefaultToJSON = !0;
                    return w
                })
        },
        "esri/geometry/support/coordsUtils": function() {
            define(["exports", "./spatialReferenceUtils"], function(a, k) {
                function w(b, c) {
                    const g = c[0] - b[0],
                        e = c[1] - b[1];
                    return 2 < b.length && 2 < c.length ? (b = b[2] -
                        c[2], Math.sqrt(g * g + e * e + b * b)) : Math.sqrt(g * g + e * e)
                }

                function t(b, c, g) {
                    const e = b[0] + g * (c[0] - b[0]),
                        d = b[1] + g * (c[1] - b[1]);
                    return 2 < b.length && 2 < c.length ? [e, d, b[2] + g * (c[2] - b[2])] : [e, d]
                }

                function r(b, c, g) {
                    const e = b.length;
                    let d = 0,
                        h = 0,
                        p = 0;
                    for (let l = 0; l < e; l++) {
                        const n = b[l],
                            u = b[(l + 1) % e];
                        let y = 2;
                        d += n[0] * u[1] - u[0] * n[1];
                        2 < n.length && 2 < u.length && g && (h += n[0] * u[2] - u[0] * n[2], y = 3);
                        n.length > y && u.length > y && c && (p += n[0] * u[y] - u[0] * n[y])
                    }
                    return 0 >= d && 0 >= h && 0 >= p
                }

                function f(b, c) {
                    if (c = k.getInfo(c)) {
                        var g = c.valid[0],
                            e = c.valid[1],
                            d = e - g;
                        for (const h of b) {
                            let p = Infinity,
                                l = -Infinity;
                            h.forEach(n => {
                                let u = n[0];
                                for (; u < g;) u += d;
                                for (; u > e;) u -= d;
                                p = Math.min(p, u);
                                l = Math.max(l, u);
                                n[0] = u
                            });
                            b = l - p;
                            d - b < b && h.forEach(n => {
                                0 > n[0] && (n[0] += d)
                            })
                        }
                    }
                }
                a.closeRings = function(b) {
                    if ("rings" in b)
                        for (const c of b.rings) 3 > c.length || c[0][0] === c[c.length - 1][0] && c[0][1] === c[c.length - 1][1] || c.push([c[0][0], c[0][1]])
                };
                a.closeRingsAndFixWinding = function(b) {
                    if ("rings" in b) {
                        for (var c of b.rings) 3 > c.length || c[0][0] === c[c.length - 1][0] && c[0][1] === c[c.length - 1][1] || c.push([c[0][0],
                            c[0][1]
                        ]);
                        if (0 < b.rings.length && !r(b.rings[0], b.hasM, b.hasZ))
                            for (c = 0; c < b.rings.length; ++c) b.rings[c] = b.rings[c].reverse()
                    }
                };
                a.computeUnnormalizedVertexPositionsOnDateLineCrossing = function(b, c, g, e) {
                    let d = Infinity,
                        h = -Infinity;
                    b.forEach(l => {
                        let n = l.pos[0];
                        for (; n < c;) n += e;
                        for (; n > g;) n -= e;
                        d = Math.min(d, n);
                        h = Math.max(h, n);
                        l.unnormalizedPos[0] = n;
                        l.unnormalizedPos[1] = l.pos[1];
                        2 < l.pos.length && (l.unnormalizedPos[2] = l.pos[2]);
                        3 < l.pos.length && (l.unnormalizedPos[3] = l.pos[3])
                    });
                    const p = h - d;
                    e - p < p && b.forEach(l => {
                        0 > l.unnormalizedPos[0] &&
                            (l.unnormalizedPos[0] += e)
                    })
                };
                a.geometryToCoordinates = function(b) {
                    if (!b) return null;
                    if (Array.isArray(b)) return b;
                    const c = b.hasZ,
                        g = b.hasM;
                    if ("point" === b.type) return g && c ? [b.x, b.y, b.z, b.m] : c ? [b.x, b.y, b.z] : g ? [b.x, b.y, b.m] : [b.x, b.y];
                    if ("polygon" === b.type) return b.rings.slice(0);
                    if ("polyline" === b.type) return b.paths.slice(0);
                    if ("multipoint" === b.type) return b.points.slice(0);
                    if ("extent" === b.type) {
                        b = b.clone().normalize();
                        if (!b) return null;
                        let e = !1,
                            d = !1;
                        b.forEach(h => {
                            h.hasZ && (e = !0);
                            h.hasM && (d = !0)
                        });
                        return b.map(h => {
                            const p = [
                                [h.xmin, h.ymin],
                                [h.xmin, h.ymax],
                                [h.xmax, h.ymax],
                                [h.xmax, h.ymin],
                                [h.xmin, h.ymin]
                            ];
                            if (e && h.hasZ) {
                                var l = .5 * (h.zmax - h.zmin);
                                for (let n = 0; n < p.length; n++) p[n].push(l)
                            }
                            if (d && h.hasM)
                                for (h = .5 * (h.mmax - h.mmin), l = 0; l < p.length; l++) p[l].push(h);
                            return p
                        })
                    }
                    return null
                };
                a.getLength = w;
                a.getMidpoint = function(b, c) {
                    return t(b, c, .5)
                };
                a.getPathLength = function(b) {
                    const c = b.length;
                    let g = 0;
                    for (let e = 0; e < c - 1; ++e) g += w(b[e], b[e + 1]);
                    return g
                };
                a.getPointOnPath = function(b, c) {
                    if (0 >= c) return b[0];
                    const g = b.length;
                    let e =
                        0;
                    for (let d = 0; d < g - 1; ++d) {
                        const h = w(b[d], b[d + 1]);
                        if (c - e < h) return t(b[d], b[d + 1], (c - e) / h);
                        e += h
                    }
                    return b[g - 1]
                };
                a.getRingArea = function(b) {
                    const c = b.length;
                    let g = 0;
                    for (let e = 0; e < c; e++) {
                        const d = b[e],
                            h = b[(e + 1) % c];
                        g += d[0] * h[1] - h[0] * d[1]
                    }
                    return g
                };
                a.isClockwise = r;
                a.projectPointOnLine = function(b, c, g, e) {
                    const [d, h] = c, [p, l] = g[e], [n, u] = g[e + 1];
                    c = n - p;
                    g = u - l;
                    e = Math.min(1, Math.max(0, ((d - p) * c + (h - l) * g) / (c * c + g * g)));
                    b[0] = p + c * e;
                    b[1] = l + g * e;
                    return b
                };
                a.unnormalizeGeometryOnDatelineCrossing = function(b) {
                    if ("polygon" !== b.type &&
                        "polyline" !== b.type) return b;
                    f("polygon" === b.type ? b.rings : b.paths, b.spatialReference);
                    return b
                };
                a.unnormalizeVerticesOnDatelineCrossing = f;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/centroid": function() {
            define(["exports", "./coordsUtils"], function(a, k) {
                function w(f, b) {
                    if (!f || !f.length) return null;
                    const c = [],
                        g = [],
                        e = b ? [Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity] : [Infinity, -Infinity, Infinity, -Infinity];
                    for (let h = 0, p = f.length; h < p; h++) {
                        var d = t(f[h], b, e);
                        d && g.push(d)
                    }
                    g.sort((h,
                        p) => {
                        let l = h[2] - p[2];
                        0 === l && b && (l = h[4] - p[4]);
                        return l
                    });
                    g.length && (d = 6 * g[0][2], c[0] = g[0][0] / d, c[1] = g[0][1] / d, b && (d = 6 * g[0][4], c[2] = 0 !== d ? g[0][3] / d : 0), c[0] < e[0] || c[0] > e[1] || c[1] < e[2] || c[1] > e[3] || b && (c[2] < e[4] || c[2] > e[5])) && (c.length = 0);
                    if (!c.length)
                        if (f = f[0] && f[0].length ? r(f[0], b) : null) c[0] = f[0], c[1] = f[1], b && 2 < f.length && (c[2] = f[2]);
                        else return null;
                    return c
                }

                function t(f, b, c) {
                    let g = 0,
                        e = 0,
                        d = 0,
                        h = 0,
                        p = 0;
                    for (let l = 0; l < f.length; l++) {
                        const n = f[l],
                            [u, y, x] = n,
                            q = f[(l + 1) % f.length],
                            [B, z, v] = q;
                        let A = u * z - B * y;
                        h += A;
                        g +=
                            (u + B) * A;
                        e += (y + z) * A;
                        b && 2 < n.length && 2 < q.length && (A = u * v - B * x, d += (x + v) * A, p += A);
                        u < c[0] && (c[0] = u);
                        u > c[1] && (c[1] = u);
                        y < c[2] && (c[2] = y);
                        y > c[3] && (c[3] = y);
                        b && (x < c[4] && (c[4] = x), x > c[5] && (c[5] = x))
                    }
                    0 < h && (h *= -1);
                    0 < p && (p *= -1);
                    if (!h) return null;
                    f = [g, e, .5 * h];
                    b && (f[3] = d, f[4] = .5 * p);
                    return f
                }

                function r(f, b) {
                    const c = b ? [0, 0, 0] : [0, 0],
                        g = b ? [0, 0, 0] : [0, 0];
                    let e = 0,
                        d = 0,
                        h = 0,
                        p = 0;
                    for (let n = 0, u = f.length; n < u - 1; n++) {
                        var l = f[n];
                        const y = f[n + 1];
                        if (l && y) {
                            c[0] = l[0];
                            c[1] = l[1];
                            g[0] = y[0];
                            g[1] = y[1];
                            b && 2 < l.length && 2 < y.length && (c[2] = l[2], g[2] = y[2]);
                            const x = k.getLength(c, g);
                            x && (e += x, l = k.getMidpoint(l, y), d += x * l[0], h += x * l[1], b && 2 < l.length && (p += x * l[2]))
                        }
                    }
                    return 0 < e ? b ? [d / e, h / e, p / e] : [d / e, h / e] : f.length ? f[0] : null
                }
                a.extentCentroid = function(f) {
                    return f ? f.hasZ ? [f.xmax - f.xmin / 2, f.ymax - f.ymin / 2, f.zmax - f.zmin / 2] : [f.xmax - f.xmin / 2, f.ymax - f.ymin / 2] : null
                };
                a.lineCentroid = r;
                a.polygonCentroid = function(f) {
                    return f ? w(f.rings, f.hasZ) : null
                };
                a.ringsCentroid = w;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/extentUtils": function() {
            define(["exports",
                "./boundsUtils"
            ], function(a, k) {
                function w(g, e = !1, d = !1) {
                    return e ? d ? {
                        xmin: g[0],
                        ymin: g[1],
                        zmin: g[2],
                        mmin: g[3],
                        xmax: g[4],
                        ymax: g[5],
                        zmax: g[6],
                        mmax: g[7]
                    } : {
                        xmin: g[0],
                        ymin: g[1],
                        zmin: g[2],
                        xmax: g[3],
                        ymax: g[4],
                        zmax: g[5]
                    } : d ? {
                        xmin: g[0],
                        ymin: g[1],
                        mmin: g[2],
                        xmax: g[3],
                        ymax: g[4],
                        mmax: g[5]
                    } : {
                        xmin: g[0],
                        ymin: g[1],
                        xmax: g[2],
                        ymax: g[3]
                    }
                }

                function t(g) {
                    const {
                        hasZ: e,
                        hasM: d,
                        points: h
                    } = g;
                    return w(k.getPointsBounds(c, h, e, d), e, d)
                }

                function r(g) {
                    const {
                        x: e,
                        y: d,
                        z: h,
                        m: p
                    } = g;
                    g = null != p;
                    return null != h ? g ? {
                        xmin: e,
                        ymin: d,
                        zmin: h,
                        mmin: p,
                        xmax: e,
                        ymax: d,
                        zmax: h,
                        mmax: p
                    } : {
                        xmin: e,
                        ymin: d,
                        zmin: h,
                        xmax: e,
                        ymax: d,
                        zmax: h
                    } : g ? {
                        xmin: e,
                        ymin: d,
                        mmin: p,
                        xmax: e,
                        ymax: d,
                        mmax: p
                    } : {
                        xmin: e,
                        ymin: d,
                        xmax: e,
                        ymax: d
                    }
                }

                function f(g) {
                    const {
                        hasZ: e,
                        hasM: d,
                        rings: h
                    } = g;
                    return (g = k.getRingsOrPathsBounds(c, h, e, d)) ? w(g, e, d) : null
                }

                function b(g) {
                    const {
                        hasZ: e,
                        hasM: d,
                        paths: h
                    } = g;
                    return (g = k.getRingsOrPathsBounds(c, h, e, d)) ? w(g, e, d) : null
                }
                const c = [];
                a.getGeometryExtent = function(g) {
                    return g ? void 0 !== g.xmin && void 0 !== g.ymin && void 0 !== g.xmax && void 0 !== g.ymax ? g : void 0 !== g.x && void 0 !== g.y ? r(g) :
                        void 0 !== g.rings ? f(g) : void 0 !== g.paths ? b(g) : void 0 !== g.points ? t(g) : null : null
                };
                a.getMultipointExtent = t;
                a.getPointExtent = r;
                a.getPolygonExtent = f;
                a.getPolylineExtent = b;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/boundsUtils": function() {
            define(["exports"], function(a) {
                function k(g) {
                    return void 0 !== g.xmin && void 0 !== g.ymin && void 0 !== g.xmax && void 0 !== g.ymax
                }

                function w(g) {
                    return (e, d) => null == e ? d : null == d ? e : g(e, d)
                }

                function t(g, e, d, h) {
                    const p = d ? 3 : 2;
                    if (!e.length || !e[0].length) return null;
                    let [l, n] = e[0][0], [u, y] = e[0][0], x = void 0, q = void 0, B = void 0;
                    var z = void 0;
                    for (let v = 0; v < e.length; v++) {
                        const A = e[v];
                        for (let m = 0; m < A.length; m++) {
                            const E = A[m],
                                [C, G] = E;
                            l = b(l, C);
                            n = b(n, G);
                            u = c(u, C);
                            y = c(y, G);
                            if (d && 2 < E.length) {
                                const F = E[2];
                                x = b(x, F);
                                q = c(q, F)
                            }
                            h && E.length > p && (z = E[p], B = b(x, z), z = c(q, z))
                        }
                    }
                    if (d) {
                        if (h) return g[0] = l, g[1] = n, g[2] = x, g[3] = B, g[4] = u, g[5] = y, g[6] = q, g[7] = z, g.length = 8, g;
                        g[0] = l;
                        g[1] = n;
                        g[2] = x;
                        g[3] = u;
                        g[4] = y;
                        g[5] = q;
                        g.length = 6;
                        return g
                    }
                    if (h) return g[0] = l, g[1] = n, g[2] = B, g[3] = u, g[4] = y, g[5] = z, g.length =
                        6, g;
                    g[0] = l;
                    g[1] = n;
                    g[2] = u;
                    g[3] = y;
                    g.length = 4;
                    return g
                }

                function r(g, e, d, h, p, l) {
                    d = e.xmin;
                    h = e.xmax;
                    const n = e.ymin,
                        u = e.ymax;
                    let y = e.zmin,
                        x = e.zmax,
                        q = e.mmin;
                    e = e.mmax;
                    if (p) {
                        y = y || 0;
                        x = x || 0;
                        if (l) return g[0] = d, g[1] = n, g[2] = y, g[3] = q || 0, g[4] = h, g[5] = u, g[6] = x, g[7] = e || 0, g;
                        g[0] = d;
                        g[1] = n;
                        g[2] = y;
                        g[3] = h;
                        g[4] = u;
                        g[5] = x;
                        return g
                    }
                    if (l) return g[0] = d, g[1] = n, g[2] = q || 0, g[3] = h, g[4] = u, g[5] = e || 0, g;
                    g[0] = d;
                    g[1] = n;
                    g[2] = h;
                    g[3] = u;
                    return g
                }

                function f(g, e, d, h, p, l) {
                    const n = d ? 3 : 2;
                    h = h && l;
                    d = d && p;
                    if (!e.length || !e[0].length) return null;
                    let [u,
                        y
                    ] = e[0], [x, q] = e[0], B = void 0, z = void 0, v = void 0;
                    var A = void 0;
                    for (let m = 0; m < e.length; m++) {
                        const E = e[m],
                            [C, G] = E;
                        u = b(u, C);
                        y = b(y, G);
                        x = c(x, C);
                        q = c(q, G);
                        if (d && 2 < E.length) {
                            const F = E[2];
                            B = b(B, F);
                            z = c(z, F)
                        }
                        h && E.length > n && (A = E[n], v = b(B, A), A = c(z, A))
                    }
                    if (p) {
                        B = B || 0;
                        z = z || 0;
                        if (l) return g[0] = u, g[1] = y, g[2] = B, g[3] = v || 0, g[4] = x, g[5] = q, g[6] = z, g[7] = A || 0, g;
                        g[0] = u;
                        g[1] = y;
                        g[2] = B;
                        g[3] = x;
                        g[4] = q;
                        g[5] = z;
                        return g
                    }
                    if (l) return g[0] = u, g[1] = y, g[2] = v || 0, g[3] = x, g[4] = q, g[5] = A || 0, g;
                    g[0] = u;
                    g[1] = y;
                    g[2] = x;
                    g[3] = q;
                    return g
                }
                const b = w(Math.min),
                    c = w(Math.max);
                a.getBoundsXY = function(g, e) {
                    if (void 0 !== e.paths) return t(g, e.paths, !1, !1);
                    if (void 0 !== e.rings) return t(g, e.rings, !1, !1);
                    if (void 0 !== e.points) return f(g, e.points, !1, !1, !1, !1);
                    if (k(e)) return r(g, e);
                    void 0 !== e.x && void 0 !== e.y && (g[0] = e.x, g[1] = e.y, g[2] = e.x, g[3] = e.y);
                    return g
                };
                a.getBoundsXYZ = function(g, e) {
                    if (void 0 !== e.paths) return t(g, e.paths, !0, !1);
                    if (void 0 !== e.rings) return t(g, e.rings, !0, !1);
                    if (void 0 !== e.points) return f(g, e.points, !0, !1, !0, !1);
                    if (k(e)) return r(g, e, !0, !1, !0, !1);
                    void 0 !==
                        e.x && void 0 !== e.y && (g[0] = e.x, g[1] = e.y, g[2] = e.z, g[3] = e.x, g[4] = e.y, g[5] = e.z);
                    return g
                };
                a.getExtentBounds = r;
                a.getPointsBounds = f;
                a.getPointsBoundsCenterX = function(g) {
                    if (!g.length || !g[0].length) return null;
                    let [e] = g[0], [d] = g[0];
                    for (let h = 0; h < g.length; h++) {
                        const [p] = g[h];
                        e = b(e, p);
                        d = c(d, p)
                    }
                    return e + .5 * (d - e)
                };
                a.getPointsBoundsWidth = function(g) {
                    if (!g.length || !g[0].length) return null;
                    let [e] = g[0], [d] = g[0];
                    for (let h = 0; h < g.length; h++) {
                        const [p] = g[h];
                        e = b(e, p);
                        d = c(d, p)
                    }
                    return d - e
                };
                a.getRingsOrPathsBounds = t;
                Object.defineProperty(a,
                    "__esModule", {
                        value: !0
                    })
            })
        },
        "esri/geometry/Polyline": function() {
            define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/has ../core/lang ../core/Logger ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/jsonMap ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/urlUtils ../core/uuid ../portal/support/resourceExtension ./SpatialReference ./Geometry ./Point ./Extent ./support/zmUtils ./support/extentUtils".split(" "),
                function(a, k, w, t, r, f, b, c, g, e, d, h, p, l, n, u, y, x, q) {
                    var B;
                    w = B = function(z) {
                        function v(...m) {
                            m = z.call(this, ...m) || this;
                            m.paths = [];
                            m.type = "polyline";
                            return m
                        }
                        a._inheritsLoose(v, z);
                        var A = v.prototype;
                        A.normalizeCtorArgs = function(m, E) {
                            let C = null,
                                G, F, D = null;
                            m && !Array.isArray(m) ? (C = m.paths ? m.paths : null, E || (m.spatialReference ? E = m.spatialReference : m.paths || (E = m)), G = m.hasZ, F = m.hasM) : C = m;
                            C = C || [];
                            E = E || l.WGS84;
                            C.length && C[0] && null != C[0][0] && "number" === typeof C[0][0] && (C = [C]);
                            if (D = C[0] && C[0][0]) void 0 === G && void 0 ===
                                F ? (G = 2 < D.length, F = !1) : void 0 === G ? G = !F && 3 < D.length : void 0 === F && (F = !G && 3 < D.length);
                            return {
                                paths: C,
                                spatialReference: E,
                                hasZ: G,
                                hasM: F
                            }
                        };
                        A.writePaths = function(m, E) {
                            E.paths = t.clone(this.paths)
                        };
                        A.addPath = function(m) {
                            if (m) {
                                var E = this.paths,
                                    C = E.length;
                                if (Array.isArray(m[0])) E[C] = m.concat();
                                else {
                                    const G = [];
                                    for (let F = 0, D = m.length; F < D; F++) G[F] = m[F].toArray();
                                    E[C] = G
                                }
                                this.notifyChange("paths");
                                return this
                            }
                        };
                        A.clone = function() {
                            const m = new B;
                            m.spatialReference = this.spatialReference;
                            m.paths = t.clone(this.paths);
                            m.hasZ =
                                this.hasZ;
                            m.hasM = this.hasM;
                            return m
                        };
                        A.getPoint = function(m, E) {
                            if (!this._validateInputs(m, E)) return null;
                            m = this.paths[m][E];
                            E = this.hasZ;
                            const C = this.hasM;
                            return E && !C ? new u(m[0], m[1], m[2], void 0, this.spatialReference) : C && !E ? new u(m[0], m[1], void 0, m[2], this.spatialReference) : E && C ? new u(m[0], m[1], m[2], m[3], this.spatialReference) : new u(m[0], m[1], this.spatialReference)
                        };
                        A.insertPoint = function(m, E, C) {
                            if (!this._validateInputs(m, E, !0)) return this;
                            x.updateSupportFromPoint(this, C);
                            Array.isArray(C) || (C = C.toArray());
                            this.paths[m].splice(E, 0, C);
                            this.notifyChange("paths");
                            return this
                        };
                        A.removePath = function(m) {
                            if (!this._validateInputs(m, null)) return null;
                            m = this.paths.splice(m, 1)[0];
                            const E = this.spatialReference;
                            m = m.map(C => new u(C, E));
                            this.notifyChange("paths");
                            return m
                        };
                        A.removePoint = function(m, E) {
                            if (!this._validateInputs(m, E)) return null;
                            m = new u(this.paths[m].splice(E, 1)[0], this.spatialReference);
                            this.notifyChange("paths");
                            return m
                        };
                        A.setPoint = function(m, E, C) {
                            if (!this._validateInputs(m, E)) return this;
                            x.updateSupportFromPoint(this,
                                C);
                            Array.isArray(C) || (C = C.toArray());
                            this.paths[m][E] = C;
                            this.notifyChange("paths");
                            return this
                        };
                        A._validateInputs = function(m, E, C = !1) {
                            return null == m || 0 > m || m >= this.paths.length || null != E && (m = this.paths[m], C && (0 > E || E > m.length) || !C && (0 > E || E >= m.length)) ? !1 : !0
                        };
                        A.toJSON = function(m) {
                            return this.write(null, m)
                        };
                        a._createClass(v, [{
                            key: "cache",
                            get: function() {
                                this.commitProperty("paths");
                                this.commitProperty("hasZ");
                                this.commitProperty("hasM");
                                this.commitProperty("spatialReference");
                                return {}
                            }
                        }, {
                            key: "extent",
                            get: function() {
                                const {
                                    spatialReference: m
                                } =
                                this;
                                var E = q.getPolylineExtent(this);
                                if (!E) return null;
                                E = new y(E);
                                E.spatialReference = m;
                                return E
                            }
                        }]);
                        return v
                    }(n);
                    k.__decorate([b.property({
                        readOnly: !0
                    })], w.prototype, "cache", null);
                    k.__decorate([b.property({
                        readOnly: !0
                    })], w.prototype, "extent", null);
                    k.__decorate([b.property({
                        type: [
                            [
                                [Number]
                            ]
                        ],
                        json: {
                            write: {
                                isRequired: !0
                            }
                        }
                    })], w.prototype, "paths", void 0);
                    k.__decorate([e.writer("paths")], w.prototype, "writePaths", null);
                    w = B = k.__decorate([g.subclass("esri.geometry.Polyline")], w);
                    w.prototype.toJSON.isDefaultToJSON = !0;
                    return w
                })
        },
        "esri/geometry/support/typeUtils": function() {
            define(["exports", "../../core/jsonMap"], function(a, k) {
                const w = k.strict()({
                    esriGeometryPoint: "point",
                    esriGeometryMultipoint: "multipoint",
                    esriGeometryPolyline: "polyline",
                    esriGeometryPolygon: "polygon"
                });
                k = k.strict()({
                    esriGeometryPoint: "point",
                    esriGeometryMultipoint: "multipoint",
                    esriGeometryPolyline: "polyline",
                    esriGeometryPolygon: "polygon",
                    esriGeometryEnvelope: "extent",
                    mesh: "mesh"
                });
                a.featureGeometryTypeKebabDictionary = w;
                a.isFeatureGeometryType =
                    function(t) {
                        return "point" === t || "multipoint" === t || "polyline" === t || "polygon" === t
                    };
                a.typeKebabDictionary = k;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "esri/geometry/support/jsonUtils": function() {
            define("exports ../Geometry ../Point ../Extent ../Multipoint ../Polygon ../Polyline".split(" "), function(a, k, w, t, r, f, b) {
                function c(n) {
                    return void 0 !== n.xmin && void 0 !== n.ymin && void 0 !== n.xmax && void 0 !== n.ymax
                }

                function g(n) {
                    return void 0 !== n.points
                }

                function e(n) {
                    return void 0 !== n.x && void 0 !== n.y
                }

                function d(n) {
                    return void 0 !==
                        n.paths
                }

                function h(n) {
                    return void 0 !== n.rings
                }

                function p(n) {
                    return n ? n instanceof k ? n : e(n) ? w.fromJSON(n) : d(n) ? b.fromJSON(n) : h(n) ? f.fromJSON(n) : g(n) ? r.fromJSON(n) : c(n) ? t.fromJSON(n) : null : null
                }
                const l = {
                    esriGeometryPoint: w,
                    esriGeometryPolyline: b,
                    esriGeometryPolygon: f,
                    esriGeometryEnvelope: t,
                    esriGeometryMultipoint: r
                };
                a.fromJSON = p;
                a.fromJson = function(n) {
                    try {
                        throw Error("fromJson is deprecated, use fromJSON instead");
                    } catch (u) {
                        console.warn(u.stack)
                    }
                    return p(n)
                };
                a.getGeometryType = function(n) {
                    return n && l[n] ||
                        null
                };
                a.getJsonType = function(n) {
                    return n ? e(n) ? "esriGeometryPoint" : d(n) ? "esriGeometryPolyline" : h(n) ? "esriGeometryPolygon" : c(n) ? "esriGeometryEnvelope" : g(n) ? "esriGeometryMultipoint" : null : null
                };
                a.isExtent = c;
                a.isMesh = function(n) {
                    return void 0 !== n.vertexAttributes
                };
                a.isMultipoint = g;
                a.isPoint = e;
                a.isPolygon = h;
                a.isPolyline = d;
                Object.defineProperty(a, "__esModule", {
                    value: !0
                })
            })
        },
        "*noref": 1
    }
});
require.boot && require.apply(null, require.boot);